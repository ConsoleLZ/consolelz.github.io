[{"title":"centos搭建gitlab私服","path":"/2025/05/13/104/","content":"初始化配置1. 编辑 /etc/resolv.conf，添加公共 DNSnameserver 8.8.8.8 nameserver 114.114.114.114 2. 更换yum镜像源备份原来的 repo 文件 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载阿里云的 CentOS 7 repo 文件 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 清除旧缓存 yum clean all 生成新的缓存 yum makecache 3. 安装wget下载器yum install -y wget 下载GitLab安装包wget https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.12.12-ce.0.el7.x86_64.rpm/download.rpm -O gitlab-ce-13.12.12-ce.0.el7.x86_64.rpm 依赖安装# 安装一些依赖 sudo yum install -y curl policycoreutils-python openssh-server perl # Enable OpenSSH server daemon if not enabled: sudo systemctl status sshd sudo systemctl enable sshd sudo systemctl start sshd # Check if opening the firewall is needed with: sudo systemctl status firewalld sudo firewall-cmd --permanent --add-service=http sudo firewall-cmd --permanent --add-service=https sudo systemctl reload firewalld # 安装邮箱所需要的软件包 sudo yum install -y postfix sudo systemctl enable postfix sudo systemctl start postfix 软件安装rpm -ivh gitlab-ce-13.12.12-ce.0.el7.x86_64.rpm 配置修改 /etc/gitlab/gitlab.rb 文件，这一行如果有专门的域名那么就写域名，如果没有域名那么就写IP地址。 更多配置，如邮箱、ssl(https)、redis、nginx、数据库等，可以参考官方文档，文档地址： https://docs.gitlab.com/omnibus/settings/ 执行以下命令使配置生效（可能时间有点长）： gitlab-ctl reconfigure 看到这个则配置成功： 常用命令# 启动gitlab gitlab-ctl start # 停止gitlab gitlab-ctl stop # 重启gitlab gitlab-ctl restart # 查看gitlab状态 gitlab-ctl status # 查看gitlab日志 gitlab-ctl tail 访问运行后，直接访问服务器的80端口 更多操作请查看：CentOS7上使用GitLab搭建私有git代码仓库（超详细）_centos7怎么设置代码库-CSDN博客","categories":["linux"]},{"title":"ADC两种测量电压方式","path":"/2025/05/07/103/","content":"逐次逼近型ADC测量电压通过不断缩小输入电压与参考电压之间的差异，逐步逼近输入电压的真实值，并将其转换成对应的数字形式 1. 外部供电电压作为参考公式：(Vref: 外部参考电压， Vin：输入电压)$$ADC读数 &#x3D; \\frac{Vin}{Vref} . (2^n - 1) &#x3D;&gt; Vin &#x3D; \\frac{ADC读数}{2^n - 1} . Vref$$这个方法适合用于外部参考电压已知且稳定的情况，比如使用LDO供电给MCU和ADC，可以测量外部模拟信号电压 2. 内部基准电压作为参考这种情况下，ADC采集的是一个与供电电压相关的比例值。内部基准电压是一个已知的精确电压，而ADC的参考电压是未知的供电电压（VDD）。此时通过反推来计算实际供电电压。 公式：（Vrefinternal: 内部基准电压，Vdd：外部供电电压）$$ADC读数 &#x3D; \\frac{Vrefinternal}{Vdd} . (2^n - 1)$$这可以用来测量当前系统的供电电压（比如电池电压），当没有外部参考时非常有用 相当于去测量内部已知的内部基准电压，此时Vin &#x3D; Vrefinternal, 而把供电的电压Vdd作为参考，反推代入公式即可得到","categories":["单片机"]},{"title":"C语言格式化文件配置","path":"/2025/03/04/102/","content":".clang-format BasedOnStyle: LLVM IndentWidth: 4 UseTab: Never ColumnLimit: 80 PointerAlignment: Left BreakBeforeBraces: Attach AllowShortLoopsOnASingleLine: true AllowShortIfStatementsOnASingleLine: true AllowShortFunctionsOnASingleLine: InlineOnly SortIncludes: true AlignTrailingComments: true","categories":["C语言"]},{"title":"分享一个小智AI接线图","path":"/2025/01/29/101/","content":"如有侵权，请联系作者哦！！！","categories":["硬件开发"]},{"title":"github使用actions完成自动化部署","path":"/2025/01/24/100/","content":"我的第100篇文章，长路漫漫，唯有坚持才能成功 创建部署文件在根目录下创建：.github&#x2F;workflows&#x2F;xx.yml文件 name: GitHub Actions Build and Deploy Demo on: push: branches: - main jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Setup Node.js uses: actions/setup-node@v4 with: node-version: 18 - name: Checkout uses: actions/checkout@v4 - name: Install and Build run: | npm install npm run-script build - name: Deploy uses: JamesIves/github-pages-deploy-action@releases/v3 with: ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; BRANCH: build FOLDER: dist 确保构建分支存在 打开actions的权限在仓库的设置界面： 最后上传代码即可自动构建部署","tags":["github"]},{"title":"mysql允许局域网内的远程连接","path":"/2025/01/04/98/","content":"平台：termux-app服务器版本: 8.0.40-0ubuntu0.20.04.1 修改配置文件默认在：&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf bind-address改为0.0.0.0即可 执行一堆命令mysql&gt;use mysql; mysql&gt;select host from user where user=&#x27;root&#x27;; mysql&gt;update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;; mysql&gt;flush privileges; 修改用户认证方式和设置密码mysql&gt;ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;your_secure_password&#x27;; mysql&gt;flush privileges; 最后重启mysql服务即可 sudo service mysql restart","tags":["mysql"],"categories":["服务器"]},{"title":"ubuntu安装redis并配置远程连接","path":"/2025/01/04/99/","content":"安装sudo apt update sudo apt upgrade sudo apt install redis-server 配置远程连接修改配置文件: vim /etc/redis/redis.conf # 注释掉绑定地址#bind 127.0.0.1，让Redis可远程访问 # bind 127.0.0.1 ::1 #取消注释requirepass 启动密码认证，并设置访问密码 requirepass your-pass-word # 以守护进程运行Redis daemonize yes # 禁用保护模式 protected-mode no 启动redissudo service redis-server start","tags":["redis"],"categories":["服务器"]},{"title":"安卓安装ubuntu环境和mysql","path":"/2025/01/01/97/","content":"摘自文章：https://blog.csdn.net/m0_49073940/article/details/127779168 下载termux-app地址：https://github.com/termux/termux-app/releases 更新源apt update 更新软件apt upgrade -y 安装wget和prootapt install wget proot -y 获取安装脚本wget https://github.com/xiliuya/termux-linux/releases/download/untagged-d42e22a770f3c95aac45/install_linux.sh 执行安装脚本chmod +x install_linux.sh &amp;&amp; ./install_linux.sh 启动ubuntu./start-ubuntu.sh 安装mysqlsudo apt update sudo apt install mysql-server -y 运行mysqlsudo service mysql start","tags":["软件"],"categories":["服务器"]},{"title":"创建自己的脚手架","path":"/2024/11/11/96/","content":"前言所谓脚手架,就是提前写好一些固定的文件模板,所以你需要先上传自己的模板到git仓库 配置文件config.js这个里面可以写你所有项目模板 const projectList = &#123; vueRouter: &quot;https://github.com/ConsoleLZ/vue-router-cli.git&quot; &#125;; module.exports = projectList; 主要逻辑index.js#!/usr/bin/env node const &#123; program &#125; = require(&quot;commander&quot;); const chalk = require(&quot;chalk&quot;); const figlet = require(&quot;figlet&quot;); const inquirer = require(&quot;inquirer&quot;); const fs = require(&quot;fs-extra&quot;); const path = require(&quot;path&quot;); const gitClone = require(&quot;git-clone&quot;); const ora = require(&quot;ora&quot;); // 项目列表 const projectList = require(&quot;./config.js&quot;) const choices = [] for(let key in projectList)&#123; choices.push(&#123; name: key, value: key &#125;) &#125; // 首行提示 program.name(&quot;lz-cli&quot;).usage(&quot;&lt;command&gt; [options]&quot;); console.log(chalk.black.bgWhite.bold(&#x27;🎉🎉 欢迎使用小哲的个人脚手架&#x27;)); // 添加命令 program .command(&quot;create &lt;app-name&gt;&quot;) .description(&quot;创建一个项目&quot;) .action(async appName =&gt; &#123; const targetPath = path.join(process.cwd(), appName); if (fs.existsSync(targetPath)) &#123; const answer = await inquirer.prompt([ &#123; message: &quot;项目已存在，是否覆盖？&quot;, type: &quot;confirm&quot;, name: &quot;isOver&quot;, default: &quot;false&quot;, &#125;, ]); if (answer.isOver) &#123; fs.remove(targetPath); console.log(chalk.blue(&quot;移除成功&quot;)); &#125; else &#123; return; &#125; &#125; // 新建项目 const result = await inquirer.prompt([ &#123; type: &quot;list&quot;, message: &quot;选择要创建的项目&quot;, default: &quot;vueRouter&quot;, name: &quot;framework&quot;, choices &#125; ]); const key = result.framework const gitUrl = projectList[key]; const spinner = ora(&quot;正在下载模板...&quot;).start(); gitClone(gitUrl, appName, &#123; checkout: &quot;main&quot; &#125;, () =&gt; &#123; spinner.succeed(chalk.blue.bold(&quot;项目创建成功&quot;)); console.log(&quot;&quot;); console.log(chalk.blue.bold(figlet.textSync(&quot;lz-cli&quot;, &#123;&#125;))); console.log(chalk.blue(&quot;感谢您的使用!&quot;)); &#125;); &#125;); // 版本号 program.version(`$&#123;require(&quot;../package.json&quot;).version&#125;`); // 监听 --help program.on(&quot;--help&quot;, () =&gt; &#123; console.log(chalk.green.bold(figlet.textSync(&quot;lz-cli&quot;, &#123;&#125;))); &#125;); program.parse(program.argv); package.json文件&#123; &quot;name&quot;: &quot;love-lz-cli&quot;, &quot;version&quot;: &quot;0.0.6&quot;, &quot;description&quot;: &quot;小哲的个人脚手架&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;bin&quot;: &#123; &quot;lz-cli&quot;: &quot;./bin/index.js&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;chalk&quot;: &quot;^4.0.0&quot;, &quot;commander&quot;: &quot;^12.1.0&quot;, &quot;figlet&quot;: &quot;^1.8.0&quot;, &quot;fs-extra&quot;: &quot;^11.2.0&quot;, &quot;git-clone&quot;: &quot;^0.2.0&quot;, &quot;inquirer&quot;: &quot;8.0.0&quot;, &quot;ora&quot;: &quot;5.0.0&quot; &#125; &#125; 完成npm link lz-cli现在就可以全局使用了 完整代码请参考: https://github.com/ConsoleLZ/love-lz-cli","tags":["node"],"categories":["前端进阶"]},{"title":"minisearch模糊搜索","path":"/2024/10/22/95/","content":"import MiniSearch from &#x27;minisearch&#x27; const tokenizer = (str) =&gt; &#123; // 分词逻辑，返回完整的单词以及单词的部分片段 const words = str.match(/[\\u4e00-\\u9fa5]+|[a-zA-Z0-9]+/g) || []; const subStrings = []; words.forEach(word =&gt; &#123; if (/^[a-zA-Z0-9]+$/.test(word)) &#123; // 英文或数字 // 生成所有可能的子串 for (let i = 1; i &lt;= word.length; i++) &#123; subStrings.push(...word.slice(0, i)); &#125; &#125; else &#123; // 中文 // 生成所有可能的 n-gram 子串 for (let i = 1; i &lt;= word.length; i++) &#123; for (let j = 0; j &lt;= word.length - i; j++) &#123; subStrings.push(word.substring(j, j + i)); &#125; &#125; &#125; &#125;); return subStrings.filter((value, index, self) =&gt; self.indexOf(value) === index); // 去重 &#125;; let miniSearch = new MiniSearch(&#123; fields: [&#x27;name&#x27;, &#x27;description&#x27;], // 搜索哪些字段 storeFields: [&#x27;name&#x27;, &#x27;description&#x27;, &#x27;url&#x27;], // 返回哪些字段 tokenize: tokenizer &#125;) miniSearch.addAll(documents); // 配置搜索源 // 搜索 miniSearch.autoSuggest(&#x27;搜索词&#x27;, &#123; filter: (result) =&gt; &#123; // 处理搜索结果 searchData.value.push(&#123; name: result.name, description: result.description, url: result.url &#125;) return true &#125; &#125;)","tags":["minisearch"],"categories":["前端进阶"]},{"title":"unity常用代码片段","path":"/2024/10/20/94/","content":"2D平面游戏角色移动代码（PC端）using System.Collections; using System.Collections.Generic; using UnityEngine; public class controler : MonoBehaviour &#123; private Rigidbody2D rigidbody2D; private Animator animator; private float speed = 20f; // 移动速度 // Start is called before the first frame update void Start() &#123; rigidbody2D = GetComponent&lt;Rigidbody2D&gt;(); animator = GetComponent&lt;Animator&gt;(); &#125; // Update is called once per frame void Update() &#123; float horizontalInput = Input.GetAxisRaw(&quot;Horizontal&quot;); // 使用 GetAxisRaw float verticalInput = Input.GetAxisRaw(&quot;Vertical&quot;); // 使用 GetAxisRaw // 设置动画参数 if (horizontalInput != 0) &#123; animator.SetFloat(&quot;Horizontal&quot;, horizontalInput); animator.SetFloat(&quot;Vertical&quot;, 0); &#125; if (verticalInput != 0) &#123; animator.SetFloat(&quot;Vertical&quot;, verticalInput); animator.SetFloat(&quot;Horizontal&quot;, 0); &#125; Vector2 dir = new Vector2(horizontalInput, verticalInput); animator.SetFloat(&quot;Speed&quot;, dir.magnitude); // 初始化移动向量为零向量 Vector2 moveDirection = Vector2.zero; // 检查水平输入 if (horizontalInput != 0) &#123; moveDirection.x = horizontalInput; &#125; // 检查垂直输入 if (verticalInput != 0) &#123; moveDirection.y = verticalInput; &#125; // 检查是否只按了一个方向键 if ((Mathf.Abs(horizontalInput) + Mathf.Abs(verticalInput)) == 1) &#123; // 计算新的位置 Vector2 newPosition = rigidbody2D.position + (moveDirection * speed * Time.deltaTime); // 使用 MovePosition 移动角色 rigidbody2D.MovePosition(newPosition); &#125; &#125; &#125; 2D平面游戏角色移动代码（移动端）using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class MobilePlayerController : MonoBehaviour &#123; private Rigidbody2D rigidbody2D; private Animator animator; [SerializeField] private float speed = 3f; // 移动速度 private float horizontalInput = 0; private float verticalInput = 0; // Start is called before the first frame update void Start() &#123; rigidbody2D = GetComponent&lt;Rigidbody2D&gt;(); animator = GetComponent&lt;Animator&gt;(); &#125; // Update is called once per frame void Update() &#123; // 设置动画参数 if (horizontalInput != 0) &#123; animator.SetFloat(&quot;Horizontal&quot;, horizontalInput); animator.SetFloat(&quot;Vertical&quot;, 0); &#125; if (verticalInput != 0) &#123; animator.SetFloat(&quot;Vertical&quot;, verticalInput); animator.SetFloat(&quot;Horizontal&quot;, 0); &#125; Vector2 dir = new Vector2(horizontalInput, verticalInput); animator.SetFloat(&quot;Speed&quot;, dir.magnitude); MovePlayer(dir); &#125; // 向上移动 public void onPointerUp() &#123; verticalInput = 1; &#125; // 向下移动 public void onPointerDown() &#123; verticalInput = -1; &#125; // 向左移动 public void onPointerLeft() &#123; horizontalInput = -1; &#125; // 向右移动 public void onPointerRight() &#123; horizontalInput = 1; &#125; // 如果没有按任何按钮则静止 public void onIdle() &#123; // 在按钮释放时停止移动 horizontalInput = 0; verticalInput = 0; &#125; private void MovePlayer(Vector2 direction) &#123; // 计算新的位置 Vector2 newPosition = rigidbody2D.position + (direction * speed * Time.deltaTime); // 使用 MovePosition 移动角色 rigidbody2D.MovePosition(newPosition); &#125; &#125;","tags":["unity"],"categories":["游戏开发"]},{"title":"在浏览器环境中对github仓库进行增删改查","path":"/2024/10/19/93/","content":"基本配置const owner = &quot;ConsoleLZ&quot;; // 仓库所有者 const repo = &quot;githubAPI&quot;; // 仓库名称 const accessToken = &quot;???&quot;; // GitHub 个人访问令牌 const branch = &#x27;main&#x27; // 仓库分支 获取文件sha值的函数// 获取文件的sha值 async function getFileSha() &#123; if (!fileName.value) &#123; return &#125; const existingFileResponse = await fetch( `https://api.github.com/repos/$&#123;owner&#125;/$&#123;repo&#125;/contents/$&#123;fileName.value&#125;`, &#123; headers: &#123; Authorization: `Bearer $&#123;accessToken&#125;`, &#125;, &#125; ); if (existingFileResponse.ok) &#123; const existingFileData = await existingFileResponse.json(); return existingFileData.sha; &#125; else &#123; console.log(&#x27;仓库文件不存在&#x27;) return &#125; &#125; 查// 查询所有文件 async function findFileList() &#123; const fileList = await fetch( `https://api.github.com/repos/$&#123;owner&#125;/$&#123;repo&#125;/contents/`, &#123; headers: &#123; Authorization: `Bearer $&#123;accessToken&#125;`, &#125;, &#125; ).then(res=&gt;res.json()); console.log(fileList) &#125; 增或改// 新增或者更新文件 async function handleUploadFile() &#123; const file = fileInput.files[0]; if (!file || !fileName.value) &#123; alert(&quot;文件为空或者输入文件路径为空&quot;); return; &#125; const commitMessage = &quot;githubAPI&quot;; // 提交信息 // 获取文件的当前 SHA 值 let sha = await getFileSha(); // 将文件内容转换为 Base64 编码 const reader = new FileReader(); reader.onload = async function () &#123; const base64Content = btoa( new Uint8Array(reader.result).reduce( (data, byte) =&gt; data + String.fromCharCode(byte), &quot;&quot; ) ); // 创建或更新文件 const fileData = &#123; message: commitMessage, content: base64Content, sha, branch &#125;; const uploadResponse = await fetch( `https://api.github.com/repos/$&#123;owner&#125;/$&#123;repo&#125;/contents/$&#123;fileName.value&#125;`, &#123; method: &quot;PUT&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, Authorization: `Bearer $&#123;accessToken&#125;`, &#125;, body: JSON.stringify(fileData), &#125; ); if (uploadResponse.ok) &#123; alert(&#x27;文件上传成功&#x27;) &#125; else &#123; alert(&#x27;文件上传失败&#x27;) &#125; &#125;; reader.readAsArrayBuffer(file); &#125; 删// 删除文件 async function handleDeleteFile() &#123; const sha = await getFileSha() const message = &#x27;删除文件&#x27; if (sha) &#123; const deleteResponse = await fetch( `https://api.github.com/repos/$&#123;owner&#125;/$&#123;repo&#125;/contents/$&#123;fileName.value&#125;`, &#123; method: &quot;DELETE&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, Authorization: `Bearer $&#123;accessToken&#125;`, &#125;, body: JSON.stringify(&#123; message, sha, branch &#125;) &#125; ); if (!deleteResponse.ok) &#123; throw new Error(`Failed to delete file: $&#123;response.statusText&#125;`); &#125; alert(&#x27;文件删除成功&#x27;) &#125; else &#123; alert(&#x27;要删除的文件不存在&#x27;) &#125; &#125; 全部代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Upload File to GitHub&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;fileName&quot; placeholder=&quot;请选择文件路径&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;fileInput&quot; /&gt; &lt;button onclick=&quot;handleUploadFile()&quot;&gt;Upload File&lt;/button&gt; &lt;button style=&quot;background-color: brown;&quot; onclick=&quot;handleDeleteFile()&quot;&gt;删除&lt;/button&gt; &lt;script&gt; const fileInput = document.getElementById(&quot;fileInput&quot;); const fileName = document.getElementById(&quot;fileName&quot;); const owner = &quot;ConsoleLZ&quot;; // 仓库所有者 const repo = &quot;githubAPI&quot;; // 仓库名称 const accessToken = &quot;???&quot;; // GitHub 个人访问令牌 const branch = &#x27;main&#x27; // 仓库分支 // 新增或者更新文件 async function handleUploadFile() &#123; const file = fileInput.files[0]; if (!file || !fileName.value) &#123; alert(&quot;文件为空或者输入文件路径为空&quot;); return; &#125; const commitMessage = &quot;githubAPI&quot;; // 提交信息 // 获取文件的当前 SHA 值 let sha = await getFileSha(); // 将文件内容转换为 Base64 编码 const reader = new FileReader(); reader.onload = async function () &#123; const base64Content = btoa( new Uint8Array(reader.result).reduce( (data, byte) =&gt; data + String.fromCharCode(byte), &quot;&quot; ) ); // 创建或更新文件 const fileData = &#123; message: commitMessage, content: base64Content, sha, branch &#125;; const uploadResponse = await fetch( `https://api.github.com/repos/$&#123;owner&#125;/$&#123;repo&#125;/contents/$&#123;fileName.value&#125;`, &#123; method: &quot;PUT&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, Authorization: `Bearer $&#123;accessToken&#125;`, &#125;, body: JSON.stringify(fileData), &#125; ); if (uploadResponse.ok) &#123; alert(&#x27;文件上传成功&#x27;) &#125; else &#123; alert(&#x27;文件上传失败&#x27;) &#125; &#125;; reader.readAsArrayBuffer(file); &#125; // 删除文件 async function handleDeleteFile() &#123; const sha = await getFileSha() const message = &#x27;删除文件&#x27; if (sha) &#123; const deleteResponse = await fetch( `https://api.github.com/repos/$&#123;owner&#125;/$&#123;repo&#125;/contents/$&#123;fileName.value&#125;`, &#123; method: &quot;DELETE&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot;, Authorization: `Bearer $&#123;accessToken&#125;`, &#125;, body: JSON.stringify(&#123; message, sha, branch &#125;) &#125; ); if (!deleteResponse.ok) &#123; throw new Error(`Failed to delete file: $&#123;response.statusText&#125;`); &#125; alert(&#x27;文件删除成功&#x27;) &#125; else &#123; alert(&#x27;要删除的文件不存在&#x27;) &#125; &#125; // 查询所有文件 async function findFileList() &#123; const fileList = await fetch( `https://api.github.com/repos/$&#123;owner&#125;/$&#123;repo&#125;/contents/`, &#123; headers: &#123; Authorization: `Bearer $&#123;accessToken&#125;`, &#125;, &#125; ).then(res=&gt;res.json()); console.log(fileList) &#125; findFileList() // 获取文件的sha值 async function getFileSha() &#123; if (!fileName.value) &#123; return &#125; const existingFileResponse = await fetch( `https://api.github.com/repos/$&#123;owner&#125;/$&#123;repo&#125;/contents/$&#123;fileName.value&#125;`, &#123; headers: &#123; Authorization: `Bearer $&#123;accessToken&#125;`, &#125;, &#125; ); if (existingFileResponse.ok) &#123; const existingFileData = await existingFileResponse.json(); return existingFileData.sha; &#125; else &#123; console.log(&#x27;仓库文件不存在&#x27;) return &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","tags":["其它"],"categories":["前端进阶"]},{"title":"使用Tiled编辑器制作phaser地图","path":"/2024/10/14/92/","content":"安装直接去官网下载Tiled编辑器：Tiled | Flexible level editor (mapeditor.org) 资源准备所有资源仅供学习使用，不可用于其他违法用途，违者与作者无关https://pan.baidu.com/s/12T3GwRrKB9uqLfYRMcSYcw 提取码:xy6s 开始使用Tiled1. 新建一个Map 目前phaser并不支持压缩，所以这里选csv格式的，下面的尺寸可以根据需要自行调节 2. 新建一个瓦片资源集 3. 开始画地图 如果成功导入，那么就是如图所示效果，那么我们刻画第一层，在右侧的瓦片中选中某个区域，然后选中油桶工具，将其刻画在中间面板中 得到效果如下： 接着画第二层，这里作者就简单画棵树（大家自由发挥） 新建一个Tile Layer图层 选择瓦片地图中的任意一棵树，然后选择印章工具： 4. 为需要碰撞的区域加标识这里主要就是方便后续phaser代码中快速增加碰撞 编辑瓦片资源：","tags":["phaser"],"categories":["前端进阶"]},{"title":"网页游戏制作，phaser制作4399小游戏","path":"/2024/10/09/91/","content":"前言相信家人们都玩过4399小游戏吧，那你会不会好奇，如何在浏览器环境中做一款小游戏呢，这里作者就用phaser来教大家如何控制角色上下左右移动 phaser官网：Phaser - A fast, fun and free open source HTML5 game framework感兴趣的可以自己深入研究学习哦，这里作者只做一个基础的角色控制演示 大家坐好，准备发车了！ 预览 phaser环境搭建这里作者就不用npm了，直接引入的cdn &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/phaser/3.85.1/phaser.min.js&quot;&gt;&lt;/script&gt; 这样没有代码提示（有没有大佬知道代码提示插件的，市面上的插件好像都有bug，可能太久没更新了🤔），你也可以使用npm，作者就是图个方便，好了废话不说了，反正环境搭建非常简单，你随便发挥，哈哈哈哈 素材准备这里使用的是一张宝可梦中角色的精灵图（从小就喜欢），大家也可以直接自己随便找一张这种关键帧的精灵图，想要作者的素材的，我也非常贴心的上传了（仅供学习使用）： 链接:&lt;https://pan.baidu.com/s/1WeJ1H_dX_xZDvLqXJrLf4w &gt;提取码:dj8m 游戏场景初始化const config = &#123; type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, parent: &#x27;game&#x27;, backgroundColor: &#x27;#efefef&#x27;, scene: &#123; preload: preload, create: create, update: update &#125;, physics: &#123; default: &#x27;arcade&#x27;, arcade: &#123; gravity: false &#125;, &#125; &#125;; const game = new Phaser.Game(config); config属性说明： type: 指定渲染器类型。Phaser.AUTO 会自动选择最适合的渲染方式（通常是WebGL，如果浏览器不支持则回退到Canvas） parent: 指定一个DOM元素ID，作为游戏画布的父容器 scene: 定义了场景相关的配置，包括预加载资源、创建游戏世界和更新逻辑的方法 preload: 用于加载游戏所需的资源（如图片、音频等）。这是一个函数引用，实际的加载逻辑需要在对应的函数中实现 create: 在这个阶段，你可以初始化游戏对象、设置初始状态等 update: 游戏循环中的每一帧都会调用此方法。通常在这里处理游戏逻辑、物理模拟、玩家输入等 physics: 配置物理引擎相关选项 default: 指定默认使用的物理引擎。这里设置为&#39;arcade&#39;，即Phaser内置的简化版物理引擎 arcade: 进一步配置Arcade物理引擎的行为,gravity设置为false表示禁用全局重力 preload函数这里主要是加载资源文件 function preload() &#123; this.load.spritesheet(&#123; key: &#x27;role&#x27;, url: &#x27;assets/role.png&#x27;, frameConfig: &#123; frameWidth: 64, frameHeight: 64, &#125; &#125;); &#125; 说明: key: 这是一个字符串，作为这个精灵图的唯一标识符。在游戏的其他部分，你可以通过这个键来引用这个精灵图 frameConfig: 这个对象定义了精灵图中每个帧（即每个小图片）的尺寸。这对于正确解析和显示精灵图中的各个部分非常重要 create这里做的就是将资源进行解析，变成一个一个的精灵动画，就是角色上下左右移动的动画 function create() &#123; player = this.physics.add.sprite(window.innerWidth / 2, window.innerHeight / 2, &#x27;role&#x27;); player.setCollideWorldBounds(true); this.anims.create(&#123; key: &#x27;up&#x27;, frames: this.anims.generateFrameNumbers(&#x27;role&#x27;, &#123; start: 0, end: 2 &#125;), frameRate: 10, repeat: -1 &#125;); this.anims.create(&#123; key: &#x27;right&#x27;, frames: this.anims.generateFrameNumbers(&#x27;role&#x27;, &#123; start: 4, end: 6 &#125;), frameRate: 10, repeat: -1 &#125;); this.anims.create(&#123; key: &#x27;down&#x27;, frames: this.anims.generateFrameNumbers(&#x27;role&#x27;, &#123; start: 8, end: 10 &#125;), frameRate: 10, repeat: -1 &#125;); this.anims.create(&#123; key: &#x27;left&#x27;, frames: this.anims.generateFrameNumbers(&#x27;role&#x27;, &#123; start: 12, end: 14 &#125;), frameRate: 10, repeat: -1 &#125;); this.anims.create(&#123; key: &#x27;idle_up&#x27;, frames: [&#123; key: &#x27;role&#x27;, frame: 1 &#125;], frameRate: 20 &#125;); this.anims.create(&#123; key: &#x27;idle_right&#x27;, frames: [&#123; key: &#x27;role&#x27;, frame: 5 &#125;], frameRate: 20 &#125;); this.anims.create(&#123; key: &#x27;idle_down&#x27;, frames: [&#123; key: &#x27;role&#x27;, frame: 9 &#125;], frameRate: 20 &#125;); this.anims.create(&#123; key: &#x27;idle_left&#x27;, frames: [&#123; key: &#x27;role&#x27;, frame: 13 &#125;], frameRate: 20 &#125;); &#125; 说明: this.physics.add.sprite(x, y, textureKey): 创建一个带有物理属性的精灵。x 和 y 是精灵的初始位置，这里设置为窗口宽度和高度的一半，使角色居中显示。textureKey 是在 preload 中加载的精灵图的键名 player.setCollideWorldBounds(true): 设置玩家角色与世界边界碰撞时的行为。true 表示当玩家角色碰到世界边界时会停止移动。 this.anims.create(config): 创建一个新的动画 frames: 定义动画帧。使用 this.anims.generateFrameNumbers 方法来生成一系列帧编号。start 和 end 参数指定了起始帧和结束帧的索引。例如，&#123; start: 0, end: 2 &#125; 表示从第0帧到第2帧 frameRate: 每秒播放的帧数。这里设置为 10，意味着每秒播放10帧 repeat: 动画是否重复播放。-1 表示无限循环 update函数这里就是控制动画如何运行的，比如人物按下哪个键向上移动等操作 // 挂机时人物的朝向 let action_type = &#x27;idle_down&#x27; // 角色的移动速度 const velocity = 160 function update() &#123; const cursors = this.input.keyboard.createCursorKeys(); // 默认情况下，停止所有方向上的运动 player.setVelocityX(0); player.setVelocityY(0); switch (true) &#123; case cursors.up.isDown: player.anims.play(&#x27;up&#x27;, true); player.setVelocityY(-velocity); action_type = &#x27;idle_up&#x27; break; case cursors.right.isDown: player.anims.play(&#x27;right&#x27;, true); player.setVelocityX(velocity); action_type = &#x27;idle_right&#x27; break; case cursors.down.isDown: player.anims.play(&#x27;down&#x27;, true); player.setVelocityY(velocity); action_type = &#x27;idle_down&#x27; break; case cursors.left.isDown: player.anims.play(&#x27;left&#x27;, true); player.setVelocityX(-velocity); action_type = &#x27;idle_left&#x27; break; default: player.anims.play(action_type, true); &#125; &#125; 完整代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/phaser/3.85.1/phaser.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #game &#123; width: 100%; height: 100vh; overflow: hidden; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;game&quot;&gt;&lt;/div&gt; &lt;script&gt; const config = &#123; type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, parent: &#x27;game&#x27;, backgroundColor: &#x27;#efefef&#x27;, scene: &#123; preload: preload, create: create, update: update &#125;, physics: &#123; default: &#x27;arcade&#x27;, arcade: &#123; gravity: false &#125;, &#125; &#125;; const game = new Phaser.Game(config); function preload() &#123; this.load.spritesheet(&#123; key: &#x27;role&#x27;, url: &#x27;assets/role.png&#x27;, frameConfig: &#123; frameWidth: 64, frameHeight: 64, &#125; &#125;); &#125; function create() &#123; player = this.physics.add.sprite(window.innerWidth / 2, window.innerHeight / 2, &#x27;role&#x27;); player.setCollideWorldBounds(true); this.anims.create(&#123; key: &#x27;up&#x27;, frames: this.anims.generateFrameNumbers(&#x27;role&#x27;, &#123; start: 0, end: 2 &#125;), frameRate: 10, repeat: -1 &#125;); this.anims.create(&#123; key: &#x27;right&#x27;, frames: this.anims.generateFrameNumbers(&#x27;role&#x27;, &#123; start: 4, end: 6 &#125;), frameRate: 10, repeat: -1 &#125;); this.anims.create(&#123; key: &#x27;down&#x27;, frames: this.anims.generateFrameNumbers(&#x27;role&#x27;, &#123; start: 8, end: 10 &#125;), frameRate: 10, repeat: -1 &#125;); this.anims.create(&#123; key: &#x27;left&#x27;, frames: this.anims.generateFrameNumbers(&#x27;role&#x27;, &#123; start: 12, end: 14 &#125;), frameRate: 10, repeat: -1 &#125;); this.anims.create(&#123; key: &#x27;idle_up&#x27;, frames: [&#123; key: &#x27;role&#x27;, frame: 1 &#125;], frameRate: 20 &#125;); this.anims.create(&#123; key: &#x27;idle_right&#x27;, frames: [&#123; key: &#x27;role&#x27;, frame: 5 &#125;], frameRate: 20 &#125;); this.anims.create(&#123; key: &#x27;idle_down&#x27;, frames: [&#123; key: &#x27;role&#x27;, frame: 9 &#125;], frameRate: 20 &#125;); this.anims.create(&#123; key: &#x27;idle_left&#x27;, frames: [&#123; key: &#x27;role&#x27;, frame: 13 &#125;], frameRate: 20 &#125;); &#125; let action_type = &#x27;idle_down&#x27; // 角色的移动速度 const velocity = 160 function update() &#123; const cursors = this.input.keyboard.createCursorKeys(); // 默认情况下，停止所有方向上的运动 player.setVelocityX(0); player.setVelocityY(0); switch (true) &#123; case cursors.up.isDown: player.anims.play(&#x27;up&#x27;, true); player.setVelocityY(-velocity); action_type = &#x27;idle_up&#x27; break; case cursors.right.isDown: player.anims.play(&#x27;right&#x27;, true); player.setVelocityX(velocity); action_type = &#x27;idle_right&#x27; break; case cursors.down.isDown: player.anims.play(&#x27;down&#x27;, true); player.setVelocityY(velocity); action_type = &#x27;idle_down&#x27; break; case cursors.left.isDown: player.anims.play(&#x27;left&#x27;, true); player.setVelocityX(-velocity); action_type = &#x27;idle_left&#x27; break; default: player.anims.play(action_type, true); &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","tags":["phaser"],"categories":["前端进阶"]},{"title":"three.js我遇到的问题","path":"/2024/10/03/90/","content":"关于模型加了阴影出现条纹的问题 给灯光加一个属性： pointLight.shadow.bias = -0.005;","tags":["three.js"],"categories":["前端进阶"]},{"title":"利用node+socket.io搭建一个简单的聊天平台","path":"/2024/09/21/89/","content":"前言从此篇文章开始，作者可能以后会多发一些技术性的文章（主要是关于前端的），此刻我才明白自己多渺小😮‍💨，感觉发一些启发性的文章，并不能真正的启发大家，甚至不屑，看来所有的都得靠大家自己了（可能一个人的成长，真的只能靠某件事情去教了🤔），废话不多说，直接进入正题，大家拿好凳子准备发车 注意：请不要连node是什么都不知道，不然这篇文章不适合你哦 原理利用的是websocket协议（感兴趣的自行探索）：在单个TCP连接上进行全双工通信的协议，总之就是服务端与客户端可以互相发送消息，实现通讯功能 项目初始化1. 安装两个包即可(其实一个也行)&#123; &quot;devDependencies&quot;: &#123; &quot;@types/node&quot;: &quot;^22.5.5&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;socket.io&quot;: &quot;^4.7.5&quot; &#125; &#125; @types&#x2F;node: 主要是提供node代码提示 socket.io：今天的主角，通信全靠它了 2. 服务端代码分为两个文件： server.js: 服务端入口文件 const http = require(&#x27;http&#x27;) const socket = require(&#x27;./socket&#x27;) const port = 3000 // 端口号 const server = http.createServer((req, res)=&gt;&#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf-8&#x27;); res.end(&#x27;欢迎来到聊天室&#x27;) &#125;) socket(server) server.listen(port, ()=&gt;&#123; console.log(&#x27;通讯服务启动成功&#x27;, `http://localhost:$&#123;port&#125;/`) &#125;) socket.js: 实现聊天服务的一个函数 const &#123; Server &#125; = require(&#x27;socket.io&#x27;); function socket(server) &#123; const io = new Server(server, &#123; cors: true // 允许跨域 &#125;); io.on(&#x27;connection&#x27;, (socket) =&gt; &#123; console.log(&#x27;a user connected&#x27;); &#125;); &#125; module.exports = socket 3.客户端代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;聊天室&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; const socket = io(&quot;ws://localhost:3000&quot;); // 监听事件 socket.on(&quot;connect&quot;, () =&gt; &#123; console.log(&quot;连接成功&quot;); &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 简单的接收和发送消息1.客户端(socket.emit)&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;聊天室&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;button onclick=&quot;send()&quot;&gt;发送&lt;/button&gt; &lt;script&gt; const socket = io(&quot;ws://localhost:3000&quot;); const input = document.querySelector(&#x27;input&#x27;) function send() &#123; socket.emit(&#x27;chat&#x27;, input.value) input.value = &#x27;&#x27; &#125; // 监听事件 socket.on(&quot;connect&quot;, () =&gt; &#123; console.log(&quot;连接成功&quot;); &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.服务端(socket.on)const &#123; Server &#125; = require(&#x27;socket.io&#x27;); function socket(server) &#123; const io = new Server(server, &#123; cors: true // 允许跨域 &#125;); io.on(&#x27;connection&#x27;, (socket) =&gt; &#123; console.log(&#x27;a user connected&#x27;); socket.on(&#x27;chat&#x27;, (msg)=&gt;&#123; console.log(msg) &#125;) &#125;); &#125; module.exports = socket 实现基本聊天功能这里为了简便，就省去了用户登录的功能，而是利用了crypto这个模块生成用户id，用以区分消息来自哪里，只要大家能理解里面的思路，加一个登录验证，对你们来说就像呼吸一样简单，嘿嘿😍 1.服务端（广播全体在线用户, io.emit）const &#123; Server &#125; = require(&#x27;socket.io&#x27;); const crypto = require(&#x27;crypto&#x27;); function socket(server) &#123; const io = new Server(server, &#123; cors: true // 允许跨域 &#125;); io.on(&#x27;connection&#x27;, (socket) =&gt; &#123; const userId = crypto.randomBytes(16).toString(&#x27;hex&#x27;) // 随机生成用户id socket.user = userId socket.on(&#x27;chat&#x27;, (msg)=&gt;&#123; io.emit(&#x27;chat&#x27;, msg + &#x27;-用户:&#x27; + socket.user) &#125;) console.log(&#x27;a user connected&#x27;); &#125;); &#125; module.exports = socket 2.客户端（监听服务器广播的消息，socket.on）&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;聊天室&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;button onclick=&quot;send()&quot;&gt;发送&lt;/button&gt; &lt;ul id=&quot;messageList&quot;&gt;&lt;/ul&gt; &lt;script&gt; const socket = io(&quot;ws://localhost:3000&quot;); const input = document.querySelector(&#x27;input&#x27;) const messageList = document.querySelector(&#x27;#messageList&#x27;) function send() &#123; socket.emit(&#x27;chat&#x27;, input.value) input.value = &#x27;&#x27; &#125; // 监听事件 socket.on(&quot;connect&quot;, () =&gt; &#123; console.log(&quot;连接成功&quot;); &#125;); // 接收消息,并展示在页面中 socket.on(&#x27;chat&#x27;, (msg)=&gt;&#123; const msgItem = document.createElement(&#x27;li&#x27;) msgItem.innerText = msg messageList.appendChild(msgItem) &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 结果如下： 总结到这里，你如果全懂了，恭喜你🎉🎉，你已经步入帝君境界，一人便可抵挡千军万马，黄沙百战穿金甲，不破楼兰终不还，嘿嘿，加油修炼吧！！ 等等，别高兴太早了 一款即时通讯应用要想真正的做起来，上面的这些只能说皮毛都不算 为什么（还有哪些要实现的）： 1. 登录验证 2. 数据的存储 3. 用户的互动性（加好友，删除好友，单聊，群聊，拉群功能） 4. 如何保证消息的可靠性、完整性，顺序性 5. 离线消息的存储，并在用户上线的时候进行发送 6. 支持桌面推送、声音提醒 7. 性能优化（服务器负载均衡，使用 Redis 等缓存常用数据） 等等.... 我都感觉我写不完了，反正实现一款成熟的聊天应用，不是我一篇文章就能讲清楚的（也不是两篇哈😂），感觉前方还有千军万马等着呢！！","tags":["node"],"categories":["前端进阶"]},{"title":"写给新生的一封信","path":"/2024/09/17/88/","content":"哈喽啊，24级的新生们，当你看到这封信，我可能已经😭。。。。哈哈哈哈，不开玩笑了，本人是一名大四的学生，现在已经是上班族了，哈哈哈，经过三年的大学生涯，我想跟大家分享一些自己的感想，嘿嘿，大家拿好板凳准备吃瓜！！🍉 前言请注意这篇文章可能会更适合学计算机类的同学们（本人网络工程），可能会给大家制造一些“焦虑”，但是对你肯定有帮助（其实我也不确定，嘻嘻😄），如下所有都是作者自身的观点，同学们，请理性思考哦😁 为什么写这封信因为我见过太多的同学了，大三还在迷茫，不知道以后想干嘛，或者有些同学大三才给自己定方向，但是其实到了大三了，很多东西都来不及了，甚至有些同学随波逐流，就是不能明确自己的方向，就比如很多同学内心深处不是很想考研，但是又不知道要干嘛（都是作者猜测哦，嘿嘿），反正，总而言之，作者写这封信的目的就是：明确自己的方向 和 更新你对大学的认知 如果你是富二代当作者的话是放屁就行了（富二代请联系作者：17347187569），嘿嘿😍怎样明确自己的方向其实我觉得这一步真的不难，无论你是什么专业的，都适用。 很多的“大师”可能会说，自己感兴趣什么就去什么，但是这个不完全正确，首先你要明确一点，社会不是过家家，首先你必须在这个社会能够生存下去，你才能去谈自己所谓的“理想”和“兴趣” 第一步，找到自己能够在社会生存下去的技术这里作者不会推荐任何一门技术,因为作者只是一个普通人😮‍💨，不可能和你说什么学这个，啊，什么以后一定能找到工作，而且工资还高，我没有这个能力，因为每个行业的未来发展是不确定的，所以也给我们带来了机遇，喵！🐱 1. 学技术一定是和社会挂钩的，所以最简单的就是，去各大招聘软件（某boss，某客）平台，去找找自己感兴趣的工作，然后看看他们要求需要掌握的技能，然后你就可以去学习啦😍，例如： 网络安全: 运营岗位每个职位都会有详细的介绍和要求 2. 除了这种软件上，还有各种大厂的校招官网上也会有职位的发布，如果只想进某家公司，那么一定要去这家官网看看，招什么人，自己就可以提前准备，例如： 某鹅厂： 3. 然后就是可以多多了解自己有没有亲戚做什么赚钱的（一定要合法哦，同学😉），多跟他沟通沟通，说不定你是成功最快的 第二步，思考自己找到的方向是否是自己喜欢的（可有可无）🤭如果你找到了自己喜欢的职位了，一定要有一个清楚的认知，就是思考自己能否坚持下去，这是一个很模糊的概念，告诉大家一个小妙招，就知道你是否真正喜欢了，就是你是否有某个时刻，有抑制不了自己学习这个方向技术的渴望，简单来说，就是不是被动学习，而是自己对这个方向的东西“上瘾”，嘿嘿！！ 第三步哈哈哈哈，没有第三步 怎样学习呢前面的一系列操作完成后，我就假设你非常喜欢自己喜欢的方向，并且能够坚持😙 作者在下面的推荐只是作者平时可能常用的，大家要学会自己打破信息差（这里作者就不说了，就是去看国外的一些教学平台，需要魔法，总之你前期用不到，到了后期我也不用讲） /*** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\\ = /O * ____/`---&#x27;____ * . &#x27; \\| |// `. * / \\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\ - /// | | * | _| &#x27;&#x27;---/&#x27;&#x27; | | * \\ .-__ `-` ___/-. / * ___`. .&#x27; /--.--\\ `. . __ * .&quot;&quot; &#x27;&lt; `.____&lt;|&gt;_/___.&#x27; &gt;&#x27;&quot;&quot;. * | | : `- `.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. _ __\\ /__ _/ .-` / / * ======`-.____`-.________/___.-`____.-&#x27;====== * `=---=&#x27; * * ............................................. * 佛祖保佑 永无BUG */ 1. 看教学视频：b站（这是作者梦的开始，喵！！） 必须注意：这里大多数的教学视频，非常适合入门选手，因为大多数都是讲入门的知识，不管什么技术，到这里来入门就行，很多高超的技术需要自己去探索，你可能会在探索中才会发现自己真的原来是小白（作者对自己说的，嘻嘻🤭） 其它教学网站（作者平时不是很常用，教学质量待评估）：学堂在线、慕课网等等 2. 看优质文章推荐：csdn，掘金，适合任何人群，里面有很多技术大佬发布的文章（也有搬运的，大家支持原创哦！！😁） 3. 寻找优质项目学习这里更适合已经入门的，水平中等的同学（不重要），推荐： github（全球优质项目都在这里，还有各种优质的学习资料） gitee（国内的，类似GitHub） 其实你只要深入学习，这两个东西，会成为你接触最多的两个“家人”🤩 大家一定要好好学习哦！！！！！！！！！！ 关于社团与学生会（不喜欢社交直接跳过）如果你平时交际为零，我建议你可以试着参加，因为人际关系可能给你带来意想不到的收获。 其实我在上大学之前就不喜欢这种东西，因为我觉得浪费时间，但是我后面才偶然发现社交也是很重要的（哎哎，都是人情事故），所以这里提了一嘴。 注意： 社交的第一原则就是志同道合（不是狐朋狗友哈，看你自己🫣），多和优秀的人接触，尽量远离那种“下流”之人，习惯都是会被影响的 交朋友的时候一定一定要谨慎（这里我也只能提醒你了，人真的是个复杂的动物，我没法教你分辨“坏人”） 其实社团和什么学生会，记住一点！！！，一定不要看的太重。还有就是，你只要记住，这种东西只是用来让自己变得健谈，而不是说什么进了社团和学生会怎么怎么样（在这里不是说社团和学生会不好，求放过🤫）。 总而言之：加入社团或者学生会会扩大你的人脉（至少是大学的人脉，出了社会就不一定了），我觉得可能最大的帮助就是可以让我们变得“圆滑”（褒义词哦😛），千万不要小看那些会社交的人哦！！ 关于兼职如果你能看到这里恭喜，你的耐心超过了90%的人了，谢谢你，我的朋友😁 可能很多同学都有着大学实现财富自由之类的一系列梦想，嘿嘿，打住！！！ 首先明确自己的观点：如果家里不是特别困难，建议不要兼职 原因： 1.你是学生，是来学习的 2.兼职大部分都是重复简单的劳动，会浪费很多宝贵的时间（说的是学习哈，有的人估计想到打游戏了🫣） 3没必要提前吃苦（以后有的是） 最后祝所有学弟、学妹们，前程似锦，万事胜意！ 有任何问题联系学长（可能有时候上班接不到，可以加V，但是必须是正能量的话题）：17347187569","tags":["生活闲聊"]},{"title":"面经","path":"/2024/09/04/87/","content":"同一个网站不同的标签页如何通信 使用 localStorage 或 sessionStorage 使用 IndexedDB 使用 Broadcast Channel API 手写filter手写多维数组拆分","tags":["面经"],"categories":["前端面试题"]},{"title":"压缩3D模型","path":"/2024/08/31/86/","content":"第一种方法npm install -g gltf-pipeline gltf-pipeline -i 输入.glb -o 输出.glb -d -s 参数 说明 -i 输入路径 -o 输出路径 -b 将输入的gltf转为glb -j 将输入的glb转为gltf -s 编写单独的缓冲区、着色器和纹理 -t 只写出单独的纹理 -d 使用Draco压缩网格 –keepUnusedElements 保留未使用的材质、节点和网格 –draco.compressionLevel Draco 压缩级别 [0-10]，大多数为 10，最小为 0 更多参数配置请参考：https://www.npmjs.com/package/gltf-pipeline 使用Draco压缩网格在three中的使用 import * as THREE from &#x27;three&#x27;; import &#123; onMounted &#125; from &quot;vue&quot; import &#123; OrbitControls &#125; from &#x27;three/addons/controls/OrbitControls.js&#x27;; import &#123; GLTFLoader &#125; from &#x27;three/addons/loaders/GLTFLoader.js&#x27;; import &#123; DRACOLoader &#125; from &quot;three/examples/jsm/loaders/DRACOLoader&quot;; onMounted(() =&gt; &#123; const width = document.documentElement.clientWidth const height = document.documentElement.clientHeight // 创建3d场景 const scene = new THREE.Scene() // 添加点光源 const pointLight = new THREE.PointLight(&quot;#ffffff&quot;, 200, 200) pointLight.position.set(10, 10, 10) scene.add(pointLight) // 创建相机 const camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000) camera.position.z = 20 camera.position.y = 10 camera.position.x = 10 // 创建一个GTLF加载器 const loader = new GLTFLoader() const dracoLoader = new DRACOLoader() dracoLoader.setDecoderPath(&quot;/draco/&quot;) loader.setDRACOLoader(dracoLoader) // 加载 loader.load(&quot;/drco.glb&quot;, (gltf) =&gt; &#123; scene.add(gltf.scene) &#125;) // 创建渲染器 const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;) // 调整渲染器大小 renderer.setSize(width, height) // 添加动画 renderer.setAnimationLoop(animate) document.querySelector(&#x27;#canvas&#x27;).appendChild(renderer.domElement) const controls = new OrbitControls(camera, renderer.domElement); // 动画函数 function animate(time) &#123; controls.update() renderer.render(scene, camera); &#125; &#125;) 其中dracoLoader.setDecoderPath(&quot;/draco/&quot;)这个需要引入draco的js文件路径，本来three中有，但是我不知道为什么成功不了，于是就把它单独提出了： https://gitee.com/xiao-zhe-is-not-lazy/assets","tags":["优化"],"categories":["前端进阶"]},{"title":"echarts绘制中国地图","path":"/2024/08/29/85/","content":"安装依赖 下载 echarts npm i echarts 下载 china.js https://gitee.com/xiao-zhe-is-not-lazy/assets 基础使用import &#123; defineComponent, onMounted, reactive &#125; from &quot;vue&quot;; import &#123; option &#125; from &quot;./config&quot;; import * as echarts from &quot;echarts&quot;; import &quot;@/assets/js/china&quot;; import &#123; cityData &#125; from &quot;./data&quot;; export default defineComponent(&#123; setup() &#123; let myEcharts; const state = reactive(&#123; option: null, &#125;); const methods = &#123; init() &#123; methods.initEcharts(); state.option.series[0].data = cityData; // 重新设置option myEcharts.setOption(state.option); &#125;, // 初始化echarts initEcharts() &#123; // 初始化echarts实例 myEcharts = echarts.init(document.getElementById(&quot;map-echarts&quot;)); state.option = option; // 使用刚指定的配置项和数据显示图表。 myEcharts.setOption(state.option); &#125;, &#125;; onMounted(() =&gt; &#123; methods.init(); &#125;); &#125;, &#125;); config: export const option = &#123; geo: &#123; map: &quot;china&quot;, // 地图类型 zoom: 1, // 缩放级别 roam: true, // 是否开启鼠标缩放和平移漫游 top: &quot;15%&quot;, left: &quot;10%&quot;, // 地图标签的配置 label: &#123; normal: &#123; show: true, &#125;, emphasis: &#123; show: true, &#125;, &#125;, &#125;, // 悬浮窗 tooltip: &#123; trigger: &quot;item&quot;, formatter: function (params) &#123; return params.name; &#125;, &#125;, legend: &#123; orient: &quot;horizontal&quot;, // 图例的方向 left: &quot;right&quot;, // 图例的位置 data: [&quot;路飞&quot;], // 图例显示的数据，即图例项的名称列表 &#125;, // 左下角图例 visualMap: [ &#123; seriesIndex: 0, min: 0, max: 100, left: &quot;left&quot;, top: &quot;bottom&quot;, text: [&quot;高&quot;, &quot;低&quot;], // 文本，默认为数值文本 calculable: true, inRange: &#123; color: [&quot;#f4d7d2&quot;, &quot;#f1674e&quot;], &#125;, &#125;, ], series: [ &#123; geoIndex: 0, coordinateSystem: &quot;geo&quot;, type: &quot;map&quot;, name: &quot;路飞&quot;, roam: true, itemStyle: &#123; normal: &#123; color: &quot;#f1674e&quot;, &#125;, &#125;, label: &#123; normal: &#123; show: true, &#125;, emphasis: &#123; show: true, &#125;, &#125;, tooltip: &#123; formatter: function (params) &#123; return `$&#123;params.name&#125; $&#123;params.value&#125;%`; &#125;, &#125;, data: [], &#125;, ], &#125;; 假数据 data export const cityData = [ &#123; name: &quot;澳门&quot;, code: &quot;820000&quot;, value: 0 &#125;, &#123; name: &quot;香港&quot;, code: &quot;810000&quot;, value: 0 &#125;, &#123; name: &quot;台湾&quot;, code: &quot;710000&quot;, value: 0 &#125;, &#123; name: &quot;海南&quot;, code: &quot;460000&quot;, value: 0 &#125;, &#123; name: &quot;宁夏&quot;, code: &quot;640000&quot;, value: 0 &#125;, &#123; name: &quot;四川&quot;, code: &quot;510000&quot;, value: 0 &#125;, &#123; name: &quot;西藏&quot;, code: &quot;540000&quot;, value: 0 &#125;, &#123; name: &quot;青海&quot;, code: &quot;630000&quot;, value: 0 &#125;, &#123; name: &quot;广东&quot;, code: &quot;440000&quot;, value: 0 &#125;, &#123; name: &quot;贵州&quot;, code: &quot;520000&quot;, value: 0 &#125;, &#123; name: &quot;福建&quot;, code: &quot;350000&quot;, value: 0 &#125;, &#123; name: &quot;吉林&quot;, code: &quot;220000&quot;, value: 0 &#125;, &#123; name: &quot;陕西&quot;, code: &quot;610000&quot;, value: 0 &#125;, &#123; name: &quot;内蒙古&quot;, code: &quot;150000&quot;, value: 0 &#125;, &#123; name: &quot;山西&quot;, code: &quot;140000&quot;, value: 0 &#125;, &#123; name: &quot;甘肃&quot;, code: &quot;620000&quot;, value: 0 &#125;, &#123; name: &quot;广西&quot;, code: &quot;450000&quot;, value: 0 &#125;, &#123; name: &quot;湖北&quot;, code: &quot;420000&quot;, value: 0 &#125;, &#123; name: &quot;江西&quot;, code: &quot;360000&quot;, value: 0 &#125;, &#123; name: &quot;浙江&quot;, code: &quot;330000&quot;, value: 0 &#125;, &#123; name: &quot;江苏&quot;, code: &quot;320000&quot;, value: 0 &#125;, &#123; name: &quot;新疆&quot;, code: &quot;650000&quot;, value: 0 &#125;, &#123; name: &quot;山东&quot;, code: &quot;370000&quot;, value: 0 &#125;, &#123; name: &quot;安徽&quot;, code: &quot;340000&quot;, value: 0 &#125;, &#123; name: &quot;湖南&quot;, code: &quot;430000&quot;, value: 0 &#125;, &#123; name: &quot;黑龙江&quot;, code: &quot;230000&quot;, value: 0 &#125;, &#123; name: &quot;辽宁&quot;, code: &quot;210000&quot;, value: 0 &#125;, &#123; name: &quot;云南&quot;, code: &quot;530000&quot;, value: 0 &#125;, &#123; name: &quot;河南&quot;, code: &quot;410000&quot;, value: 0 &#125;, &#123; name: &quot;河北&quot;, code: &quot;130000&quot;, value: 0 &#125;, &#123; name: &quot;重庆&quot;, code: &quot;500000&quot;, value: 0 &#125;, &#123; name: &quot;上海&quot;, code: &quot;310000&quot;, value: 0 &#125;, &#123; name: &quot;天津&quot;, code: &quot;120000&quot;, value: 0 &#125;, &#123; name: &quot;北京&quot;, code: &quot;110000&quot;, value: 0 &#125;, ]; 更多的 option 的配置请参考：https://echarts.apache.org/zh/option.html#title","tags":["echarts"],"categories":["前端进阶"]},{"title":"css巧妙技巧","path":"/2024/08/11/84/","content":"滚动动画效果： css主要属性 @keyframes animationScroll &#123; 0%&#123; opacity: 0; transform: scale(0.5); &#125; 100%&#123; opacity: 1; transform: scale(1); &#125; &#125; animation: animationScroll; animation-timeline: view(); /* 控制CSS动画进度的时间线 */ animation-range: entry 0 cover 50%; /* 控制css盒子当进入视口的50%时完成动画 */","tags":["css"],"categories":["前端基础"]},{"title":"blender插件分享","path":"/2024/07/28/83/","content":"1. 布尔工具 2. 物体对齐工具 使用： 3. FLIP Fluids这是一个流体模拟的工具 简单使用： 首先制作一个域，其实就是流体的运动范围 在设置一个流入 最后进行烘培 然后空格进行动画播放:","tags":["blender"],"categories":["3D建模"]},{"title":"blender基础知识","path":"/2024/07/11/82/","content":"易忘快捷键1. 内插面：i 2. 挤出：EAlt + E 可以选择如何挤出 3. 倒角：ctrl + B注意：ctrl + Z 可以在倒角和斜面之间进行切换 4. 环切（循环分段）：ctrl + R 5. 桥接：ctrl + E 6. 其他常用操作 操作描述 快捷键 切换成编辑模式 Tab 连接两点 J 分离模型 P 合并模型（不能在编辑模式下进行合并） ctrl + J 独立显示某个模型 &#x2F; 选择相邻 L 反选 ctrl + i 对面进行翻转操作 Alt + N 改变旋转点 ctrl + . 小妙招1. 斜面重置如果你在对物体进行缩放或者移动时，不小心将某个面变成了斜面，比如下面： 你可以使用缩放工具的时候按0，就可以重新调正这个斜面了 注意事项1. 关于缩放后对物体的影响在我们将物体进行缩放后，在使用倒角的时候，会发现倒角很奇怪： 这是因为切角会保留缩放后的数据: 此时我们可以对缩放数据进行清空，快捷键：ctrl + A 2. 关于面朝向问题众所周知，一个面具有正面和反面，那么在blender中如何查看呢？ 可以按Alt + N对面进行翻转 正面：蓝色 反面：红色 此时做倒角就会变成这样： 所以在建模过程中要注意面朝向的问题","tags":["blender"],"categories":["3D建模"]},{"title":"three.js加载模型基础代码","path":"/2024/07/01/81/","content":"代码展示import * as THREE from &#x27;three&#x27;; import &#123; onMounted &#125; from &quot;vue&quot; import &#123; OrbitControls &#125; from &#x27;three/addons/controls/OrbitControls.js&#x27;; import &#123; GLTFLoader &#125; from &#x27;three/addons/loaders/GLTFLoader.js&#x27;; onMounted(() =&gt; &#123; const width = document.documentElement.clientWidth const height = document.documentElement.clientHeight // 创建3d场景 const scene = new THREE.Scene() // 添加点光源 const pointLight = new THREE.PointLight(&quot;#ffffff&quot;, 200, 200) pointLight.position.set(10, 10, 10) scene.add(pointLight) // 创建相机 const camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000) camera.position.z = 20 camera.position.y = 10 camera.position.x = 10 // 创建一个GTLF加载器 const loader = new GLTFLoader() // 加载 loader.load(&quot;/test2.glb&quot;, (gltf) =&gt; &#123; scene.add(gltf.scene) &#125;) // 创建渲染器 const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;) // 调整渲染器大小 renderer.setSize(width, height) // 添加动画 renderer.setAnimationLoop(animate) document.querySelector(&#x27;#canvas&#x27;).appendChild(renderer.domElement) const controls = new OrbitControls(camera, renderer.domElement); // 动画函数 function animate(time) &#123; controls.update() renderer.render(scene, camera); &#125; &#125;)","tags":["three.js"],"categories":["前端进阶"]},{"title":"three.js结合cannon-es实现3d物理世界","path":"/2024/06/28/80/","content":"说明这里主要实现物理世界中的自由落体和物体间的碰撞 学习本篇文章前，请事先了解或者学习一下three的内容，方便理解，这里不会教大家创建一个基础的three3d场景，直接就是进行物理世界的搭建 下载依赖包npm i cannon-es 引入依赖包import * as CANNON from &quot;cannon-es&quot;; 搭建物理世界1.实例化一个物理世界,并且设置重力加速度// CANNON.World创建物理世界对象 const world = new CANNON.World(); // 设置物理世界的重力加速度 world.gravity.set(0, -9.8, 0) 2.创建碰撞体的形状和位置说明：这里为什么说的是形状，因为cannon本身并不会真正去渲染出一个物体，而是利用three创建物体，并进行渲染，但是此时创建的物体是没有任何物理效果的，所以就必须将物理世界中的碰撞体与three中的物体关联起来，变成一个整体，从而实现物理效果，就是在three的物体表面附着一层碰撞形状，从而实现碰撞的检测 比如创建一个球的形状 const bodyShape = new CANNON.Sphere(0.3); // 设置碰撞体规则 const body = new CANNON.Body(&#123; mass: 1, // 质量，如果为0表示静止不动 position: new CANNON.Vec3(0, 2, 0), //位置 shape: bodyShape,//碰撞体的几何体形状 &#125;); 3.将物体添加到物理世界中world.addBody(body); 4.在动画函数中更新物理世界// 更新物理世界 world.step(1 / 60) // 渲染循环中，同步物理世界与网格世界 mesh.position.copy(body.position); 完整代码这里作者增加了一个地面，并且设置了地面与球体间的摩擦系数和弹性系数，这里以vue3框架 &lt;template&gt; &lt;div id=&quot;canvas&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang=&quot;js&quot;&gt; import * as THREE from &#x27;three&#x27;; import &#123; OrbitControls &#125; from &#x27;three/addons/controls/OrbitControls.js&#x27;; import * as CANNON from &quot;cannon-es&quot;; import &#123; onMounted &#125; from &quot;vue&quot; onMounted(() =&gt; &#123; const width = document.documentElement.clientWidth const height = document.documentElement.clientHeight // 创建3d场景 const scene = new THREE.Scene() // 环境光 const light = new THREE.AmbientLight(&quot;#ffffff&quot;, 0.2) scene.add(light) // 添加一个点光源 const pointLight = new THREE.PointLight(&quot;#ffffff&quot;, 100, 100) pointLight.position.set(5, 5, 5) scene.add(pointLight) // CANNON.World创建物理世界对象 const world = new CANNON.World(); // 设置物理世界的重力加速度 world.gravity.set(0, -9.8, 0) // 创建碰撞体的形状 // 球 const bodyShape = new CANNON.Sphere(0.3); // 地面 const bodyFloor = new CANNON.Plane() // 设置碰撞体规则 const body = new CANNON.Body(&#123; mass: 1, position: new CANNON.Vec3(0, 2, 0), shape: bodyShape,//碰撞体的几何体形状 &#125;); const body2 = new CANNON.Body(&#123; mass: 0, position: new CANNON.Vec3(0, 0, 0), shape: bodyFloor,//碰撞体的几何体形状 &#125;); // 设置刚体的旋转 body2.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2) // 创建球体和地面的材质，并设置弹性系数 const ballMaterial = new CANNON.Material(&quot;ballMaterial&quot;); const floorMaterial = new CANNON.Material(&quot;floorMaterial&quot;); // 为球体和地面的碰撞体设置材质 body.material = ballMaterial; // 球体的碰撞体 body2.material = floorMaterial; // 地面的碰撞体 const contactMaterial = new CANNON.ContactMaterial( ballMaterial, floorMaterial, &#123; friction: 0.3, // 摩擦系数 restitution: 0.5, // 弹性系数，这里再次强调以保持一致性 &#125; ); // 添加接触材料对到物理世界 world.addContactMaterial(contactMaterial); // 在物理世界添加物体 world.addBody(body); world.addBody(body2); // 创建相机 const camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000) camera.position.z = 7 camera.position.y = 3 camera.position.x = 3 // 创建球 const boxGeometry = new THREE.SphereGeometry(0.3) const material = new THREE.MeshPhongMaterial(&#123; color: &quot;#e67e22&quot; &#125;) const mesh = new THREE.Mesh(boxGeometry, material) mesh.position.set(0, 2, 0) scene.add(mesh) // 创建地面 const planeGeometry = new THREE.PlaneGeometry(10, 10) const materialfloor = new THREE.MeshPhongMaterial(&#123; color: &quot;#95a5a6&quot;, side: THREE.DoubleSide &#125;) const meshfloor = new THREE.Mesh(planeGeometry, materialfloor) meshfloor.position.set(0, 0, 0) meshfloor.rotation.x = -Math.PI / 2 scene.add(meshfloor) // 创建渲染器 const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;) // 调整渲染器大小 renderer.setSize(width, height) // 添加动画 renderer.setAnimationLoop(animate) document.querySelector(&quot;#canvas&quot;).appendChild(renderer.domElement) // 添加轨道控制器 const controls = new OrbitControls(camera, renderer.domElement); // 动画函数 function animate(time) &#123; // 更新物理世界 world.step(1 / 60) // 渲染循环中，同步物理世界与网格世界 mesh.position.copy(body.position); meshfloor.position.copy(body2.position); controls.update() renderer.render(scene, camera); &#125; &#125;) &lt;/script&gt; &lt;style scoped&gt;&lt;/style&gt;","tags":["three.js","cannon-es"],"categories":["前端进阶"]},{"title":"文件上传多种场景(前端+后端)","path":"/2024/06/20/79/","content":"input进行文件上传时有关的属性 属性 说明 accept 指定上传文件的类型，例如：accept&#x3D;”image&#x2F;*”，只能上传图片文件 multiple 允许上传多个文件 webkitdirectory 是否上传文件夹 单文件上传后端： var express = require(&#x27;express&#x27;); var router = express.Router(); const multer = require(&#x27;multer&#x27;) const upload = multer(&#123; dest: &#x27;uploads/&#x27; &#125;) /* GET home page. */ router.post(&#x27;/upload&#x27;,upload.single(&quot;image&quot;),function(req, res, next) &#123; res.send(&#123;ok:1&#125;) &#125;); module.exports = router; form &lt;form method=&quot;post&quot; action=&quot;http://localhost:3000/upload&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot;/&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;br /&gt; &lt;/form&gt; 说明：form表单enctype属性的值必需为multipart&#x2F;form-data，name&#x3D;”image”与upload.single(“image”)相对应 fetch &lt;input type=&quot;file&quot; id=&quot;uploadFile&quot;&gt; &lt;button onclick=&quot;upload()&quot;&gt;upload&lt;/button&gt; &lt;script&gt; const uploadFile = document.querySelector(&quot;#uploadFile&quot;) function upload()&#123; const file = uploadFile.files[0] const formData = new FormData() formData.set(&quot;image&quot;, file) fetch(&quot;http://localhost:3000/upload&quot;,&#123; method: &quot;POST&quot;, body: formData &#125;).then(res=&gt;res.json()).then(res=&gt;&#123; console.log(res) &#125;) &#125; &lt;/script&gt; 说明：这里body的值需要利用FormData，其中formData.set(“image”, file)的image对应于upload.single(“image”) 多文件上传后端： var express = require(&#x27;express&#x27;); var router = express.Router(); const multer = require(&#x27;multer&#x27;) const upload = multer(&#123; dest: &#x27;uploads/&#x27; &#125;) /* GET home page. */ router.post(&#x27;/upload&#x27;,upload.array(&quot;image&quot;,5),function(req, res, next) &#123; res.send(&#123;ok:1&#125;) &#125;); module.exports = router; 说明：upload.array(“image”,5)第二个参数指定了最多上传的图片数量 form &lt;form method=&quot;post&quot; action=&quot;http://localhost:3000/upload&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input id=&quot;uploadFile&quot; type=&quot;file&quot; name=&quot;image&quot; onchange=&quot;upload()&quot; multiple/&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;br /&gt; &lt;/form&gt; &lt;script&gt; const uploadFile = document.querySelector(&quot;#uploadFile&quot;) function upload()&#123; if(uploadFile.files.length&gt;5)&#123; // 清空文件选择的输入框 uploadFile.value = &#x27;&#x27; alert(&quot;最多上传5张图片&quot;) &#125; &#125; &lt;/script&gt; fetch &lt;input type=&quot;file&quot; id=&quot;uploadFile&quot; multiple&gt; &lt;button onclick=&quot;upload()&quot;&gt;upload&lt;/button&gt; &lt;script&gt; const uploadFile = document.querySelector(&quot;#uploadFile&quot;) function upload() &#123; const formData = new FormData() if (uploadFile.files.length &gt; 5) &#123; alert(&quot;最多上传5张图片&quot;) &#125; else &#123; for (let item of uploadFile.files) &#123; // 将文件数据存入表单 formData.append(&quot;image&quot;, item) &#125; // 上传表单 fetch(&quot;http://localhost:3000/upload&quot;, &#123; method: &quot;POST&quot;, body: formData &#125;).then(res =&gt; res.json()).then(res =&gt; &#123; console.log(res) &#125;) &#125; &#125; &lt;/script&gt; 上传文件夹给input标签加个webkitdirectory即可 &lt;input type=&quot;file&quot; id=&quot;uploadFile&quot; webkitdirectory&gt; &lt;button onclick=&quot;upload()&quot;&gt;upload&lt;/button&gt; &lt;script&gt; const uploadFile = document.querySelector(&quot;#uploadFile&quot;) function upload() &#123; const formData = new FormData() if (uploadFile.files.length &gt; 5) &#123; alert(&quot;最多上传5张图片&quot;) &#125; else &#123; for (let item of uploadFile.files) &#123; // 将文件数据存入表单 formData.append(&quot;image&quot;, item) &#125; // 上传表单 fetch(&quot;http://localhost:3000/upload&quot;, &#123; method: &quot;POST&quot;, body: formData &#125;).then(res =&gt; res.json()).then(res =&gt; &#123; console.log(res) &#125;) &#125; &#125; &lt;/script&gt; 拖拽上传const dragArea = document.getElementsByClassName(&#x27;dragArea&#x27;)[0] // 当拖拽文件进入时触发 dragArea.ondragenter = (e) =&gt; &#123; // 阻止默认行为 e.preventDefault() &#125; // 当拖拽文件停留在此区域不松手会不断触发 dragArea.ondragover = (e) =&gt; &#123; e.preventDefault() &#125; // 当拖拽文件松手时触发 dragArea.ondrop = async (e) =&gt; &#123; // 创建form表单进行数据存储 const formData = new FormData(); // 处理文件 const files = e.dataTransfer.files; for (let file of files) &#123; if(file.type)&#123; formData.append(&quot;file&quot;, file); &#125; &#125; // 处理文件夹 const items = e.dataTransfer.items; for (let item of items) &#123; const entry = item.webkitGetAsEntry(); if (entry.isDirectory) &#123; // 等待 await directoryDec(entry, formData); &#125; &#125; // 一次性上传所有数据 fetch(&quot;http://localhost:3000/upload&quot;, &#123; method: &quot;POST&quot;, body: formData &#125;).then(res =&gt; res.json()).then(res =&gt; &#123; console.log(res) &#125;) e.preventDefault() &#125; // 处理文件夹函数 function directoryDec(entry, formData) &#123; return new Promise((resolve, reject) =&gt; &#123; const reader = entry.createReader(); reader.readEntries(async (entries) =&gt; &#123; // 使用 Promise.all 确保所有递归调用完成 await Promise.all(entries.map(async (itemEntry) =&gt; &#123; if (itemEntry.isDirectory) &#123; // 等待处理子目录完成 await directoryDec(itemEntry, formData); &#125; else &#123; await new Promise(resolve1 =&gt; &#123; itemEntry.file(file =&gt; &#123; formData.append(&quot;file&quot;, file); resolve1(); &#125;); &#125;) &#125; &#125;)); resolve(); &#125;) &#125;); &#125; 大文件分片上传 前端分片，后端进行文件重组 后端校验文件完整性 前端可根据自己的cpu利用worker开启多个进程，提高效率 前端 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/spark-md5/3.0.2/spark-md5.min.js&quot; integrity=&quot;sha512-iWbxiCA4l1WTD0rRctt/BfDEmDC5PiVqFc6c1Rhj/GKjuj6tqrjrikTw3Sypm/eEgMa7jSOS9ydmDlOtxJKlSQ==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;file&quot; id=&quot;upload&quot;&gt; &lt;button onclick=&quot;upload()&quot;&gt;上传&lt;/button&gt; &lt;script&gt; const uploadInput = document.querySelector(&quot;#upload&quot;) async function upload() &#123; // 定义分片大小 const chunkSize = 1024 * 1024 * 3 // 文件大小 const fileSize = uploadInput.files[0].size // 记录文件完整的MD5值 const spark = new SparkMD5.ArrayBuffer() spark.append(uploadInput.files[0]) // 一共要分多少个切片 const chunkCount = Math.ceil(fileSize / chunkSize) // 存储所有切片信息 const chunkAll = [] for (let i = 0; i &lt; chunkCount; i++) &#123; const chunkItem = await createChunk(uploadInput.files[0], i, chunkSize) chunkAll.push(chunkItem) &#125; const formData = new FormData() chunkAll.forEach((item)=&gt;&#123; formData.append(&quot;chunk&quot;,item.blob, `chunk$&#123;item.index&#125;`) &#125;) formData.append(&quot;MD5&quot;, spark.end()) // 发送请求 fetch(&quot;http://localhost:3000/upload&quot;, &#123; method: &quot;POST&quot;, body: formData &#125;).then(res =&gt; res.json()).then(res =&gt; &#123; console.log(res) &#125;) &#125; // 创建每一个分片信息 function createChunk(file, index, chunkSize) &#123; return new Promise(resolve =&gt; &#123; // 开始位置 let start = index * chunkSize // 结束位置 let end = start + chunkSize // 进行切片 const blob = file.slice(start, end) const spark = new SparkMD5.ArrayBuffer() const fileReader = new FileReader() // 读取 fileReader.readAsArrayBuffer(blob) // 监听读取完毕 fileReader.onload = (e) =&gt; &#123; // 生成MD5值 spark.append(e.target.result) resolve(&#123; start, end, index, MD5: spark.end(), blob &#125;) &#125; &#125;) &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 后端 var express = require(&#x27;express&#x27;); const fs = require(&quot;fs&quot;) const crypto = require(&#x27;crypto&#x27;); const SparkMD5 = require(&#x27;spark-md5&#x27;) const path = require(&quot;path&quot;) var router = express.Router(); const multer = require(&#x27;multer&#x27;) const upload = multer(&#123; dest: &#x27;uploads/&#x27; &#125;) /* GET home page. */ router.post(&#x27;/upload&#x27;, upload.fields([ &#123; name: &quot;chunk&quot;, maxCount: 100 &#125;, ]), function (req, res, next) &#123; // 分片数组 const chunks = req.files.chunk; // 分片总数 const totalChunks = chunks.length; // 生成随机文件名 function generateRandomFileName() &#123; return crypto.randomBytes(16).toString(&#x27;hex&#x27;); &#125; // 输出文件路径，包含随机文件名 const randomFileName = generateRandomFileName(); const outputFile = path.join(&#x27;outChunks/&#x27;, randomFileName); // 确保 outChunks文件夹存在 if (!fs.existsSync(&#x27;outChunks&#x27;)) &#123; fs.mkdirSync(&#x27;outChunks&#x27;); &#125; // 确保输出文件不存在或清空已存在的文件 fs.writeFileSync(outputFile, &#x27;&#x27;); // 使用流进行文件合并 const outputStream = fs.createWriteStream(outputFile); let currentChunk = 0; function writeNextChunk() &#123; if (currentChunk &gt;= totalChunks) &#123; // 所有分片写入完毕，关闭输出流 outputStream.end(); return; &#125; const chunkStream = fs.createReadStream(chunks[currentChunk].path); chunkStream.pipe(outputStream, &#123; end: false &#125;); chunkStream.on(&#x27;end&#x27;, () =&gt; &#123; // console.log(`分片 $&#123;chunks[currentChunk].originalname&#125; 成功写入`); currentChunk++; writeNextChunk(); // 写入下一个分片 &#125;).on(&#x27;error&#x27;, (err) =&gt; &#123; console.error(`分片 $&#123;chunks[currentChunk].originalname&#125; 写入错误`, err); // 可能需要在这里处理错误，比如删除已写入的部分文件，记录日志等 &#125;); &#125; // 监听重组结束 outputStream.on(&#x27;finish&#x27;, () =&gt; &#123; chunks.forEach(chunk =&gt; &#123; fs.unlink(chunk.path, (err) =&gt; &#123; if (err) &#123; console.error(`删除分片文件 $&#123;chunk.path&#125; 出错:`, err); &#125; else &#123; // console.log(`分片文件 $&#123;chunk.path&#125; 已成功删除`); &#125; &#125;); &#125;); // 计算文件完整性 const spark = new SparkMD5.ArrayBuffer() spark.append(outputFile) if(req.body.MD5 === spark.end())&#123; console.log(&quot;文件完整&quot;) &#125;else&#123; console.log(&quot;文件不完整&quot;) &#125; &#125;).on(&#x27;error&#x27;, (err) =&gt; &#123; console.error(&#x27;文件合并过程中出现错误:&#x27;, err); &#125;); // 开始写入第一个分片 writeNextChunk(); &#125;); module.exports = router; 上传进度跟踪目前fetch并不能跟踪文件的上传进度，所以这里使用的是XMLHttpRequest &lt;input type=&quot;file&quot; id=&quot;file&quot;&gt; &lt;button id=&quot;uploadClick&quot;&gt;点击上传&lt;/button&gt; &lt;progress id=&quot;progress&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt; &lt;script&gt; const progress = document.querySelector(&quot;#progress&quot;) uploadClick.onclick = () =&gt; &#123; const file = document.querySelector(&quot;#file&quot;).files[0] const formData = new FormData() formData.append(&quot;file&quot;, file) // 发送请求 const xhr = new XMLHttpRequest() xhr.open(&#x27;post&#x27;, &#x27;http://127.0.0.1:3000/upload&#x27;) xhr.onload = (res) =&gt; &#123; console.log(&#x27;上传成功&#x27;, xhr.responseText) &#125; xhr.onloadstart = () =&gt; &#123; console.log(&quot;上传开始！&quot;) &#125;; xhr.upload.onprogress = (e) =&gt; &#123; // 当前进度 const currentPro = e.loaded/file.size * 100 console.log(&quot;当前进度&quot;, currentPro) progress.value = currentPro &#125; xhr.send(formData); &#125; &lt;/script&gt;","tags":["node"],"categories":["前端进阶"]},{"title":"sass实现主题切换","path":"/2024/06/17/78/","content":"需要用到的sass知识点 变量的定义 @mixin混入 @each遍历 实现代码@use &quot;sass:map&quot;; $light: ( bg-color: #ffffff, text-color: black ); $dark: ( bg-color: #2c2c2c, text-color: white ); // 存储主题 $themes: ( light: $light, dark: $dark ); @mixin theme($key, $value)&#123; // 遍历当前主题 @each $item in map.keys($themes) &#123; // 获取当前主题的颜色 $current-theme: map.get($themes, $item); // 不同主题使用不同主题颜色 [data-theme=&#x27;#&#123;$item&#125;&#x27;] &amp;&#123; #&#123;$key&#125;: map.get($current-theme, $value); transition: all 300ms; &#125; &#125; &#125; 使用@include theme(&#x27;background-color&#x27;, &#x27;bg-color&#x27;); @include theme(&#x27;color&#x27;, &#x27;text-color&#x27;);","tags":["sass"],"categories":["前端进阶"]},{"title":"GSAP基础知识","path":"/2024/06/16/76/","content":"安装 CDN &lt;script src=&quot;https://cdn.jsdelivr.net/npm/gsap@3.12/dist/gsap.min.js&quot;&gt;&lt;/script&gt; npm npm install gsap 使用gsap.to(&quot;.box&quot;, &#123;x: 200&#125;) 说明： to\t方法 .box\t类名 x\t水平方向移动的距离 有哪些方法 gsap.to()——这是一种最常用的tween动画，就是让元素从初始状态变化到目标状态 gsap.from()——有点像to方法的逆向变化，就是让元素从目标状态变化到初始状态。 gsap.fromTo()——需要自己定义两个状态的数据，然后从前一个变化到后一个。 gsap.set()——直接设置成想要的状态，没有任何过度与动画效果。本质上就是duration为0的 .to 方法 常用属性 属性 说明 x 水平移动 y 垂直移动 xPercent 水平移动（元素自身百分比） yPercent 垂直移动（元素自身百分比） rotation 旋转 scale 缩放 transformOrigin 设置旋转中心点 duration 动画变化的时长（秒）默认是0.5 delay 动画变化开始前的延迟时长（秒），默认是0.5 repeat 动画的重复次数 yoyo 如果设置为ture，那么动画会在执行完之后再反向执行一次，就像悠悠球的效果，默认是false stagger 是一个时间的设置（秒），如果有多个元素同时要被驱动，那么当这个属性设置了时间的值之后，元素们会被依次逐个驱动，间隔时长就是这个属性设置的时长 ease 动画过渡的运动曲线的设置，默认是”power1.out” onComplete 动画结束时执行的回调函数 Timelines时间线时间线能让我们创建非常容易调节的、很灵活的顺序动画效果。下面就是一个简单的包含着三个tween动画的timeline实例效果。默认情况下，这些动画是依次添加的，他们在变化的时候也是依次执行，而且是一个执行完之后再下一个执行。 // 创建一个Timeline类型的实例 let tl = gsap.timeline() // 把tween动画添加到timeline实例上，注意我们在用的是tl.to 而不是gsap.to tl.to(&quot;.green&quot;, &#123; x: 600, duration: 2 &#125;); tl.to(&quot;.purple&quot;, &#123; x: 600, duration: 1 &#125;); tl.to(&quot;.orange&quot;, &#123; x: 600, duration: 1 &#125;); 调整执行时间点 let tl = gsap.timeline() // 绿色方块会在整个时间线开始1秒后进行移动 tl.to(&quot;.green&quot;, &#123; x: 600, duration: 2 &#125;, 1); // 紫色方块会和之前一个添加的动画同时开始运动 tl.to(&quot;.purple&quot;, &#123; x: 600, duration: 1 &#125;, &quot;&lt;&quot;); // 橘色方块会在之前所有动画都结束一秒后再开始运动 tl.to(&quot;.orange&quot;, &#123; x: 600, duration: 1 &#125;, &quot;+=1&quot;); 特殊属性 Special Properties Timelines可以设置的动画属性和tween动画绝大部分是一样的，比如像repeat和delay，可以让你轻松的设定整个顺序动画的动画属性 let tl = gsap.timeline(&#123;repeat: -1, repeatDelay: 1, yoyo: true&#125;) tl.to(&quot;.green&quot;, &#123; rotation: 360 &#125;); tl.to(&quot;.purple&quot;, &#123; rotation: 360 &#125;); tl.to(&quot;.orange&quot;, &#123; rotation: 360 &#125;); 时间线的默认设置 如果你发现自己总是一遍又一遍的写同一个属性，那么你可以使用 defaults来进行设置。任何添加到时间线上的defaults的属性，都会被添加到这个时间线上的tween动画继承，像是通过to(),from()和fromTo()方式添加到时间线上的动画效果都是有这个继承效果的。利用这个方式可以让你的代码更简洁一些。 var tl = gsap.timeline(&#123; defaults: &#123; duration: 1 &#125; &#125;); //这样每个动画都是1秒的时长，不用重复写了 tl.to(&quot;.color1&quot;, &#123; x: 200 &#125;) tl.to(&quot;.color2&quot;, &#123; x: 200, scale: 0.2 &#125;) tl.to(&quot;.color3&quot;, &#123; x: 200, scale: 2, y: 20 &#125;); 控制动画通过一个变量保存对Tween或者Timeline实例的引用 let tween = gsap.to(&quot;.color1&quot;, &#123; duration: 10, x: 700 &#125;); 暂停动画：tween.pause() 继续动画：tween.resume() 反向变化：tween.reverse() 切换至动画1s时候的状态：tween.seek(1) 切换至动画1&#x2F;4时候的状态：tween.progress(1/4) 让动画速度变为原来的0.5倍：tween.timeScale(0.5) 销毁tween实例：tween.kill() 动画事件onStart：动画开始时触发 gsap.to(&quot;.color1&quot;, &#123;x:300,duration:3,onStart:event&#125;) function event()&#123; console.log(&#x27;触发&#x27;) &#125; onComplete：动画结束时触发 onUpdate：只要动画运行，每一帧都会触发（元素有属性变化时） onRepeat：每次动画重复时触发 onReverseComplete：当动画反向执行后运动到变化起始点时触发","tags":["GSAP"],"categories":["前端进阶"]},{"title":"GSAP插件介绍","path":"/2024/06/16/77/","content":"ScrollTrigger 一个可以将元素动画效果与浏览器滚动条关联起来的插件 引入依赖 &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/ScrollTrigger.min.js&quot;&gt;&lt;/script&gt; 使用 gsap.registerPlugin(ScrollTrigger) // 注册插件 gsap.to(&#x27;.box&#x27;, &#123; scrollTrigger: &#123; trigger: &#x27;.box&#x27;, // 在哪些元素上触发动画 scrub: true, // 将指定元素与滚动条进行关联 pin: true, // 固定元素 start: &quot;center center&quot; // 元素播放动画时在可视窗口的位置 &#125;, x: 500, ease: &quot;none&quot; &#125;);","tags":["GSAP"],"categories":["前端进阶"]},{"title":"three.js添加gui参数调试工具","path":"/2024/06/15/75/","content":"安装依赖npm install --save dat.gui 在vue中使用&lt;template&gt; &lt;div id=&quot;canvas&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import dat from &quot;dat.gui&quot; // 创建gui调试面板 // 创建控制对象 const controlData = &#123; color: &quot;#2f3542&quot; &#125; // 创建实例 const gui = new dat.GUI() const folder = gui.addFolder(&quot;参数调试&quot;) // 颜色选择器 folder.addColor(controlData, &quot;color&quot;) // 添加id选择器，方便后续进行样式控制 folder.domElement.id = &quot;gui&quot; folder.open() onMounted(()=&gt;&#123; // 将gui面板元素放入app中 document.getElementById(&quot;canvas&quot;).appendChild(folder.domElement) // 基础材质 const material = new THREE.MeshBasicMaterial(&#123; color: controlData.color &#125;) // 在动画函数中进行 function animate(time) &#123; // 调试颜色 mesh.material.color = new THREE.Color(controlData.color) &#125; &#125;) &lt;/script&gt;","tags":["three.js"],"categories":["前端进阶"]},{"title":"three.js添加轨道控制器","path":"/2024/06/14/73/","content":"引入import &#123; OrbitControls &#125; from &#x27;three/addons/controls/OrbitControls.js&#x27;; 添加轨道控制器const controls = new OrbitControls( camera, renderer.domElement ); 在动画函数中使用function animate( time) &#123; mesh.rotation.x = time / 2000; mesh.rotation.y = time / 1000; controls.update() renderer.render( scene, camera ); &#125; 添加阻尼controls.enableDamping = true controls.dampingFactor = 0.01 自动旋转controls.autoRotate = true controls.autoRotateSpeed = 1.2","tags":["three.js"],"categories":["前端进阶"]},{"title":"three.js常见知识点","path":"/2024/06/14/74/","content":"添加三维坐标const axesHelper = new THREE.AxesHelper(5) axesHelper.position.y = 1 scene.add(axesHelper) 修改背景颜色scene.background = new THREE.Color(&quot;#9aa7b1&quot;) 雾// 第一个参数是雾的颜色，第二个是雾的最小距离，第三个是雾的最大距离 scene.fog = new THREE.Fog(&quot;#f5f3f2&quot;, 10, 15) 添加背景图片素材网站：Poly Haven 素材分割：HDRI to CubeMap (matheowis.github.io) 注意：必须使用正方形图片才能生效!!! // 创建一个立方体纹理,左右上下前后 const cubeTexture = new THREE.CubeTextureLoader().setPath(&#x27;/textures/&#x27;).load([ &quot;px.png&quot;, &quot;nx.png&quot;, &quot;py.png&quot;, &quot;ny.png&quot;, &quot;pz.png&quot;, &quot;nz.png&quot; ]) scene.background = cubeTexture 材质贴图// 创建一个纹理 const texture = new THREE.TextureLoader().load(&quot;/star.jpg&quot;) // 基础材质 const material = new THREE.MeshBasicMaterial(&#123; map: texture &#125;) 环境贴图// 创建一个立方体纹理,左右上下前后 const cubeTexture = new THREE.CubeTextureLoader().setPath(&#x27;/textures/&#x27;).load([ &quot;px.png&quot;, &quot;nx.png&quot;, &quot;py.png&quot;, &quot;ny.png&quot;, &quot;pz.png&quot;, &quot;nz.png&quot; ]) const material = new THREE.MeshBasicMaterial(&#123; envMap: cubeTexture &#125;) 将物体变为线框材质material.wireframe = true BufferGeometry自定义几何体 第一种方式 const geometry = new THREE.BufferGeometry() const float32Array = new Float32Array([ 0,0,1, 1,0,1, 1,1,1, 1,1,1, 0,1,1, 0,0,1 ]) geometry.setAttribute(&quot;position&quot;,new THREE.BufferAttribute(float32Array,3)) 预览： 第二种方式 前面那种方式发现在绘制点的时候，会有一些重复的点，可以采用索引的方式进行绘制 const geometry = new THREE.BufferGeometry() const float32Array = new Float32Array([ 0,0,1, 1,0,1, 1,1,1, // 1,1,1, 0,1,1, // 0,0,1 ]) geometry.setAttribute(&quot;position&quot;,new THREE.BufferAttribute(float32Array,3)) // 创建一个索引 const indexs = new Uint16Array([ 0,1,2,2,3,0 ]) geometry.index = new THREE.BufferAttribute(indexs,1) 自定义uv坐标如果你想要显示纹理图片的某一个部分，而不是全部显示，就可以考虑使用这个 // 定义uv像素的取值范围 左上 右上 左下 右下 const uv = new Float32Array([ 0.5,1, 1,1, 0.5,0, 1,0 ]) geometry.attributes.uv = new THREE.BufferAttribute(uv,2) 环境光源与点光源预览： 添加环境光源 // 颜色，光照强度 const light = new THREE.AmbientLight(&quot;#ecf0f1&quot;,1) scene.add(light) 添加点光源 const pointLight = new THREE.PointLight(&quot;#ffffff&quot;,100,100) pointLight.position.set(5,5,5) scene.add(pointLight) 设置阴影效果 正方体的设置： // 物体接受光源 mesh.receiveShadow = true // 物体投射光源 mesh.castShadow = true 地面的设置： meshfloor.receiveShadow = true 点光源的设置： pointLight.castShadow = true 渲染器的设置： renderer.shadowMap.enabled=true 全部代码 &lt;template&gt; &lt;div id=&quot;canvas&quot;&gt;&lt;/div&gt; &lt;/template&gt; &lt;script setup lang=&quot;js&quot;&gt; import * as THREE from &#x27;three&#x27;; import &#123; onMounted &#125; from &quot;vue&quot; // 引入轨道控制器 import &#123; OrbitControls &#125; from &#x27;@/assets/js/OrbitControls.js&#x27; const width = document.documentElement.clientWidth const height = document.documentElement.clientHeight // 创建3d场景 const scene = new THREE.Scene() // 创建3维坐标 const axesHelper = new THREE.AxesHelper(5) scene.add(axesHelper) // 创建相机 const camera = new THREE.PerspectiveCamera(60, 2, 0.1, 500) camera.position.z = 7 camera.position.y = 3 // 创建正方体 const geometry = new THREE.BoxGeometry(1,1,1) // 创建地面 const geometryFloor = new THREE.PlaneGeometry(10,10) // 添加灯光效果 // 环境光 const light = new THREE.AmbientLight(&quot;#ecf0f1&quot;,1) scene.add(light) // 点光源 const pointLight = new THREE.PointLight(&quot;#ffffff&quot;,100,100) pointLight.position.set(5,5,5) pointLight.castShadow = true scene.add(pointLight) // 基础材质 const material = new THREE.MeshPhongMaterial(&#123; color: &quot;#54a0ff&quot;, // 灯光打到物体上的高亮程度，越高的值越闪亮 shininess: 500 &#125;) // 基础材质 const materialFloor = new THREE.MeshPhongMaterial(&#123; color: &quot;#bdc3c7&quot; &#125;) // 网格 const mesh = new THREE.Mesh(geometry, material) const meshfloor = new THREE.Mesh(geometryFloor, materialFloor) mesh.position.set(0, 0.5, 0) // 物体接受光源 mesh.receiveShadow = true // 物体投射光源 mesh.castShadow = true meshfloor.rotation.x -= Math.PI / 2 meshfloor.receiveShadow = true scene.add(mesh) scene.add(meshfloor) // 创建渲染器 const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;) // 调整渲染器大小 renderer.setSize(width, height) // 阴影投射 renderer.shadowMap.enabled=true onMounted(() =&gt; &#123; // 添加动画 renderer.setAnimationLoop(animate) document.querySelector(&#x27;#canvas&#x27;).appendChild(renderer.domElement) // 添加轨道控制器 const controls = new OrbitControls(camera, renderer.domElement); // 动画函数 function animate(time) &#123; // mesh.rotation.x = time / 2000; // mesh.rotation.y = time / 1000; controls.update() renderer.render(scene, camera); &#125; &#125;) // 添加网格地面 // const gridHelper = new THREE.GridHelper(10, 10) // scene.add(gridHelper) // 进行渲染 renderer.render(scene, camera) &lt;/script&gt; &lt;style&gt;&lt;/style&gt; 组可以给一些物体进行统一的一个编组，方便对其进行统一的控制 const geometry = new THREE.BoxGeometry( 1, 1, 1 ); const material = new THREE.MeshBasicMaterial( &#123;color: 0x00ff00&#125; ); const cubeA = new THREE.Mesh( geometry, material ); cubeA.position.set( 100, 100, 0 ); const cubeB = new THREE.Mesh( geometry, material ); cubeB.position.set( -100, -100, 0 ); //create a group and add the two cubes //These cubes can now be rotated / scaled etc as a group const group = new THREE.Group(); group.add( cubeA ); group.add( cubeB ); scene.add( group ); GLTF加载器（GLTFLoader）glTF（gl传输格式）是一种开放格式的规范 （open format specification）， 用于更高效地传输、加载3D内容。该类文件以JSON（.gltf）格式或二进制（.glb）格式提供， 外部文件存储贴图（.jpg、.png）和额外的二进制数据（.bin）。一个glTF组件可传输一个或多个场景， 包括网格、材质、贴图、蒙皮、骨架、变形目标、动画、灯光以及摄像机 导入 import &#123; GLTFLoader &#125; from &#x27;three/addons/loaders/GLTFLoader.js&#x27;; 使用 // 创建一个GTLF加载器 const loader = new GLTFLoader() // 加载 loader.load(&quot;/xuefulan.glb&quot;, (gltf)=&gt;&#123; scene.add(gltf.scene) &#125;)","tags":["three.js"],"categories":["前端进阶"]},{"title":"使用docker镜像nginx进行项目部署","path":"/2024/06/13/71/","content":"准备阶段 准备任意一个项目，或者直接一个html文件 下载docker，自行前往官网进行下载 可以提前了解一下docker的数据卷挂载，可以将宿主机文件与docker容器中的文件进行一个同步，方便对nginx进行配置与日志查看 这篇教程不适合对docker完全不懂的人，不然你很难理解，甚至难以感受到docker进行项目部署的方便 我这里使用的是windows11操作系统进行演示，虽然docker有可视化窗口，但是我这里主要使用命令的形式教大家进行部署，我这里使用的是react项目 下载nginxdocker pull nginx 我的nginx版本为：1.27.0，不同版本的nginx目录结构可能有所不同 在项目中新建一个目录nginx这个目录下在新建conf，logs目录，用来存放配置文件和日志文件 启动nginx容器docker run -d -p 80:80 -v D:\\我的项目\\react项目之博客后台系统\\App ginx\\logs:/var/log/nginx -v D:\\我的项目\\react项目之博客后台系统\\App ginx\\conf:/etc/nginx/conf.d -v D:\\我的项目\\react项目之博客后台系统\\App\\dist:/usr/share/nginx/html/dist nginx 此时项目中的conf，logs，dist目录就已经和容器中同步了 在conf目录下新建一个default.conf文件，可以看到容器中也多了一个： 到这里就快成功了 编辑default.conf文件： server &#123; listen 80; listen [::]:80; server_name localhost; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html/dist; index index.html index.htm; # 解决路由模式为history报404错误 try_files $uri $uri/ /index.html; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; &#125; 配置文件修改必需重启容器后才生效哦 docker restart 容器ID或者容器名 或者可视化界面中： 测试是否成功访问 http://localhost/","tags":["Docker"],"categories":["全栈工程师"]},{"title":"使用three.js创建一个最基础的3d场景","path":"/2024/06/13/72/","content":"效果图 代码import * as THREE from &#x27;three&#x27;; const width = document.documentElement.clientWidth const height = document.documentElement.clientHeight // 创建3d场景 const scene = new THREE.Scene() // 创建相机 const camera = new THREE.PerspectiveCamera() camera.position.z = 7 camera.position.y = 3 // 创建立方体 const boxGeometry = new THREE.BoxGeometry(0.5,0.5,0.5) // 基础材质 const material = new THREE.MeshBasicMaterial(&#123; color: &quot;#70a1ff&quot; &#125;) // 网格 const mesh = new THREE.Mesh(boxGeometry,material) mesh.position.set(0, 3, 0) scene.add(mesh) // 创建渲染器 const renderer = new THREE.WebGLRenderer(&#123; antialias: true &#125;) // 调整渲染器大小 renderer.setSize(width, height) // 添加动画 renderer.setAnimationLoop(animate) document.body.appendChild(renderer.domElement) // 添加网格地面 const gridHelper = new THREE.GridHelper(10, 10) scene.add(gridHelper) // 动画函数 function animate(time) &#123; mesh.rotation.x = time / 2000; mesh.rotation.y = time / 1000; renderer.render( scene, camera ); &#125;","tags":["three.js"],"categories":["前端进阶"]},{"title":"Docker安装mysql","path":"/2024/06/12/69/","content":"要达到的目的 实现mysql安装，并且能让外部进行连接 实现数据卷的挂载，让容器被删除时，数据不会丢失 解决无法插入中文数据，或者中文乱码 docker pull mysql 启动mysqldocker run -d -p 3306:3306 --privileged=true -v /root/mysql/log:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 查看数据卷是否挂载成功 进入mysql容器docker exec -it 49aecf50ef9c /bin/bash 基础操作： 外部连接数据库自己下载数据库连接工具，例如：Navicat 查看本机地址 ip addr 使用navicat连接： 插入中文数据看看发现无法插入中文数据 原因： 查看数据库默认字符集： SHOW VARIABLES LIKE &#x27;character_set_%&#x27;; 发现是latin1,而不是utf8 将字符集修改为utf-8格式: 修改配置文件（&#x2F;root&#x2F;mysql&#x2F;conf）： 在&#x2F;root&#x2F;mysql&#x2F;conf 目录下新建一个my.cnf文件使用vim进行编辑： [client] default_character_set=utf8 [mysqld] collation_server = utf8_general_ci character_set_server = utf8 然后重启mysql容器 docker restart 容器id/容器名 然后再新建数据库，不能在原有的数据库中测试 再次查看数据库字符集： 发现可以插入中文数据了：","tags":["Docker"],"categories":["全栈工程师"]},{"title":"Dockerfile介绍","path":"/2024/06/12/70/","content":"介绍类似一个构建镜像的清单，docker可以根据这个清单进行镜像的自动化构建 保留字1. FROM指定基础镜像，并且必须是第一条指令 FROM &lt;image&gt; FROM &lt;image&gt;:&lt;tag&gt; 2. MAINTAINER指定作者 MAINTAINER &lt;name&gt; 3. RUN在构建镜像时需要运行的命令 例如： RUN yum -y install vim RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] # 等价于 RUN ./test.php dev offline 4. CMD容器启动后需要运行的命令 例如： CMD echo &quot;hello world&quot; CMD [&quot;catalina.sh&quot;, &quot;run&quot;] 5. ENTRYPOINT容器启动后需要运行的命令，类似于CMD，但是不会被docker run后面的命令覆盖，这些命令参数会被当做参数送给ENTRYPOINT指令指定的程序。 例如： FROM nginx ENTRYPOINT [&quot;nginx&quot;, &quot;-c&quot;] # 定参 CMD [&quot;/etc/nginx/nginx.conf&quot;] # 变参 # nginx -c /etc/nginx/nginx.conf 6. ENV在镜像构建时，创建环境变量 例如： ENV MY_PATH /usr/mytest # 使用环境变量 WORKDIR $MY_PATH 7. EXPOSE当前容器对外暴露出的端口 例如： EXPOSE 80 8. COPY复制本地文件或目录到镜像中 例如： COPY 【源路径】【容器路径】 9. ADD将宿主机目录下（或远程文件）的文件拷贝进镜像，且会自动处理URL和解压tar压缩包。 例如： ADD https://example.com/file.tar.gz /tmp/ 10. WORKDIR设置工作目录，后续命令将在该目录下执行 例如： WORKDIR /app","tags":["Docker"],"categories":["全栈工程师"]},{"title":"Docker常用命令","path":"/2024/06/04/67/","content":"docker 基础命令 启动docker systemctl start docker 关闭docker systemctl stop docker 重启docker systemctl restart docker docker设置随服务启动而自启动 systemctl enable docker 查看docker 运行状态 systemctl status docker 如果是在运行中 输入命令后 会看到绿色的active 查看docker 版本号信息 docker version docker info docker 帮助命令 docker --help 比如 咱忘记了 拉取命令 不知道可以带哪些参数 咱可以这样使用 docker pull --help docker 镜像命令 查看自己服务器中docker 镜像列表 docker images 搜索镜像 docker search 镜像名 docker search --filter=STARS=9000 mysql 搜索 STARS &gt;9000的 mysql 镜像 拉取镜像 不加tag(版本号) 即拉取docker仓库中 该镜像的最新版本latest 加:tag 则是拉取指定版本 docker pull 镜像名 docker pull 镜像名:tag 比如拉取ubuntu： 删除镜像 删除一个： docker rmi -f 镜像名/镜像ID 删除多个 其镜像ID或镜像用用空格隔开即可 docker rmi -f 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID 删除全部镜像 -a 意思为显示全部, -q 意思为只显示ID docker rmi -f $(docker images -aq) 强制删除镜像 docker image rm 镜像名称/镜像ID 保存镜像 将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像 docker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字 加载镜像 任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像 docker load -i 镜像保存文件位置 容器命令 通过镜像运行一个容器 docker run 镜像名字 查看正在运行的容器 docker ps 常用参数： -a :列出当前所有的容器 -l :显示最近创建的容器。 -n nu：显示最近nu个创建的容器。 -q :静默模式，只显示容器编号。 运行容器时的常用参数 -it: 命令交互式 比如运行ubuntu docker run -it ubuntu 退出交互： 输入exit：容器也会停止运行 输入ctrl+p+q: 容器不会停止运行 -d: 后台守护式 比如运行redis： docker run -d redis 进入正在运行的容器并以命令行交互 # 这种方式会打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器的停止 docker exec -it 容器ID/容器名称 /bin/bash # 直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会导致容器的停止 docker attach 容器ID 比如进入redis： 停止容器 docker stop 容器ID或者容器名 强制停止容器 docker kill 容器ID或容器名 启动已停止运行的容器 docker start 容器ID或者容器名 重启容器 docker restart 容器ID或者容器名 删除已停止的容器 #删除一个 docker rm 容器ID docker rm -f 容器ID #强制删除 #删除多个 docker rm -f $(docker ps -a -q) 或 docker ps -a -q | xargs docker rm 查看容器日志 docker logs 容器ID 查看容器内运行的进程 docker top 容器ID 查看容器内部细节 查看其json文件 docker inspect 容器ID 从容器内拷贝文件到主机上 docker cp 容器ID:容器内路径 目的主机路径 例如： docker cp 3d26bf46bbb0:/home/ubuntu/a.txt /root/test 导入和导出容器 docker export 容器ID &gt; 文件名.tar cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号 挂载数据卷 如何理解 就是宿主机与docker容器之间的文件进行一个同步操作，例如：当我指定某个宿主机目录与docker容器中的某个目录进行数据卷挂载的时候，那么无论是我操作宿主机中的这个目录，还是docker容器中的目录时，他们之间都会进行数据共享，使两者目录的内容保持一致 数据卷的特点 数据卷可在容器之间共享或重用数据 卷中的更改可以直接生效 数据卷中的更改不会包含在镜像的更新中 数据卷的生命周期一直持续到没有容器使用它为止 使用： 首先在宿主机上面创建一个目录tmp，方便后续测试 以数据卷挂载的方式运行一个ubuntu容器 docker run -it -v /root/tmp:/tmp ubuntu 解释： -v &#x2F;root&#x2F;tmp:&#x2F;tmp：-v就是指定需要进行数据卷挂载，冒号左边的是宿主机目录，右边是docker容器目录 运行成功后应该会看到一个tmp目录, cd进去 创建一个test.txt文件 返回宿主机目录发现在tmp目录下出现了一个test.txt文件 再到宿主机上面创建一个host.txt 然后再查看docker中是否数据进行了同步更新 到这里就完成了宿主机与docker容器中的一个数据同步更新了 自己提交一个镜像我们运行的容器可能在镜像的基础上做了一些修改，有时候我们希望保存起来，封装成一个更新的镜像，这时候我们就需要使用 commit 命令来构建一个新的镜像 docker commit -m=&quot;提交信息&quot; -a=&quot;作者信息&quot; 容器名/容器ID 提交后的镜像名:Tag 本地镜像发布到阿里云首先登录阿里云，然后进入控制台 然后可以在快捷入口这里添加一个容器镜像服务 点击进去选择个人版或者企业版即可 然后设置密码： 创建命名空间： 接着创建镜像仓库： 最后会给你一个操作指南，跟着做就行","tags":["Docker"],"categories":["全栈工程师"]},{"title":"Centos7安装Docker","path":"/2024/06/03/66/","content":"原文地址在：https://blog.csdn.net/qq_26400011&#x2F;article&#x2F;details&#x2F;113856681 卸载系统上原有的Dockeryum remove docker \\ &gt; docker-client \\ &gt; docker-client-latest \\ &gt; docker-common \\ &gt; docker-latest \\ &gt; docker-latest-logrotate \\ &gt; docker-logrotate \\ &gt; docker-engine 安装需要的安装包yum-utilsyum install -y yum-utils 设置镜像仓库地址 docker默认的官方仓库地址 yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo ##此地址为官方的仓库地址，在国内建议不要用 阿里云的镜像仓库地址 yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker相关的引擎 先更新yum软件包索引 yum makecache fase docker社区、ee企业版 ce为社区版 官方推荐使用ce版，默认安装最新的docker版本，也可以指定版本安装 yum install docker-ce docker-ce-cli containerd.io 启动dockersystemctl start docker 使用hello-world镜像测试dockerdocker run hello-world 卸载docker 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io 删除资源 rm -rf /var/lib/docker","tags":["Docker"],"categories":["全栈工程师"]},{"title":"js中判断数据类型的方法","path":"/2024/05/29/65/","content":"typeof这种方法存在缺陷，在js中数组[], 也视为对象{}，所以无法区分数组与对象 let obj = &#123;&#125; let arr = [] let str = &#x27;&#x27; console.log(typeof obj) // object console.log(typeof arr) // object console.log(typeof str) // string toString()对于任何对象，obj.proto 指向该对象的原型对象（即构造函数的 prototype 属性所指向的对象） let obj = &#123;&#125; let arr = [] let str = &#x27;&#x27; console.log(obj.__proto__.toString()) // [object Object] console.log(arr.__proto__.toString()) // &#x27;&#x27; console.log(str.__proto__.toString()) // &#x27;&#x27; constructor在JavaScript中，constructor 属性是一个预定义在大多数对象的原型（prototype）上的属性，它指向创建该对象实例的构造函数 let obj = &#123;&#125; let arr = [] let str = &#x27;&#x27; console.log(obj.constructor) // ƒ Object() &#123; [native code] &#125; console.log(arr.constructor) // ƒ Array() &#123; [native code] &#125; console.log(str.constructor) // ƒ String() &#123; [native code] &#125;","tags":["js"],"categories":["前端3大件"]},{"title":"js中的微任务与宏任务","path":"/2024/05/28/64/","content":"微任务 Promise callbacks: 包括.then, .catch, 和 .finally的回调函数。 async/await: 当使用await关键字等待一个Promise时，后续的代码作为微任务执行。 MutationObserver: 用于监视DOM树的变化，其回调函数作为微任务执行。 queueMicrotask: 在某些环境中（如Node.js），这是一个直接将函数放入微任务队列的方法。 process.nextTick（Node.js环境）: 虽然不直接属于ES规范中的微任务，但它具有类似的行为，常用于Node.js中立即执行的回调。 宏任务 setTimeout 和 setInterval: 用于延迟或周期性执行代码。 setImmediate（Node.js环境）: 提供了一个比setTimeout(0)更快的执行方式，用于在I&#x2F;O循环的下一次迭代开始时执行。 I/O: 如文件读写等操作通常作为宏任务调度。 UI Rendering: 浏览器中的渲染任务，如对DOM的修改触发的重绘和回流。 Event Loop Iteration: 每次事件循环的迭代本身也可以视为一个宏任务。 requestAnimationFrame: 用于在下一次浏览器重绘之前执行回调，常用于动画和高性能UI更新。 script: 整体的JavaScript脚本执行也是一个宏任务。","tags":["js"],"categories":["前端3大件"]},{"title":"为git配置代理(解决开启科学上网后，push报错问题)","path":"/2024/05/22/63/","content":"本文参考至: 解决挂着Clash的时候git操作push失败的问题-CSDN博客 问题源当开启Clash后，本机网络会被代理，此时可以在 设置-网络-代理 中看到： 失败的原因就是本机开启了代理，而git没有设置代理，导致443端口转发不过去 解决设置代理: git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 取消和查看代理: 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy 查看代理 git config --global --get http.proxy git config --global --get https.proxy git config --list","tags":["git"],"categories":["前端进阶"]},{"title":"vue3扩展学习","path":"/2024/05/20/62/","content":"createApp()创建一个应用实例。 function createApp(rootComponent: Component, rootProps?: object): App 第一个参数是根组件。第二个参数可选，它是要传递给根组件的 props。 app.component()如果同时传递一个组件名字符串及其定义，则注册一个全局组件；如果只传递一个名字，则会返回用该名字注册的组件 (如果存在的话)。 interface App &#123; component(name: string): Component | undefined component(name: string, component: Component): this &#125; app.directive()如果同时传递一个名字和一个指令定义，则注册一个全局指令；如果只传递一个名字，则会返回用该名字注册的指令 (如果存在的话)。 interface App &#123; directive(name: string): Directive | undefined directive(name: string, directive: Directive): this &#125; app.provide()提供一个值，可以在应用中的所有后代组件中注入使用。 app.version获取当前vue的版本号 app.config.errorHandler用于为应用内抛出的未捕获错误指定一个全局处理函数。 interface AppConfig &#123; errorHandler?: ( err: unknown, instance: ComponentPublicInstance | null, // `info` 是一个 Vue 特定的错误信息 // 例如：错误是在哪个生命周期的钩子上抛出的 info: string ) =&gt; void &#125; app.config.warnHandler用于为 Vue 的运行时警告指定一个自定义处理函数。 interface AppConfig &#123; warnHandler?: ( msg: string, instance: ComponentPublicInstance | null, trace: string ) =&gt; void &#125; app.config.globalProperties一个用于注册能够被应用内所有组件实例访问到的全局属性的对象。 这是对 Vue 2 中 Vue.prototype 使用方式的一种替代，此写法在 Vue 3 已经不存在了。与任何全局的东西一样，应该谨慎使用。 如果全局属性与组件自己的属性冲突，组件自己的属性将具有更高的优先级。 app.config.globalProperties.msg = &#x27;hello&#x27; 选项式中使用 export default &#123; mounted() &#123; console.log(this.msg) // &#x27;hello&#x27; &#125; &#125; 组合式中使用 import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;; const instance = getCurrentInstance() console.log(instance.appContext.config.globalProperties.msg) isRef()检查某个值是否为 ref。","tags":["vue"],"categories":["前端进阶"]},{"title":"react易忘知识点","path":"/2024/05/20/68/","content":"组件通信1.父传子function Children(props)&#123; return( &lt;div&gt;我是孩子:&#123;props.msg&#125;&lt;/div&gt; ) &#125; function App()&#123; const msg = &#x27;传递给孩子的东西&#x27; return( &lt;div&gt; &lt;Children msg=&#123;msg&#125;&gt;&lt;/Children&gt; &lt;/div&gt; ) &#125; export default App 2.子传父就是在传递props的时候，传递一个函数 import &#123; useEffect &#125; from &quot;react&quot; import &#123; useState &#125; from &quot;react&quot; function Children(props)&#123; const msg = &#x27;传递给父亲的东西&#x27; const &#123;onMsg&#125; = props useEffect(()=&gt;&#123; onMsg(msg) &#125;,[]) return( &lt;div&gt;我是孩子:&lt;/div&gt; ) &#125; function App()&#123; let [data, setData] = useState() const msg = (value)=&gt;&#123; setData(value) &#125; return( &lt;div&gt; &lt;Children onMsg=&#123;msg&#125;&gt;&lt;/Children&gt; &lt;h6&gt;&#123;data&#125;&lt;/h6&gt; &lt;/div&gt; ) &#125; export default App 3.使用createContext()进行跨级通信import &#123; createContext &#125; from &quot;react&quot; import &#123; useContext &#125; from &quot;react&quot; const MsgContext = createContext() function Demo1()&#123; return( &lt;div&gt;demo1 &lt;Demo2&gt;&lt;/Demo2&gt; &lt;/div&gt; ) &#125; function Demo2()&#123; const msg = useContext(MsgContext) return( &lt;div&gt;demo2:&#123;msg&#125;&lt;/div&gt; ) &#125; function App()&#123; const msg = &quot;我是父组件&quot; return( &lt;div&gt; &lt;MsgContext.Provider value=&#123;msg&#125;&gt; this is App &lt;Demo1&gt;&lt;/Demo1&gt; &lt;/MsgContext.Provider&gt; &lt;/div&gt; ) &#125; export default App redux的使用首先安装依赖： npm i react-redux @reduxjs/toolkit 创建store文件夹，用于配置redux 创建modules目录，用于存放具体模块，创建index.js文件用于集中导出 例如创建一个counterStore.js用于存放计数信息 import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;; const counterStore = createSlice(&#123; name: &quot;counter&quot;, // 初始化state initialState: &#123; count: 0 &#125;, // 修改状态的方法 reducers: &#123; inscrement(state)&#123; state.count++ &#125;, descrement(state)&#123; state.count-- &#125;, &#125; &#125;) // 解构actions const &#123;inscrement,descrement&#125; = counterStore.actions // 获取reducer const reducer = counterStore.reducer // 导出 export &#123;inscrement,descrement&#125; export default reducer index.js: import &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;; import counterReducer from &quot;./modules/counterStore&quot; const store = configureStore(&#123; reducer: &#123; counter: counterReducer &#125; &#125;) export default store 入口文件main.jsx: import React from &#x27;react&#x27; import ReactDOM from &#x27;react-dom/client&#x27; import App from &#x27;./App.jsx&#x27; import &#x27;./index.css&#x27; import store from &#x27;./store/index.js&#x27; import &#123; Provider &#125; from &#x27;react-redux&#x27; ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)).render( &lt;React.StrictMode&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;, ) 使用： import &#123; useSelector,useDispatch &#125; from &quot;react-redux&quot; import &#123; inscrement,descrement &#125; from &quot;./store/modules/counterStore&quot; function App()&#123; const &#123;count&#125; = useSelector(state=&gt;state.counter) const dispatch = useDispatch() return( &lt;div&gt; &lt;div&gt;使用redux进行状态管理&lt;/div&gt; &lt;div&gt;当前状态&#123;count&#125;&lt;/div&gt; &lt;button style=&#123;&#123;marginRight:10&#125;&#125; onClick=&#123;()=&gt;dispatch(inscrement())&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;()=&gt;dispatch(descrement())&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125; export default App 路由知识安装依赖： npm i react-router-dom 新建一个router目录,再新建一个index.js文件用以配置路由 import &#123;createBrowserRouter&#125; from &quot;react-router-dom&quot; import Home from &quot;../pages/Home&quot; import About from &quot;../pages/About&quot; const router = createBrowserRouter([ &#123; path: &quot;/&quot;, element: &lt;Home/&gt; &#125;, &#123; path: &quot;/about&quot;, element: &lt;About/&gt; &#125; ]) export default router main.jsx: import React from &#x27;react&#x27; import ReactDOM from &#x27;react-dom/client&#x27; import &#x27;./index.css&#x27; import &#123;RouterProvider&#125; from &quot;react-router-dom&quot; import router from &quot;./router&quot; ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;)).render( &lt;React.StrictMode&gt; &lt;RouterProvider router=&#123;router&#125; /&gt; &lt;/React.StrictMode&gt; )","tags":["react"],"categories":["前端进阶"]},{"title":"webpack基础知识","path":"/2024/04/02/61/","content":"需要安装的模块&#123; &quot;name&quot;: &quot;webpack&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;@babel/core&quot;: &quot;^7.23.9&quot;, &quot;@babel/preset-env&quot;: &quot;^7.23.9&quot;, &quot;add-asset-html-webpack-plugin&quot;: &quot;^6.0.0&quot;, &quot;autoprefixer&quot;: &quot;^10.4.17&quot;, &quot;babel-loader&quot;: &quot;^9.1.3&quot;, &quot;css-loader&quot;: &quot;^6.10.0&quot;, &quot;css-minimizer-webpack-plugin&quot;: &quot;^6.0.0&quot;, &quot;csv-loader&quot;: &quot;^3.0.5&quot;, &quot;dart-sass&quot;: &quot;^1.25.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^5.6.0&quot;, &quot;imports-loader&quot;: &quot;^5.0.0&quot;, &quot;json5&quot;: &quot;^2.2.3&quot;, &quot;mini-css-extract-plugin&quot;: &quot;^2.8.0&quot;, &quot;postcss-loader&quot;: &quot;^8.1.0&quot;, &quot;sass-loader&quot;: &quot;^14.1.0&quot;, &quot;style-loader&quot;: &quot;^3.3.4&quot;, &quot;terser-webpack-plugin&quot;: &quot;^5.3.10&quot;, &quot;toml&quot;: &quot;^3.0.0&quot;, &quot;ts-loader&quot;: &quot;^9.5.1&quot;, &quot;typescript&quot;: &quot;^5.3.3&quot;, &quot;webpack&quot;: &quot;^5.90.0&quot;, &quot;webpack-bundle-analyzer&quot;: &quot;^4.10.1&quot;, &quot;webpack-cli&quot;: &quot;^5.1.4&quot;, &quot;webpack-dev-server&quot;: &quot;^4.15.1&quot;, &quot;webpack-merge&quot;: &quot;^5.10.0&quot;, &quot;xml-loader&quot;: &quot;^1.2.1&quot;, &quot;yaml&quot;: &quot;^2.3.4&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;lodash&quot;: &quot;^4.17.21&quot;, &quot;rgb-random-lazychild&quot;: &quot;^1.0.2&quot; &#125;, &quot;browserslist&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;] &#125; 基本命令&quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;webpack serve --config webpack.config.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.config.js&quot; &#125; 基本配置webpack 的配置文件为：webpack.config.js const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); module.exports = &#123; entry: &quot;./src/index.js&quot;, //以哪个文件为主 output: &#123; // filename: &#x27;[name].[contenthash].js&#x27;, filename: &quot;index.js&quot;, path: path.resolve(__dirname, &quot;./dist&quot;), //绝对路径 clean: true, //清理上次打包的文件 &#125;, mode: &quot;development&quot;, // 指定运行模式为开发模式 devtool: &quot;eval-cheap-module-source-map&quot;, plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;./index.html&quot;, filename: &quot;app.html&quot;, inject: &quot;body&quot;, //在body里面生成script标签 &#125;), ], // 配置热更新服务器 devServer: &#123; static: &quot;./dist&quot;, &#125;, &#125;; 静态资源处理1.处理图片文件asset&#x2F;resource: module: &#123; rules: [ &#123; //处理图片文件 test: /\\.png$/, type: &quot;asset/resource&quot;, //类型 // 路径 generator: &#123; filename: &quot;images/[contenthash][ext]&quot;, &#125;, &#125;, ]; &#125; asset&#x2F;inline: module: &#123; rules: [ &#123; //处理图片文件 test: /\\.svg$/, type: &quot;asset/inline&quot;, //inline类型,将图片变为base64 &#125;, ]; &#125; asset: module: &#123; rules: [ &#123; //处理图片文件 test: /\\.png$/, type: &quot;asset&quot;, //类型：自动选择：默认如果大于8k--&gt;本地资源，否则就是inline类型 // 自定义 parser: &#123; dataUrlCondition: &#123; maxSize: 4 * 1024 * 1024, //如果图片大于4M，那么就作为本地资源，否则就是inline类型 &#125;, &#125;, &#125;, ]; &#125; 2.处理纯文本module: &#123; rules: [ &#123; //处文本文件 test: /\\.txt$/, type: &quot;asset/source&quot;, //类型 &#125;, ]; &#125; 3.处理字体文件module: &#123; rules: [ &#123; // 加载字体 test: /\\.(woff|woff2|eot|ttf|otf)$/, type: &quot;asset/resource&quot;, // 路径 generator: &#123; filename: &quot;iconFont/[contenthash][ext]&quot;, &#125;, &#125;, ]; &#125; 4.其它文件的处理module: &#123; rules: [ &#123; test: /\\.toml$/, type: &#x27;json&#x27;, // 指定解析器 parser: &#123; parse: toml.parse, &#125; &#125;, &#123; test: /\\.yaml$/, type: &#x27;json&#x27;, parser: &#123; parse: yaml.parse, &#125; &#125;, &#123; test: /\\.json5$/, type: &#x27;json&#x27;, parser: &#123; parse: json5.parse, &#125; &#125;, &#123; test: /\\.csv$/, use: &#x27;csv-loader&#x27; &#125;, &#123; test: /\\.xml$/, use: &#x27;xml-loader&#x27; &#125; ], &#125;, babel-loader这个可以将 ES6 转 ES5 // 需要安装的库 /** * 1. babel-loader: 用于处理es6语法 * 2. @babel/core: babel核心库 * 3. @babel/preset-env: babel预设库, 一组babel插件集合 */ module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; presets: [&quot;@babel/preset-env&quot;], &#125;, &#125;, &#125;, ]; &#125; 代码分离防止引入的第三方库重复导出 内置模块处理： optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;; //对所有模块进行分割 &#125; &#125; 使用 dependOn: module.exports = &#123; // 多个入口文件 entry: &#123; index: &#123; import: &quot;./src/index.js&quot;, dependOn: &quot;comment&quot;, &#125;, another: &#123; import: &quot;./src/another.js&quot;, dependOn: &quot;comment&quot;, &#125;, comment: &quot;lodash&quot;, &#125;, &#125;; 预获取和预加载预获取 prefetch: 在浏览器加载完必要的资源后，空闲时就会去获取可能需要的资源。 预加载 preload: 预先加载当前页面可能需要的资源， 它会与必要资源并行请求。 /* webpackPrefetch: true */ /* webpackPreload: true */ btn.addEventListener(&quot;click&quot;, () =&gt; &#123; import(/* webpackPrefetch: true */ &quot;./math&quot;).then((&#123; add &#125;) =&gt; &#123; console.log(add(4, 8)); &#125;); &#125;); 缓存第三方库optimization: &#123; splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &#x27;vendors&#x27;, chunks: &#x27;all&#x27; &#125; &#125; &#125; &#125; 公共路径output: &#123; filename: &#x27;index.js&#x27;, path: path.resolve(__dirname, &#x27;./dist&#x27;), //绝对路径 clean: true, //清理上次打包的文件 publicPath: &#x27;http://127.0.0.1:5500/公共路径/dist/&#x27; //设置打包后的文件访问路径 &#125;, 动态改变 modemodule.exports = (env) =&gt; &#123; mode: env.production ? &#x27;production&#x27; : &#x27;development&#x27;, // 如果要压缩, 则需要生产环境 &#125; 配置文件的拆分与合并const &#123; merge &#125; = require(&quot;webpack-merge&quot;); const configDev = require(&quot;./webpack.config.dev&quot;); const configPro = require(&quot;./webpack.config.pro&quot;); const configCommon = require(&quot;./webpack.config.common&quot;); module.exports = (env) =&gt; &#123; switch (true) &#123; case env.development: return merge(configDev, configCommon); case env.production: return merge(configPro, configCommon); default: return new Error(&quot;No valid environment&quot;); &#125; &#125;; 路径别名resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;) &#125; &#125; 外部扩展externalsType: &quot;script&quot;, externals: &#123; jquery: [ &quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js&quot;, &quot;$&quot; ] &#125; 这样就可以直接使用了： import $ from &quot;jquery&quot;; console.log($); 依赖分析图使用插件：webpack-bundle-analyzer const &#123; BundleAnalyzerPlugin &#125; = require(&quot;webpack-bundle-analyzer&quot;); //依赖图插件 module.exports = &#123; plugins: [new BundleAnalyzerPlugin()], &#125;; css 的自动兼容module: &#123; rules: [ &#123; test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;postcss-loader&quot;], &#125;, ]; &#125; css 模块化module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &quot;style-loader&quot;, &#123; loader: &quot;css-loader&quot;, options: &#123; modules: true, &#125;, &#125;, ], &#125;, ]; &#125; 解析 sassmodule: &#123; rules: [ &#123; // 加载css或者scss文件 test: /\\.(css|scss)$/, use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, &#123; loader: &quot;sass-loader&quot;, options: &#123; implementation: require(&quot;dart-sass&quot;), &#125;, &#125;, ], //顺序不能改，，从数组后往前进行加载 &#125;, ]; &#125; 抽离与压缩 css需要生产环境 const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;); //提取css const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;); //压缩css module.exports = &#123; plugins: [ // 提取css new MiniCssExtractPlugin(&#123; filename: &quot;styles/[contenthash].css&quot;, //生成的css位置与css文件名字 &#125;), ], module: &#123; rules: [ &#123; // 加载css或者scss文件 test: /\\.(css|scss)$/, use: [ MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &#123; loader: &quot;sass-loader&quot;, options: &#123; implementation: require(&quot;dart-sass&quot;), &#125;, &#125;, ], //顺序不能改，，从数组后往前进行加载 &#125;, ], &#125;, optimization: &#123; minimizer: [new CssMinimizerPlugin()], //压缩css &#125;, &#125;; 压缩 js需要生产环境 const terserPlugin = require(&quot;terser-webpack-plugin&quot;); //压缩js module.exports = &#123; // 我们发现在使用了css压缩后，js不能进行自动压缩了，所以需要自己配置 optimization: &#123; minimizer: [ new terserPlugin(), //压缩js ], &#125;, &#125;; 解析 tsmodule: &#123; rules: [ &#123; test: /\\.ts$/, use: &quot;ts-loader&quot;, &#125;, ]; &#125; shimming 预置全局变量const webpack = require(&quot;webpack&quot;); module.exports = &#123; plugins: [ new webpack.ProvidePlugin(&#123; _: &quot;lodash&quot;, &#125;), ], &#125;; 使用： console.log(_.join([1, 2, 3], &quot;~&quot;)); 将 this 指向为 windowmodule: &#123; rules: [ &#123; test: /\\.js$/, use: &quot;imports-loader?wrapper=window&quot;, &#125;, ]; &#125; 自建小轮子之 library因为 webpack 打包后的文件都是一个自执行函数，在库外部的任何位置都访问不到它，所以需要配置 library module.exports = &#123; // 如果library的type为module时，必须配置 experiments: &#123; outputModule: true, &#125;, output: &#123; library: &#123; // type: &quot;umd&quot; type: &quot;module&quot;, &#125;, globalObject: &quot;globalThis&quot;, //解决在type: &quot;umd&quot;时，self未定义的问题 &#125;, &#125;;","tags":["webpack"],"categories":["前端进阶"]},{"title":"sass基础知识","path":"/2024/03/15/60/","content":"sass中的变量$color: var(--color, red); .box&#123; color: $color; &#125; 数据类型 数字，1rem、2vh、13、 10px； 字符串，分有引号字符串与无引号字符串，&quot;foo&quot;、 &#39;bar&#39;、baz； 颜色，blue, #04a3f9, rgba(255,0,0,0.5)； 布尔型，true和false； 空值，null是其类型的唯一值。表示缺少值，通常由函数返回以表示缺少结果； 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em,Helvetica,Arial,sans-serif； maps， 相当于 JavaScript的 object，(key1: value1, key2: value2)； 三元运算符if.test&#123; z-index: if(false, 1, 2); &#125; @if与@else$select: false; .box&#123; @if $select&#123; color: red; &#125; @else&#123; color: blue; &#125; &#125; @while$value: 5; @while $value &gt; 0&#123; .number#&#123;$value&#125;&#123; z-index: $value; &#125; $value: $value - 1; &#125; @for@for $i from 1 to 4&#123; .title#&#123;$i&#125;&#123; height: 100px * $i; &#125; &#125; @each$sizes: 40px 60px 80px; @each $size in $sizes &#123; .icon-#&#123;$size&#125; &#123; font-size: $size; height: $size; width: $size; &#125; &#125; 编译后 .icon-40px &#123; font-size: 40px; height: 40px; width: 40px; &#125; .icon-60px &#123; font-size: 60px; height: 60px; width: 60px; &#125; .icon-80px &#123; font-size: 80px; height: 80px; width: 80px; &#125; @function@function qiuHe($number1, $number2)&#123; @return $number1 + $number2; &#125; .test&#123; width: qiuHe(210, 200)+&#x27;px&#x27;; &#125; @mixin@mixin theme($color: black)&#123; background-color: $color; color: $color; &#125; body&#123; @include theme(red); &#125; // 编译结果 /* body &#123; background-color: red; color: red; &#125; */ @extend.box1&#123; width: 100px; height: 100px; &#125; .box2&#123; @extend .box1; color: red; &#125; // 编译结果 /* .box1, .box2 &#123; width: 100px; height: 100px; &#125; .box2 &#123; color: red; &#125; */ 父选择器&amp;.container &#123; a &#123; color: #333; &amp;:hover &#123; text-decoration: underline; color: #f00; &#125; &#125; &#125; 编译后 .container a &#123; color:#333; &#125; .container a:hover &#123; text-decoration:underline; color:#F00; &#125; !default$content: &quot;First content&quot;; // 如果$content之前没定义就使用如下的默认值 $content: &quot;Second content&quot; !default; #main &#123; content: $content; &#125; 编译后 #main &#123; content: &quot;First content&quot;; &#125; @at-root跳出嵌套，在多级嵌套时比较常用 .box&#123; width: 100px; height: 100px; @at-root&#123; .contanter&#123; color: aquamarine; &#125; .title&#123; font-size: 20px; @at-root .red&#123; color: red; background-color: red; &#125; &#125; &#125; &#125; 编译后 .box &#123; width: 100px; height: 100px; &#125; .contanter &#123; color: aquamarine; &#125; .title &#123; font-size: 20px; &#125; .red &#123; color: red; background-color: red; &#125; @use 多处导入，存在样式重复加载。 因为没有命名空间，为了避免撞名，不敢使用简写的 classname，因此起名总是需要注意。 没有私有函数的概念，样式完全暴露在使用import的地方，这对ui库不够友好。 假如我现在有一个入口scss文件，然后还有一个common文件夹，里面有3个文件 common/_1.scss $color1: red; .box1&#123; background-color: $color1; &#125; common/_2.scss $color2: yellow; .box2&#123; background-color: $color2; &#125; common/_index.scss @use &#x27;./1.scss&#x27; as a; @use &#x27;./2.scss&#x27; as b; body&#123; background-color: a.$color1; color: b.$color2; &#125; 入口文件 @use &#x27;./common/index&#x27; as all; .test&#123; width: 100px; &#125; 编译后的结果 .box1 &#123; background-color: red; &#125; .box2 &#123; background-color: yellow; &#125; body &#123; background-color: red; color: yellow; &#125; .test &#123; width: 100px; &#125; @forward@forward语句可以引入另一个模块的所有变量、mixins和函数，将它们直接作为当前模块的API暴露出去，不会真的在当前模块增加代码。不同于 @use， @forward不能给变量添加命名空间。 common/_1.scss $color1: red; .box1&#123; background-color: $color1; &#125; common/_2.scss $color2: yellow; .box2&#123; background-color: $color2; &#125; common/_index.scss @forward &#x27;./1&#x27;; @forward &#x27;./2&#x27;; body&#123; color: blue; &#125; 入口文件 @use &#x27;./common/forword&#x27; as all; .test&#123; color: all.$color2; &#125; 编译后 .box1 &#123; background-color: red; &#125; .box2 &#123; background-color: yellow; &#125; body &#123; color: blue; &#125; .test &#123; color: yellow; &#125; 内置函数1. colorscss包含很多操作颜色的函数。例如lighten()与 darken()可用于调亮或调暗颜色，opacify()使颜色透明度减少，transparent()使颜色透明度增加，mix()用来混合两种颜色。 .p1 &#123; // 让颜色变亮 color:scale-color(#5c7a29, $lightness: +30%); &#125; .p2 &#123; // 让颜色变暗 color:scale-color(#5c7a29, $lightness: -15%); &#125; .p3 &#123; // 降低颜色透明度 color:scale-color(#5c7a29, $alpha: -40%); &#125; 2. List$panding: 10px 20px 30px; .box&#123; padding: append($panding, 100px);//追加 z-index: index($panding, 20px);//返回索引 padding: join(10px 20px, 30px 40px);//合并 z-index: length($panding);//返回长度 width: nth($list: $panding, $n: 3);//返回值 padding: set-nth($list: $panding, $n: 2, $value: 2em); &#125; 3. map@use &quot;sass:map&quot;; $map1: (width: 90%, height: 100%, color: #fff); $map2: (border: 1px solid red, backgroud-color: #000); $map3: map.merge($map1, $map2); //合并 $map4: map.remove($map: $map1, $key:width); //删除 $map5: map.set($map1, &quot;width&quot;, 20%); //设置 .box&#123; width: map.get($map:$map1 , $key:width ); //获取 content: map.has-key($map: $map1, $key:color ); //是否存在 content: map.keys($map: $map3); //获取所有键 content: map.keys($map: $map4); content: map.values($map5); &#125; 4. math@use &#x27;sass:math&#x27;; .test&#123; z-index: math.$pi; z-index: math.ceil($number: 4.2);//向上取整 z-index: math.floor($number: 4.2);//向下取整 width: math.max(10px, 8px, 20px);//返回最大值 width: math.min(10px, 8px, 20px);//返回最小值 z-index: math.round($number: 4.4);//四舍五入 z-index: math.abs($number: -2);//绝对值 z-index: math.pow(2, 3);//2的3次方 z-index: math.sqrt(100);//平方根 z-index: math.random();//随机数 &#125; 5. string@use &#x27;sass:string&#x27;; $str: &#x27;abcdFG&#x27;; .test::after&#123; content: string.quote(helloWorld);//转为字符串 z-index: string.index($str, &#x27;c&#x27;);//返回对应的索引 z-index: string.length($str);//返回字符串长度 content: string.slice($str, 2, 3);//截取字符串 content: string.to-upper-case($str);//转为大写 content: string.to-lower-case($str);//转为小写 content: string.unique-id();//随机生成的不带引号的字符串 &#125;","tags":["sass"],"categories":["前端进阶"]},{"title":"js设计模式","path":"/2024/03/10/59/","content":"工厂模式&lt;!-- 工厂模式：根据不同的输入返回不同类的实例，一般用来创建同一类对象。 --&gt; // 饭店方法 function restaurant(menu) &#123; switch (menu) &#123; case &#x27;鱼香肉丝&#x27;: return new YuXiangRouSi(); case &#x27;宫保鸡丁&#x27;: return new GongBaoJiDin(); default: throw new Error(&#x27;这个菜本店没有&#x27;); &#125; &#125;; // 鱼香肉丝类 function YuXiangRouSi() &#123; this.type = &#x27;鱼香肉丝&#x27; &#125;; YuXiangRouSi.prototype.eat = function () &#123; console.log(this.type + &#x27; 真香&#x27;); &#125;; // 宫保鸡丁类 function GongBaoJiDin() &#123; this.type = &#x27;宫保鸡丁&#x27; &#125;; GongBaoJiDin.prototype.eat = function () &#123; console.log(this.type + &#x27; 让我想起了外婆做的菜~&#x27;); &#125;; const dish1 = restaurant(&#x27;鱼香肉丝&#x27;); dish1.eat(); // 鱼香肉丝 真香 const dish2 = restaurant(&#x27;红烧排骨&#x27;); // Error 这个菜本店没有 建造者模式// 建造者，汽车部件厂家，提供具体零部件的生产 class CarBuilder &#123; constructor(&#123; color = &#x27;white&#x27;, weight = 0 &#125;) &#123; this.color = color; this.weight = weight; &#125; // 生产部件，轮胎 buildTyre(type) &#123; const tyre = &#123;&#125; switch (type) &#123; case &#x27;small&#x27;: tyre.tyreType = &#x27;小号轮胎&#x27; tyre.tyreIntro = &#x27;正在使用小号轮胎&#x27; break case &#x27;normal&#x27;: tyre.tyreType = &#x27;中号轮胎&#x27; tyre.tyreIntro = &#x27;正在使用中号轮胎&#x27; break case &#x27;big&#x27;: tyre.tyreType = &#x27;大号轮胎&#x27; tyre.tyreIntro = &#x27;正在使用大号轮胎&#x27; break &#125; this.tyre = tyre; &#125; // 生产部件，发动机 buildEngine(type) &#123; const engine = &#123;&#125; switch (type) &#123; case &#x27;small&#x27;: engine.engineType = &#x27;小马力发动机&#x27; engine.engineIntro = &#x27;正在使用小马力发动机&#x27; break case &#x27;normal&#x27;: engine.engineType = &#x27;中马力发动机&#x27; engine.engineIntro = &#x27;正在使用中马力发动机&#x27; break case &#x27;big&#x27;: engine.engineType = &#x27;大马力发动机&#x27; engine.engineIntro = &#x27;正在使用大马力发动机&#x27; break &#125; this.engine = engine &#125; &#125;; // 指挥者，负责最终汽车产品的装配 class BenChiDirector &#123; constructor(tyre, engine, param) &#123; const car = new CarBuilder(param); car.buildTyre(tyre); car.buildEngine(engine); return car; &#125; &#125;; // 获得产品实例 const benchi = new BenChiDirector(&#x27;small&#x27;, &#x27;big&#x27;, &#123; color: &#x27;red&#x27;, weight: &#x27;1600kg&#x27; &#125;); 发布订阅模式// 发布、订阅中心 class PubSub&#123; #list = [] // 订阅 subscribe(sub)&#123; this.#list.push(sub) &#125; // 发布 publish()&#123; this.#list.forEach(item=&gt;&#123; item.update() &#125;) &#125; // 退订 unsubscribe(sub)&#123; this.#list = this.#list.filter(item=&gt;item!==sub) &#125; &#125; // 订阅者 class Subscriber&#123; constructor(name)&#123; this.name = name &#125; // 主要逻辑 update()&#123; console.log(this.name) &#125; &#125; // const pubsub = new PubSub() let subscriber1 = new Subscriber(&#x27;xiaoming&#x27;) let subscriber2 = new Subscriber(&#x27;tiechui&#x27;) // 开始订阅 pubsub.subscribe(subscriber1) pubsub.subscribe(subscriber2) // 退订 // pubsub.unsubscribe(subscriber1) // 当符合情况时，进行发布 pubsub.publish() 单例模式class Single&#123; constructor(name, age)&#123; if(!Single.instance)&#123; this.name = name; this.age = age; Single.instance = this; &#125; return Single.instance; &#125; &#125; let a = new Single(&quot;tom&quot;, 18); let b = new Single(&quot;tiechui&quot;, 28); console.log(a) // Single &#123;name: &#x27;tom&#x27;, age: 18&#125; console.log(b) // Single &#123;name: &#x27;tom&#x27;, age: 18&#125; 适配器模式// 将一个类(对象)的接口(方法、属性)转化为用户需要的另一个接口。解决类(对象)之间接口不兼容的问题 class TencentMap&#123; show()&#123; console.log(&#x27;开始渲染腾讯地图&#x27;); &#125; &#125; class BaiduMap&#123; display()&#123; console.log(&#x27;开始渲染百度地图&#x27;); &#125; &#125; // 百度的适配器 class BaiduAdapator extends BaiduMap&#123; constructor()&#123; super(); &#125; show()&#123; this.display() &#125; &#125; // 只支持腾讯地图，所以要给百度写一个适配器 function renderMap(map)&#123; map.show(); &#125; renderMap(new TencentMap()); renderMap(new BaiduAdapator()); 装饰器模式 // 前置函数 Function.prototype.before = function (fn) &#123; var _this = this; return function () &#123; // 先进行前置函数的调用 fn.apply(this, arguments); // 再调用原函数 return _this.apply(_this, arguments); &#125; &#125; // 后置函数 Function.prototype.after = function (fn) &#123; var _this = this; return function () &#123; // 先调用原函数 var result = _this.apply(_this, arguments); // 再进行后置函数的调用 fn.apply(this, arguments); return result; &#125; &#125; function test(params) &#123; console.log(params); &#125; var test1 = test.before(function (params) &#123; console.log(&#x27;前置函数&#x27;); params.token = &#x27;ajsbasczxc&#x27;; &#125;); var test2 = test.after(function (params) &#123; console.log(&#x27;后置函数&#x27;); params.date = new Date() &#125;); test1(&#123; name: &#x27;zhe&#x27; &#125;) /* 前置函数 index.html:32 &#123;name: &#x27;zhe&#x27;, token: &#x27;ajsbasczxc&#x27;&#125; */ test2(&#123; name: &#x27;zhe&#x27; &#125;) /* &#123;name: &#x27;zhe&#x27;&#125; index.html:39 后置函数 */","tags":["js"],"categories":["前端3大件"]},{"title":"vue3基础知识3","path":"/2024/03/02/58/","content":"slot插槽1. 基本插槽组件： &lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 使用者： &lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;/div&gt; &lt;/template&gt; 2. 具名插槽组件： &lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot name=&quot;content&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 使用者： &lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot; v-slot:content&gt; &lt;ul&gt; &lt;li v-for=&quot;item in games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;Compo1 title=&quot;美食中国&quot; #content&gt; &lt;img :src=&quot;imgUrl&quot; alt=&quot;&quot;&gt; &lt;/Compo1&gt; &lt;/div&gt; &lt;/template&gt; 3. 作用域插槽组件： &lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;slot name=&quot;content&quot; :games=&quot;games&quot; :imgUrl=&quot;imgUrl&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 使用者： &lt;template&gt; &lt;div&gt; &lt;Compo1 title=&quot;游戏列表&quot; v-slot:content = &#x27;params&#x27;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in params.games&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Compo1&gt; &lt;Compo1 title=&quot;美食中国&quot; #content = &#x27;params&#x27;&gt; &lt;img :src=&quot;params.imgUrl&quot; alt=&quot;&quot;&gt; &lt;/Compo1&gt; &lt;/div&gt; &lt;/template&gt; 自定义指令1. 局部注册&lt;template&gt; &lt;div&gt; &lt;input v-focus type=&quot;text&quot;&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; const vFocus = &#123; mounted: (el) =&gt; &#123; el.style.height = &#x27;25px&#x27; el.focus() &#125; &#125; &lt;/script&gt; 2. 全局注册可以自定义一个文件夹directives，将所有指令的逻辑都放在这里 比如我新建一个vFocus.ts文件 const vFocus = &#123; mounted: (el) =&gt; &#123; el.style.height = &#x27;25px&#x27; el.style.border = &#x27;1px dashed black&#x27; el.focus() &#125; &#125; export default vFocus main.js // 引入自定义指令 import vFocus from &#x27;@/directives/vFocus&#x27; import &#123; createApp &#125; from &#x27;vue&#x27; import App from &#x27;./App.vue&#x27; const app = createApp(App); //注册自定义指令 app.directive(&#x27;focus&#x27;, vFocus) app.mount(&#x27;#app&#x27;); shallowRef与shallowReactiveref()与reactive()的浅层作用形式，也就是说只对浅层的数据具有响应式 const state = shallowRef(&#123; count: 1 &#125;) // 不会触发更改 state.value.count = 2 // 会触发更改 state.value = &#123; count: 2 &#125; const state = shallowReactive(&#123; foo: 1, nested: &#123; bar: 2 &#125; &#125;) // 更改状态自身的属性是响应式的 state.foo++ // ...但下层嵌套对象不会被转为响应式 isReactive(state.nested) // false // 不是响应式的 state.nested.bar++ readonly()与shallowReadonly()readonly()只读代理是深层的：对任何嵌套属性的访问都将是只读的。 const original = reactive(&#123; count: 0 &#125;) const copy = readonly(original) watchEffect(() =&gt; &#123; // 用来做响应性追踪 console.log(copy.count) &#125;) // 更改源属性会触发其依赖的侦听器 original.count++ // 更改该只读副本将会失败，并会得到一个警告 copy.count++ // warning! 和 readonly() 不同，这里没有深层级的转换：只有根层级的属性变为了只读。 const state = shallowReadonly(&#123; foo: 1, nested: &#123; bar: 2 &#125; &#125;) // 更改状态自身的属性会失败 state.foo++ // ...但可以更改下层嵌套对象 isReadonly(state.nested) // false // 这是可以通过的 state.nested.bar++ toRaw()toRaw() 可以返回由 reactive()、readonly()、shallowReactive() 或者 shallowReadonly() 创建的代理对应的原始对象。 const foo = &#123;&#125; const reactiveFoo = reactive(foo) console.log(toRaw(reactiveFoo) === foo) // true markRaw()markRaw 将一个对象标记为不可被转为代理。返回该对象本身。(只对reactive生效) const foo = markRaw(&#123;&#125;) console.log(isReactive(reactive(foo))) // false // 也适用于嵌套在其他响应性对象 const bar = reactive(&#123; foo &#125;) console.log(isReactive(bar.foo)) // false customRef()创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。 创建一个hooks： import &#123; customRef &#125; from &#x27;vue&#x27; export default function (inputInit, delay) &#123; const input = customRef((track, trigger) =&gt; &#123; let timer return &#123; get() &#123; track() //告诉vue数据inputInit很重要，你要对其进行持续关注，一旦其数据变化就去更新 return inputInit &#125;, set(value) &#123; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; inputInit = value trigger() // 通知vue数据变化了 &#125;, delay) &#125; &#125; &#125;) return &#123; input &#125; &#125; 使用者： &lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;input&quot;&gt; &lt;div&gt;&#123;&#123; input &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import useCustomRef from &#x27;./hooks/useCustomRef&#x27;; let &#123;input&#125; = useCustomRef(&#x27;666&#x27;, 2000) &lt;/script&gt; Teleport&lt;Teleport&gt; 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。 &lt;button @click=&quot;open = true&quot;&gt;Open Modal&lt;/button&gt; &lt;Teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;open&quot; class=&quot;modal&quot;&gt; &lt;p&gt;Hello from the modal!&lt;/p&gt; &lt;button @click=&quot;open = false&quot;&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/Teleport&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"vue3基础知识2","path":"/2024/02/24/57/","content":"编程式路由导航import &#123; useRouter &#125; from &#x27;vue-router&#x27; const router = useRouter() function handleClick(item: any) &#123; router.push(&#123; path: &#x27;/news/details&#x27;, query: &#123; id: item.id, title: item.title &#125;, &#125;) &#125; pinia存储与读取数据存储： import &#123; defineStore &#125; from &quot;pinia&quot; export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;, &#x27;213&#x27;] &#125; &#125; &#125;) 读取： import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27; const tagsStore = useTagsStore() const dynamicTags = tagsStore.dynamicTags pinia修改数据的2种方式第一种直接修改： tagsStore.dynamicTags.splice(tagsStore.dynamicTags.indexOf(tag),1) 第二种（actions） import &#123; defineStore &#125; from &quot;pinia&quot; export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;] &#125; &#125;, actions: &#123; changeTags(index)&#123; this.dynamicTags.splice(index,1) &#125; &#125; &#125;) tagsStore.changeTags(tagsStore.dynamicTags.indexOf(tag)) getters与storeToRefsgetters类似于计算属性，在store中的写法： import &#123; defineStore &#125; from &quot;pinia&quot; export const useTagsStore = defineStore(&#x27;tags&#x27;,&#123; state: ()=&gt;&#123; return &#123; dynamicTags : [&#x27;Tag 1&#x27;, &#x27;Tag 2&#x27;, &#x27;Tag 3&#x27;], &#125; &#125;, actions: &#123; changeTags(index)&#123; this.dynamicTags.splice(index,1) &#125; &#125;, getters: &#123; countTags()&#123; return this.dynamicTags.length + &#x27;&#x27; &#125; &#125; &#125;) storeToRefs的使用： import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27; import &#123; storeToRefs &#125; from &#x27;pinia&#x27; const tagsStore = useTagsStore() // 这种方式不可取，因为他会把tagsStore中所有的东西都变成ref // let &#123; dynamicTags, countTags &#125; = toRefs(tagsStore) // 推荐这种 let &#123; dynamicTags, countTags &#125; = storeToRefs(tagsStore) pinia中的$subscribe$subscribe可以监听数据的更改： import &#123; useTagsStore &#125; from &#x27;@/store/tags&#x27; const tagsStore = useTagsStore() tagsStore.$subscribe(()=&gt;&#123; console.log(&quot;tagsStore数据发生改变&quot;) &#125;) 组件通信的方式1. props父： &lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; 我的好朋友是&#123;&#123; a &#125;&#125; &lt;/div&gt; &lt;Compo1 :name1 = &#x27;name&#x27; :getName = &quot;handleName&quot;&gt;&lt;/Compo1&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import &#123;ref&#125; from &#x27;vue&#x27; import Compo1 from &#x27;@/components/Compo1.vue&#x27; const name = ref(&quot;索隆&quot;) let a = ref(&#x27;&#x27;) function handleName(data)&#123; a.value = data.value &#125; &lt;/script&gt; 子： &lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; 我的好朋友&#123;&#123; name1 &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import &#123;ref&#125; from &#x27;vue&#x27; const name = ref(&quot;路飞&quot;) let props = defineProps([&#x27;name1&#x27;,&#x27;getName&#x27;]) props.getName(name) &lt;/script&gt; 2. $refs+$parent父： &lt;template&gt; &lt;div&gt; &lt;Compo1 ref=&quot;a&quot;&gt;&lt;/Compo1&gt; &lt;Compo2 ref=&quot;b&quot;&gt;&lt;/Compo2&gt; &lt;/div&gt; &lt;button @click=&quot;handleClick($refs)&quot;&gt;点击&lt;/button&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import Compo1 from &#x27;@/components/Compo1.vue&#x27; import Compo2 from &#x27;@/components/Compo2.vue&#x27; import &#123;ref, onMounted&#125; from &#x27;vue&#x27; const a = ref() const b = ref() let x = ref(2) let y = ref(10) function handleClick(refs)&#123; console.log(refs.a.title) &#125; onMounted(()=&gt;&#123; console.log(a.value.title) &#125;) defineExpose(&#123;x,y&#125;) &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 子： &lt;template&gt; &lt;h2&gt; 子组件1 &lt;/h2&gt; &lt;div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;handClick($parent)&quot;&gt;获取父组件信息&lt;/button&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import &#123;ref&#125; from &#x27;vue&#x27; let title = ref(&quot;哈哈哈哈&quot;) let ppp = ref(2) function handClick(parent)&#123; console.log(parent.y) &#125; defineExpose(&#123;title, ppp&#125;) &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 3. $attrs父： &lt;template&gt; &lt;div&gt; &lt;Compo2 a=&quot;111&quot; b=&quot;222&quot;&gt;&lt;/Compo2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import Compo2 from &#x27;@/components/Compo2.vue&#x27; &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 子： &lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &#123;&#123; $attrs &#125;&#125; // &#123; &quot;a&quot;: &quot;111&quot;, &quot;b&quot;: &quot;222&quot; &#125; &lt;/div&gt; &lt;Compo1 v-bind=&quot;$attrs&quot;&gt;&lt;/Compo1&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import &#123; ref &#125; from &#x27;vue&#x27; import Compo1 from &#x27;./Compo1.vue&#x27;; const name = ref(&quot;索隆&quot;) &lt;/script&gt; 4. defineEmits自定义事件父： &lt;template&gt; &lt;div&gt; &lt;Compo2 @custom-event=&quot;send&quot;&gt;&lt;/Compo2&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import Compo2 from &#x27;@/components/Compo2.vue&#x27; import &#123;ref&#125; from &#x27;vue&#x27; let name = ref(&#x27;????&#x27;) function send(data)&#123; // console.log(data) name.value = data &#125; &lt;/script&gt; 子： &lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;emit(&#x27;custom-event&#x27;, name)&quot;&gt;发送&lt;/button&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import &#123;ref&#125; from &#x27;vue&#x27; const name = ref(&quot;索隆&quot;) // 自定义事件 const emit = defineEmits([&#x27;custom-event&#x27;]) &lt;/script&gt; 5. mitt事件总线安装mitt： npm install --save mitt 在文件夹utils中新建文件emitter.ts import mitt from &#x27;mitt&#x27; const emitter = mitt() export default emitter 父： &lt;template&gt; &lt;div&gt; &lt;Compo2&gt;&lt;/Compo2&gt; &lt;/div&gt; &lt;span&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import Compo2 from &#x27;@/components/Compo2.vue&#x27; import emitter from &#x27;@/utils/emitter&#x27; import &#123; ref &#125; from &#x27;vue&#x27; let name = ref(&#x27;???&#x27;) emitter.on(&#x27;send&#x27;, (data: any) =&gt; &#123; // console.log(data.value) name.value = data.value &#125;) &lt;/script&gt; 子： &lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;send&quot;&gt;发送&lt;/button&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import &#123; ref &#125; from &#x27;vue&#x27; import emitter from &#x27;@/utils/emitter&#x27; const name = ref(&quot;索隆&quot;) function send() &#123; emitter.emit(&#x27;send&#x27;, name) &#125; &lt;/script&gt; 6. provide+inject父： &lt;template&gt; &lt;div&gt; &lt;Compo1&gt;&lt;/Compo1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import Compo1 from &#x27;@/components/Compo1.vue&#x27; import &#123;ref,provide&#125; from &#x27;vue&#x27; let x = ref(2) let y = ref(10) // 向后代提供数据 provide(&#x27;x&#x27;,x) provide(&#x27;y&#x27;,y) &lt;/script&gt; 子： &lt;template&gt; &lt;h2&gt; 子组件1 &lt;/h2&gt; &lt;div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import &#123;ref,inject&#125; from &#x27;vue&#x27; let title = ref(&quot;哈哈哈哈&quot;) let m = ref(1) // 接收数据 let x = inject(&#x27;x&#x27;,m) let y = inject(&#x27;y&#x27;,m) console.log(x.value,y.value) &lt;/script&gt; 7. v-model我们都知道在input标签上使用v-model，那么如果要想用在组件上，该怎么做呢？ 父： &lt;template&gt; &lt;div&gt; &lt;Compo2 v-model=&quot;text&quot;&gt;&lt;/Compo2&gt; &#123;&#123; text &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import Compo2 from &#x27;@/components/Compo2.vue&#x27; import &#123; ref &#125; from &#x27;vue&#x27; let text = ref(&#x27;asd&#x27;) &lt;/script&gt; 子： &lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;!-- 传统写法 --&gt; &lt;!-- &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emit(&#x27;update:modelValue&#x27;, (&lt;HTMLInputElement&gt;$event.target).value)&quot;&gt; --&gt; &lt;!-- 新型写法 --&gt; &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;change&quot;&gt; &lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt; import &#123; ref &#125; from &#x27;vue&#x27; const name = ref(&quot;索隆&quot;) // 传统写法 // defineProps([&#x27;modelValue&#x27;]) // const emit = defineEmits([&#x27;update:modelValue&#x27;]) // 3.4+推荐写法 const model = defineModel() function change(e)&#123; model.value = e.target.value &#125; &lt;/script&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"vue3基础知识1","path":"/2024/02/23/56/","content":"toRef与toRefs使用它，消费者组件可以解构&#x2F;展开返回的对象而不会失去响应性： import &#123; reactive,toRefs,toRef &#125; from &#x27;vue&#x27; const person = reactive(&#123; name: &#x27;张三&#x27;, age: 18 &#125;) const cityObj = reactive(&#123; name: &#x27;北京&#x27;, id: &#x27;asdasxzc&#x27; &#125;) // 消费者组件可以解构/展开返回的对象而不会失去响应性 let &#123; name, age &#125; = toRefs(person) let city = toRef(cityObj,&#x27;name&#x27;) computed()函数创建一个只读的计算属性 ref： const count = ref(1) const plusOne = computed(() =&gt; count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // 错误 创建一个可写的计算属性 ref： const count = ref(1) const plusOne = computed(&#123; get: () =&gt; count.value + 1, set: (val) =&gt; &#123; count.value = val - 1 &#125; &#125;) plusOne.value = 1 console.log(count.value) // 0 watch()函数用于声明在数据更改时调用的侦听回调。 **immediate**：在侦听器创建时立即触发回调。第一次调用时，旧值将为 undefined。 **deep**：如果源是对象或数组，则强制深度遍历源，以便在深度变更时触发回调。详见深层侦听器。 **flush**：调整回调的刷新时机。详见回调的触发时机及 watchEffect()。 **onTrack / onTrigger**：调试侦听器的依赖关系。详见侦听器调试。 监听ref数据时： let person = ref(&#123; name: &quot;张三&quot;, age: 18 &#125;) // 默认是不会开启深度监听的，如果需要开启深度监听，需要在watch中传入deep参数 // deep: true watch(person, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal) &#125;, &#123; deep: true &#125;) 监听reactive数据时： let person = reactive(&#123; name: &quot;张三&quot;, age: 18 &#125;) // 默认开启深度监听,并且无法修改 watch(person, (newValue, oldValue) =&gt; &#123; console.log(newValue, oldValue) &#125;) ​\t监听响应式对象中的单个属性 const person = reactive(&#123; name: &#x27;张三&#x27;, age: 18, adress: &#123; city: &#x27;北京&#x27;, street: &#x27;北京路&#x27; &#125; &#125;) // 如果要监听某个属性，可以使用getter函数 // 1.如果这个属性值是基本类型，只能写成getter函数 watch(()=&gt;person.name, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal) &#125;) /* 2.如果这个属性值是对象，如果写成getter函数， 那么就是监听的地址的变换，里面单个属性变化监听不到，但是可以开启deep，进行深度监听 如果不写成函数，那么就是监听里面单个属性的变化，无法监听地址的变换 */ watch(()=&gt;person.adress, (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal) &#125;) 监听响应式对象中的单个属性: // 如果要监听多个属性，写成数组即可 watch([()=&gt;person.name, ()=&gt;person.adress], (newVal, oldVal) =&gt; &#123; console.log(newVal, oldVal) &#125;) watchEffect()函数立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。 与watch的区别：watch需要指定数据源进行监听 let height = ref(0) let weight = ref(0) watchEffect(() =&gt; &#123; if(height.value &gt; 5 &amp;&amp; weight.value &gt; 10)&#123; console.log(&quot;发送服务器消息&quot;) &#125; &#125;) ref与dom结构的联动使用选项式 API，引用将被注册在组件的 this.$refs 对象里： &lt;!-- 存储为 this.$refs.p --&gt; &lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt; 使用组合式 API，引用将存储在与名字匹配的 ref 里： &lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; const p = ref() &lt;/script&gt; &lt;template&gt; &lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt; &lt;/template&gt; 用于组件时： // test组件 &lt;template&gt; &lt;h2&gt;我是一个组件&lt;/h2&gt; &lt;/template&gt; &lt;script setup&gt; import &#123; ref &#125; from &#x27;vue&#x27; let a = ref(0) let b = ref(1) let c = ref(2) defineExpose(&#123;a,b,c&#125;) &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped&gt; &lt;/style&gt; &lt;template&gt; &lt;button @click=&quot;getDom&quot;&gt;获取dom&lt;/button&gt; &lt;test ref=&quot;tes&quot;&gt;&lt;/test&gt; &lt;/template&gt; import test from &#x27;./components/test.vue&#x27; let tes = ref(); // 如果想要获取组件里面的变量，需要组件自行导出 function getDom() &#123; console.log(tes.value.a); console.log(tes.value.b); console.log(tes.value.c); &#125; defineProps()// 类型限制+默认值+是否必传 let props = withDefaults(defineProps&lt;&#123;list?:PersonList&#125;&gt;(),&#123; // 默认值 list:()=&gt;[&#123;id:&#x27;asdasdzxc&#x27;,name:&#x27;海尔&#x27;,age:22&#125;] &#125;) 基本路由import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;; import Home from &#x27;@/views/Home.vue&#x27;; import News from &#x27;@/views/News.vue&#x27;; import About from &#x27;@/views/About.vue&#x27;; import NewsDetails from &#x27;@/views/NewsDetails.vue&#x27;; const router = createRouter(&#123; history: createWebHistory(), routes: [ &#123; path: &#x27;/home&#x27;, component: Home, &#125;, &#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details&#x27;, component: NewsDetails, &#125;, ], &#125;, &#123; path: &#x27;/about&#x27;, component: About, &#125;, // 重定向 &#123; path: &#x27;/:pathMatch(.*)*&#x27;, redirect: to =&gt; &#123; return &#123; path: &#x27;/home&#x27; &#125;; &#125;, &#125;, ] &#125;) export default router; query传参当我点击某个按钮，让它跳转到新闻详情页面时：&#x2F;news&#x2F;details?id&#x3D;${item.id}&amp;title&#x3D;${item.title} 如何接收传的值呢？ &lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; route.query.id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; route.query.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import &#123;useRoute&#125; from &quot;vue-router&quot;; const route = useRoute(); &lt;/script&gt; params传参也就是需要这样传参：&#x2F;news&#x2F;details&#x2F;${item.id}&#x2F;${item.title} 此时要怎样接收参数呢？ 改变路由结构： &#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details/:id/:title&#x27;, component: NewsDetails, &#125;, ], &#125;, 接收： &lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; route.params.id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; route.params.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import &#123;useRoute&#125; from &quot;vue-router&quot;; const route = useRoute(); 路由props配置之前所说的query传参和params传参，在接收时感觉比较繁琐，接下来看看路由props配置，告别繁琐 首先改变路由： &#123; path: &#x27;/news&#x27;, component: News, children: [ &#123; path: &#x27;details&#x27;, component: NewsDetails, // 第一种params写法 // props: true, // 第二种query写法 props(route)&#123; return route.query; &#125;, &#125;, ], &#125;, 接收： &lt;template&gt; &lt;div&gt; 新闻详情 &lt;ul&gt; &lt;li&gt;&#123;&#123; id &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; title &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; defineProps([&#x27;id&#x27;, &#x27;title&#x27;]) &lt;/script&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"md文件的解析、渲染与目录文件读取","path":"/2024/02/10/55/","content":"markdown文件内容的读取使用markdown-it的插件 npm install markdown-it import MarkdownIt from &quot;markdown-it&quot; import contentMd from &quot;@/article/1.md?raw&quot; const markdownit = new MarkdownIt() console.log(markdownit.render(contentMd)) markdown的渲染markdown-it只能将markdown文件转换为html标签，但是没有css样式，网上有很多插件对其进行美化，推荐一个网站：Themes Gallery — Typora 目录文件读取const localeResourceFiles = import.meta.glob(&#x27;@/article/*.md&#x27;, &#123; eager: true, import: &#x27;default&#x27; &#125;) console.log(localeResourceFiles)","tags":["vue"],"categories":["前端进阶"]},{"title":"js基础篇4","path":"/2024/02/01/54/","content":"proxy let obj = &#123; name: &#x27;tom&#x27;, &#125; // 使用 proxy 监听 obj 的变化 proxy = new Proxy(obj, &#123; get(target, key) &#123; console.log(`get $&#123;key&#125;`) if (key === &#x27;name&#x27;) &#123; a.innerHTML = target[key] &#125; return target[key] &#125;, set(target, key, value) &#123; console.log(`set $&#123;key&#125; = $&#123;value&#125;`) if (key === &#x27;name&#x27;) &#123; a.innerHTML = value &#125; target[key] = value return true &#125; &#125;) proxy.name // get name Reflect配合proxylet obj = &#123;&#125; let proxy = new Proxy(obj, &#123; get(target, key) &#123; console.log(`get $&#123;Reflect.get(target, key)&#125;`) // return Reflect.get(target, key) return Reflect.get(...arguments) &#125;, set(target, key, value) &#123; console.log(`set $&#123;key&#125; = $&#123;value&#125;`) Reflect.set(...arguments) return true &#125; &#125;) promise相关api一个 Promise 必然处于以下几种状态之一： ​ 1.待定（pending）：初始状态，既没有被兑现，也没有被拒绝。 ​ 2.已兑现（fulfilled）：意味着操作成功完成。 ​ 3.已拒绝（rejected）：意味着操作失败。 ajax函数 function ajax(str, time, isSuccess) &#123; if (isSuccess)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;); &#125;else&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(str); &#125;, time); &#125;); &#125; &#125; Promise.all() 等待所有 Promise, 在任意一个 Promise 被拒绝时拒绝 Promise.all([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) // [&#x27;1&#x27;, &#x27;2&#x27;] Promise.race() 看哪一个 Promise 先被执行完，就执行哪一个 Promise Promise.race([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) // 1 Promise.any() 当输入的任何 promise 实现时，此返回的 promise 将实现，并具有第一个 fulfillation 值。当所有输入的 promise 都拒绝时（包括传递空可迭代对象时），它会拒绝 Promise.any([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err, &#x27;拒绝&#x27;) &#125;) // 2 Promise.allSettled() 无论任何 promise 实现，此返回的 promise 都将实现，并具有一个数组，其中包含每个输入 promise 的状态和值。 Promise.allSettled([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, false)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) /* [&#123;…&#125;, &#123;…&#125;] 0: &#123;status: &#x27;rejected&#x27;, reason: &#x27;1&#x27;&#125; 1: &#123;status: &#x27;rejected&#x27;, reason: &#x27;2&#x27;&#125; */","tags":["js"],"categories":["前端3大件"]},{"title":"MongoDB的安装与使用","path":"/2024/01/10/53/","content":"安装下载官网（社区版）：Download MongoDB Community Server | MongoDB 根据自己的操作系统下载即可 配置环境变量（方便后续的启动）找到系统环境变量的编辑界面 添加自己下载好的mongodb的bin路径即可 最后进行测试，输入mongod，没有报错说明配置成功（这个命令主要用来启动mongodb） 启动mongo服务在启动之前必须配置mongo服务数据存放的文件夹，比如我在mongo安装的目录下，新建了一个db文件夹，用来存放数据库内容：D:\\Database\\MongoDB\\db， 启动方法 mongod --dbpath D:\\Database\\MongoDB\\db 启动后不能关闭终端，不然会中断mongo的服务 node连接mongoDB 这里用express框架进行演示 1. 模块下载npm i mongoose 2. 连接建议放在单独的一个文件中，方便管理 const mongoose = require(&#x27;mongoose&#x27;); const dbURL = &#x27;mongodb://127.0.0.1:27017/managerCool&#x27;; // 连接数据库 mongoose.connect(dbURL); // 绑定数据库连接监听 mongoose.connection.on(&quot;open&quot;, (err) =&gt; &#123; if (err) &#123; cosnole.log(&quot;连接失败...&quot;, err); &#125; else &#123; console.log(&quot;mongodb连接成功&quot;); &#125; &#125;) 在入口文件中进行引入即可 // 连接数据库 require(&#x27;../connect_db/mongo&#x27;) 3. 创建模型（需要连接的表）上述步骤已经成功连接到了具体的数据库了，而大家都知道库中是不是有具体的表，这是mysql的称呼，在mongodb中称为模型，建议将所有的创建模型的文件单独存放到一个文件夹中 比如我要连接introduction的模型 const mongoose = require(&#x27;mongoose&#x27;) const IntroductionType = &#123; title:String, value:String &#125; const IntroductionModel = mongoose.model(&#x27;introduction&#x27;, new mongoose.Schema(IntroductionType)) module.exports = IntroductionModel 查询 比如我要查询introduction中的所有内容 const IntroductionModel = require(&#x27;../model/IntroductionModel&#x27;) router.get(&#x27;/&#x27;, function (req, res, next) &#123; IntroductionModel.find().then(data=&gt;&#123; console.log(data) &#125;) res.send(&#123; ok: 1 &#125;) &#125;); 修改 注意updateOne里面的第二个字段，对应的是new mongoose.Schema(IntroductionType))里面的字段，如果不对应的话是无法修改的哦 router.post(&#x27;/api/change/homeData/:id&#x27;, (req, res)=&gt;&#123; IntroductionModel.updateOne(&#123;_id: req.body._id&#125;,&#123; title: req.body.title, value: req.body.value &#125;).then(result=&gt;&#123; console.log(result) res.send(&#123;ok:1&#125;) &#125;).catch(err=&gt;&#123; console.log(err) res.send(&#123;ok:0&#125;) &#125;) &#125;)","tags":["node"],"categories":["前端进阶"]},{"title":"js基础篇3","path":"/2024/01/02/52/","content":"数组扩展 拆分多维数组flat let arr = [1,2,[3,4,[5,6]]] console.log(arr.flat(2)) // [1, 2, 3, 4, 5, 6] 数组元素修改fill /* fill(value) fill(value, start) fill(value, start, end) */ let arr = [1, 2, 3, 4, 5] console.log(arr.fill(10, 2)) // [1, 2, 10, 10, 10] 只改变数组其中一个元素with let arr = [1, 2, 3, 4, 5] console.log(arr.with(1, 100)) // [1, 100, 3, 4, 5] 对象扩展1. 判断一个对象是否存在特定属性let obj = &#123; name: &#x27;xiaoming&#x27;, age: 18 &#125; // hasOwnProperty console.log(obj.hasOwnProperty(&#x27;name&#x27;)) // in console.log(&#x27;name&#x27; in obj) // Reflect.has() console.log(Reflect.has(obj, &#x27;name&#x27;)) 2. Object.assign() 拼接 let obj1 = &#123; name: &#x27;John&#x27;, age: 30, city: &#x27;New York&#x27; &#125; let obj2 = &#123; age: 25, country: &#x27;USA&#x27; &#125; let obj3 = Object.assign(obj1, obj2) console.log(obj3) // &#123;name: &#x27;John&#x27;, age: 25, city: &#x27;New York&#x27;, country: &#x27;USA&#x27;&#125; 很多人可能会想到这种方式可不可以用来复制一个对象，我告诉你结果：不完全可以，为什么这样说，大家看如下代码： let obj4 = &#123; nameValue: &#x27;xiaoming&#x27;, age: 18, get name() &#123; console.log(&#x27;get name&#x27;) &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125; &#125; let obj5 = &#123;&#125; let obj6 = Object.assign(obj5, obj4) console.log(obj6) // &#123;nameValue: &#x27;xiaoming&#x27;, age: 18, name: undefined&#125; 当这个对象中有get 或者 set 时就不行了 3. getOwnPropertyDescriptors()返回给定对象的所有自有属性描述符 let obj4 = &#123; nameValue: &#x27;xiaoming&#x27;, age: 18, get name() &#123; console.log(&#x27;get name&#x27;) &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125; &#125; let obj7 = Object.getOwnPropertyDescriptors(obj4) obj7.name.get() // get name 4. Object.keys()​ 返回一个由给定对象自身的可枚举的字符串键属性名组成的数组。 let obj1 = &#123; name: &#x27;John&#x27;, age: 30, city: &#x27;New York&#x27; &#125; console.log(Object.keys(obj1)) // [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;] 5. Object.values()​ 返回一个由所有自身属性值的数组，包括不可枚举属性值。 console.log(Object.values(obj1)) // [&#x27;John&#x27;, 30, &#x27;New York&#x27;] 6. Object.entries()​ 返回一个数组，包含给定对象自有的可枚举字符串键属性的键值对。 console.log(Object.entries(obj1)) /* [ [&#x27;name&#x27;, &#x27;John&#x27;] [&#x27;age&#x27;, 30] [&#x27;city&#x27;, &#x27;New York&#x27;] ] */ 7. Object.create​ 以一个现有对象作为原型，创建一个新对象。 let obj1 = &#123; nameValue: &#x27;John&#x27;, age: 30, city: &#123; name: &#x27;New York&#x27;, population: 800000 &#125;, get name() &#123; console.log(&#x27;get name&#x27;) return this.nameValue &#125;, set name(value) &#123; console.log(&#x27;set name&#x27;) &#125; &#125; let obj3 = Object.create( Object.getPrototypeOf(obj1), Object.getOwnPropertyDescriptors(obj1), ); console.log(obj3) // &#123;nameValue: &#x27;John&#x27;, age: 30, city: &#123;…&#125;&#125; console.log(obj3.name) // get name // John 获取css中的变量&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;简单的背景选择&lt;/title&gt; &lt;style&gt; :root&#123; --color: #000; &#125; body&#123; height: 96vh; background-color: var(--color); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;color&quot; id=&quot;color&quot;&gt; &lt;script&gt; // 获取css中变量的值 const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); let colorSelector = document.querySelector(&#x27;#color&#x27;); colorSelector.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; // 通过改变css变量，改变页面背景色 document.documentElement.style.setProperty(&#x27;--color&#x27;, e.target.value); &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; class新增 在属性面前在一个#，就是私有属性 class Person &#123; static a = 1; // 定义私有属性 #privateName = &#x27;tiechui&#x27; constructor(name, age) &#123; this.name = name; this.age = age; this.privateName = this.#privateName &#125; // 定义一个方法 sayHello() &#123; console.log(`Hello, my name is $&#123;this.name&#125;`); &#125; &#125; 静态代码块，当这个类被定义后，代码块会自动执行 class test&#123; static n = 1 static &#123; console.log(&#x27;静态代码块&#x27;, this.n) &#125; &#125; // 静态代码块 1 异步迭代function ajax(str, time) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;); &#125; // 迭代器 async function* foo() &#123; yield ajax(&#x27;a&#x27;,1000); yield ajax(&#x27;b&#x27;,1000); yield ajax(&#x27;c&#x27;,1000); &#125; let str = &#x27;&#x27;; let Foo = foo(); Foo.next().then(res=&gt;&#123; console.log(res); &#125;) // &#123;value: &#x27;a&#x27;, done: false&#125; async function generate() &#123; for await (var val of foo()) &#123; str = str + val; console.log(val); &#125; console.log(str); &#125; generate(); // a // b // c // abc 正则扩展let str = &#x27;今天是2023-12-23&#x27; let reg = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;mounth&gt;\\d&#123;1,2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/ let reg1 = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;mounth&gt;\\d&#123;1,2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/d console.log(reg.exec(str)) // [&#x27;2023-12-23&#x27;, &#x27;2023&#x27;, &#x27;12&#x27;, &#x27;23&#x27;, index: 3, input: &#x27;今天是2023-12-23&#x27;, groups: &#123;…&#125;] console.log(reg1.exec(str)) // [&#x27;2023-12-23&#x27;, &#x27;2023&#x27;, &#x27;12&#x27;, &#x27;23&#x27;, index: 3, input: &#x27;今天是2023-12-23&#x27;, groups: &#123;…&#125;, indices: Array(4)] 字符串扩展 includes函数可以判断字符串中是否含有指定字符串 let str = &quot;helloworld&quot; console.log(str.includes(&quot;h&quot;)) // true startsWith和endsWith方法可以判断字符串是否以指定字符串开头或结尾 let str = &quot;hello&quot; console.log(str.startsWith(&quot;h&quot;)) // true console.log(str.startsWith(&quot;h&quot;, 1)) // false console.log(str.endsWith(&quot;o&quot;)) // true 字符串的repeat方法可以重复字符串 let str = &quot;hello&quot; console.log(str.repeat(3)) // hellohellohello console.log(str.repeat(0)===&#x27;&#x27;) // true 字符串的padStart和padEnd方法可以对字符串进行填充 let str = &quot;hello&quot; console.log(str.padStart(10, &quot;world&quot;)) // worldhello console.log(str.padEnd(10, &quot;world&quot;)) // helloworld at方法（寻找数组内的元素）let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] console.log(arr.at(1)) // 2 console.log(arr.at(-1)) // 10","tags":["js"],"categories":["前端3大件"]},{"title":"js基础篇2","path":"/2023/12/10/51/","content":"获取dom节点尺寸var omw=document.querySelector(&#x27;#box&#x27;) // 获取宽高 console.log(omw.offsetWidth,omw.offsetHeight) // 获取宽高（不计算边框） console.log(omw.clientWidth,omw.clientHeight) 获取dom节点偏移量var a=document.querySelector(&#x27;.box&#x27;) // 获取节点相对于父节点的偏移量（要求父节点要设置position），否则根据整个页面进行计算 console.log(a.offsetLeft,a.offsetTop) 获取可视窗口尺寸// 包括滚动条 console.log(innerWidth,innerHeight) // 不包括滚动条 console.log(window.document.documentElement.clientWidth,document.documentElement.clientHeight) 基本事件类型 单击：click 双击：dblclick 右键：contextmenu 鼠标按下：mousedown 鼠标抬起：mouseup 鼠标移动：mousemove 移入（包括子节点）：mouseover 移入（不包括子节点）：mouseenter 移出（包括子节点）：mouseout 移出（不包括子节点）：mouseleave 键盘按下：keydown 键盘抬起：keyup 得到焦点：focus 失去焦点：blur 内容改变：input 前后内容不一致：change 重置：reset 提交：submit 触摸开始：touchstart 触摸结束：touchend 触摸移动：touchmove 常用鼠标事件对象（event）box.onclick = function (evt) &#123; //距离可视窗口的位置 console.log(evt.clientX, evt.clientY) //距离整个页面的位置，不受滚动条影响 console.log(evt.pageX, evt.pageY) //距离自己左上角的位置 console.log(evt.offsetX, evt.offsetY) &#125; 阻止事件传播ob.onclick=function(evt)&#123; evt.stopPropagation() //阻止这个按钮事件往下传播 &#125; 阻止默认行为// dom0的方式 // document.oncontextmenu=function()&#123; // console.log(&quot;自定义右键菜单&quot;) // return false // &#125; //dom2的方式 document.addEventListener(&#x27;contextmenu&#x27;,function(evt)&#123; console.log(&quot;自定义右键菜单&quot;) evt.preventDefault() &#125;) 正则表达式 基本元字符 \\d 数字 \\D 非数字 \\s 空白（空格、缩进、换行） \\S 非空白 \\w 字母、数字或下划线 \\W 非字母、数字或下划线 . 任意内容 \\ 转义字符 边界符 ^ 开头 $ 结尾 限定符 * 0~多次 + 1~多次 ? 0~1 {n} 限定n次,必须连续 {n,} &gt;&#x3D;n {n,m} n~m 特殊符号 ( ) 作为整体 | 或(两边默认为整体) [] 表示里面只要有一个就行 [^abc]表示取反，不是abc其中一个 正则两大特新 懒惰性，解决：使用全局标识符g 贪婪 可以加个？，变成非贪婪 var reg1=/\\d&#123;1,4&#125;/ //贪婪 var reg2=/\\d&#123;1,4&#125;?/ //非贪婪 console.log(reg1.exec(&#x27;ab1234d&#x27;)[0]) // 1234 console.log(reg2.exec(&#x27;ab1234d&#x27;)[0]) // 1 this指向问题 call apply bind call 与 apply都会自动执行函数，区别：传入参数的形式不同 bind不会自动执行函数 obj1=&#123; name:&#x27;obj1&#x27;, getName:function(a,b,c)&#123; console.log(&#x27;getName1&#x27;,this.name) console.log(&#x27;参数&#x27;,a,b,c) &#125; &#125; obj2=&#123; name:&#x27;obj2&#x27;, getName:function()&#123; console.log(&#x27;getName2&#x27;,this.name) &#125; &#125; obj1.getName.call(obj2,1,2,3) // getName1 obj2 // 参数 1 2 3 obj1.getName.apply(obj2,[1,2,3]) // getName1 obj2 // 参数 1 2 3 var fun= obj1.getName.bind(obj2,1,2,3) fun() // getName1 obj2 // 参数 1 2 3 继承 1 function Person(name,age)&#123; this.myname=name this.myage=age &#125; Person.prototype.mysay=function()&#123; console.log(&#x27;hello&#x27;,this.myname) &#125; function Student(name,age,grade)&#123; // 继承 Person.apply(this,[name,age]) this.grade=grade &#125; // 原型的继承 Student.prototype=new Person() let stu=new Student(&#x27;pig&#x27;,14,100) console.log(stu) // &#123;myname: &#x27;pig&#x27;, myage: 14, grade: 100&#125; stu.mysay() // hello pig 2 class Person&#123; constructor(name, age)&#123; this.myname = name this.age = age &#125; mysay()&#123; console.log(&#x27;hello&#x27;,this.myname) &#125; &#125; class Student extends Person&#123; constructor(name, age, grade)&#123; super(name, age) this.grade = grade &#125; &#125; let stu = new Student(&#x27;xz&#x27;,18,99) console.log(stu) // &#123;myname: &#x27;xz&#x27;, age: 18, grade: 99&#125; stu.mysay() // hello xz 数学方法 var num=124.2361234 // 指定保留几位小数,能够四舍五入 console.log(num.toFixed(3)) // 124.236 Math.random() 随机数 Math.round() 四舍五入 Math.ceil() 向上取整 Math.floor() 向下取整 Math.abs() 绝对值 Math.sqrt() 平方根 Math.pow(2,4) 2的4次方 &#x3D; 16 Math.max(10,11,20,1,2,4) 取最大 Math.min(10,11,20,1,2,4) 取最小 Math.PI","tags":["js"],"categories":["前端3大件"]},{"title":"处理yaml文件","path":"/2023/11/27/50/","content":"第一种方法这个很简单直接以import的形式引入，在后面加一个?raw,然后使用yaml模块进行解析即可 import config from &#x27;@/assets/managerCool.config.yml?raw&#x27; import &#123;parse&#125; from &#x27;yaml&#x27; console.log(parse(config)) 第二种方法1. 转文件对象函数​ 记得安装axios import axios from &quot;axios&quot;; async function urlToFile(url:string, fileName:string) &#123; try &#123; const response = await axios.get(url, &#123; responseType: &#x27;blob&#x27; &#125;); return new File([response.data], fileName, &#123; type: response.headers[&#x27;content-type&#x27;] &#125;); &#125; catch (error) &#123; console.error(&#x27;Error fetching image:&#x27;, error); &#125; &#125; export &#123; urlToFile &#125; 2. 读取文件内容函数/** * 读取文件的方法，返回Promise对象 * @param file 要读取的文件对象 * @param encoding 文件编码格式，默认为&#x27;utf-8&#x27; */ function readFile(file: File, encoding = &#x27;utf-8&#x27;): Promise&lt;string&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建FileReader对象 const reader = new FileReader(); // 当文件读取完成后，调用resolve方法返回文件内容 reader.onload = function () &#123; resolve(reader.result as string); &#125;; // 当文件读取出错时，调用reject方法返回错误信息 reader.onerror = function () &#123; reject(reader.error); &#125;; // 以指定的编码格式读取文件内容 reader.readAsText(file, encoding); &#125;); &#125; export &#123; readFile &#125; 3. 解析yaml文件​ 需要安装yaml模块 import &#123;parse&#125; from &#x27;yaml&#x27; parse(&#x27;文件内容&#x27;) 4. 使用​ const url &#x3D; import.meta.env.VITE_CONFIG_URL;这个是我自己的配置的地址，具体的可以查看vite官网的env配置，其实这里的url就是一个指向yaml文件地址的字符串，你直接写你的yaml文件所在位置就行 import &#123;readFile&#125; from &quot;@/tools/readFile.ts&quot;; import &#123;urlToFile&#125; from &quot;@/tools/urlToFile.ts&quot;; import &#123;parse&#125; from &#x27;yaml&#x27; const url = import.meta.env.VITE_CONFIG_URL; const name = &#x27;config.yml&#x27;; urlToFile(url, name).then(file =&gt; &#123; // 使用转换后的File对象 readFile(file as File).then(res=&gt;&#123; console.log(parse(res)) &#125;) &#125;);","tags":["vue"],"categories":["前端进阶"]},{"title":"js基础篇1","path":"/2023/11/20/49/","content":"数组常用方法 注意：前面7种方法会改变原数组 1. push 后面追加元素2. pop 后面删除元素3. unshift 前面追加元素4. shift 前面删除元素5. splice 删除与增加，比如arr.splice(1, 1)、arr.splice(1, 0, &quot;lz&quot;)6. reverse 倒序7. sort 排序： 从小到大 var arr1 = [10, 1, 7, 66, 11] arr1.sort(function (a, b) &#123; return a-b &#125;) // [1, 7, 10, 11, 66] 从大到小 var arr1 = [10, 1, 7, 66, 11] arr1.sort(function (a, b) &#123; return b-a &#125;) // [66, 11, 10, 7, 1] 8. concat 拼接两个数组9. join 数组转字符串10. slice 截取​ 说明：这个可以用于字符串，也可以用于数组 11. indexOf 查找元素​ 说明: 返回索引 12. forEach 遍历var arr = [&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;] arr.forEach(function (value, index) &#123; console.log(value) &#125;) // aaa bbb ccc ddd 13. map 映射var arr = [1, 2, 3, 4, 5] var arr1 = arr.map(function (value) &#123; return value * 2 &#125;) console.log(arr1) // [2, 4, 6, 8, 10] 14. filter 过滤var arr = [11, 2, 4, 1, 5] var arr1 = arr.filter(function (value) &#123; return value &gt; 4 &#125;) console.log(arr1) // [11, 5] 15. every​ 说明：返回布尔值，如果数组里面的每一项都满足条件返回true,否则为false var arr = [90, 90, 80, 100, 95] var arr1 = arr.every(function (item) &#123; return item &gt;= 90 &#125;) console.log(arr1); // false 16. some​ 说明：返回布尔值，只要数组中的有一项满足条件就返回true，否则为false var arr = [90, 90, 80, 100, 95] var arr1 = arr.some(function (a) &#123; return a &gt;= 100 &#125;) console.log(arr1); // true 17. find​ 说明：返回第一个满足条件的数组元素 var arr = [ &#123; name: &quot;语文&quot;, grade: 90 &#125;, &#123; name: &quot;数学&quot;, grade: 85 &#125;, &#123; name: &quot;英语&quot;, grade: 100 &#125;, ] var arr1 = arr.find(function (item) &#123; return item.grade &gt;= 90 &#125;) console.log(arr1) // &#123;name: &#x27;语文&#x27;, grade: 90&#125; 18. reduce​ 说明: 每一次运行 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。 ​ var arr = [1, 2, 3, 4, 5] var arr1 = arr.reduce(function (accumulator, currentValue) &#123; return accumulator + currentValue &#125;) console.log(arr1); // 15 字符串常用方法1. charAt​ var str = &quot;liuzhe&quot; var str1 = str.charAt(2) console.log(str1) // u 2. charCodeAt​ var str = &quot;liuzhe&quot; var str1 = str.charCodeAt(2) console.log(str1) // 117 3. fromCharCode 获取26个字母​ var arr = [] for (var i = 65; i &lt; 91; i++) &#123; arr.push(String.fromCharCode(i)) &#125; console.log(arr) // [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;] 4. toLocaleUpperCase &amp;&amp; toLocaleLowerCase 大小写的转换​ var str1 = &quot;ASDasd&quot;, str2 = &quot;ZXCzxc&quot; console.log(str1.toLocaleUpperCase()) console.log(str2.toLocaleLowerCase()) // ASDASD // zxczxc 5. substr(开始索引，长度) &amp;&amp; substring(开始索引，结束索引) 字符串的截取6. replace 替换7. split 分割 字符串转成数组​ var str = &quot;abcd&quot; console.log(str.split(&quot;&quot;)) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] 8. trim 去掉首尾空格​ var str = &quot; abcd &quot; console.log(&quot;|&quot; + str + &quot;|&quot;, &quot;|&quot; + str.trim() + &quot;|&quot;) // | abcd | |abcd| new Date()常用方法 ​ 注意：获取月份时记得加1 var date=new Date() console.log(date.getFullYear())//年 console.log(date.getMonth()+1)//月 console.log(date.getDate())//日 console.log(date.getDay())//星期 console.log(date.getHours()) console.log(date.getMinutes()) console.log(date.getSeconds()) //时间戳 getTime() console.log(date.getTime()) //修改 date.setFullYear(2020) console.log(date) 浏览器相关1. 事件// 页面所有资源加载完成后执行 onload=function()&#123; console.log(&quot;加载完成&quot;) &#125; // 窗口大小改变就会执行 onresize=function()&#123; console.log(&quot;resize&quot;) &#125; //滚动条滚动就会执行 onscroll=function()&#123; console.log(&quot;scroll&quot;) &#125; 2. 滚动距离window.document.documentElement.scrollTop||window.document.body.scrollTop 3. 回到顶部​ window.scrollTo(0,0) 4. 本地存储​ // 存储 localStorage.setItem(&quot;age&quot;,&quot;19&quot;) // 获取 localStorage.getItem(&quot;age&quot;) // 移除 localStorage.removeItem(&quot;age&quot;) // 清除 localStorage.clear() 给dom标签挂标识1. 新建原生属性​ var a=document.getElementById(&quot;box&quot;) a.setAttribute(&quot;name&quot;,&quot;teichui&quot;) // &lt;div id=&quot;box&quot; name=&quot;teichui&quot;&gt;&lt;/div&gt; 2. 获取原生属性的值​ console.log(a.getAttribute(&quot;name&quot;)) // teichui 3. 移除原生属性​ a.removeAttribute(&quot;name&quot;) 4. dataset​ a.dataset.xiaoming=&quot;111&quot; //&lt;div id=&quot;box&quot; data-xiaoming=&quot;111&quot;&gt;&lt;/div&gt; // 删除 delete a.dataset.xiaoming 操作dom类名1. className(可以赋值,不会去重)​ var a=document.querySelector(&quot;#box&quot;) a.className=&quot;box1 box2&quot; // &lt;div id=&quot;box&quot; class=&quot;box1 box2&quot;&gt;&lt;/div&gt; 2. classList(会自动去重)​ //增加 a.classList.add(&quot;box4&quot;) // 移除 a.classList.remove(&quot;box2&quot;) 获取指定dom的某个节点​ var a=document.querySelector(&quot;#box&quot;) // 获取所有子节点 console.log(a.children) // 获取第一个元素子节点 console.log(a.firstElementChild) // 获取上一个兄弟节点 console.log(a.previousElementSibling) // 获取下一个兄弟节点 console.log(a.nextElementSibling) 操作dom节点var a=document.querySelector(&#x27;#aa&#x27;) var b=document.querySelector(&#x27;#bb&#x27;) // 创建节点 var odiv=document.createElement(&#x27;div&#x27;)//创建节点 odiv.innerHTML=&#x27;我是新的&#x27; // 插入子节点 a.appendChild(odiv) // 在谁的前面插入 a.insertBefore(odiv,bb) // 删除子节点 a.removeChild(bb) // 删除自己以及后代 a.remove() // 节点的替换 replaceChild(新的节点，老的节点) // 节点的克隆 cloneNode() // false 不克隆后代 // true 克隆后代 var clon=a.cloneNode(true)","tags":["js"],"categories":["前端3大件"]},{"title":"文件上传完整流程","path":"/2023/10/01/48/","content":"思维导图 构建前端1. 安装项目npm create vite@latest 相信大家运行个项目没啥问题吧，这里作者就不多费口舌了 2. 安装ant-design-vuenpm install ant-design-vue@4.x --save 不用安装这个也可以，但是要自己写前端上传代码，没必要，我们就站在巨人肩膀上就行 3. 引入ant-design-vue直接在main.ts中进行全局引入 import &#x27;./assets/main.css&#x27; import &#x27;ant-design-vue/dist/reset.css&#x27;; import Antd from &#x27;ant-design-vue&#x27;; import &#123; createApp &#125; from &#x27;vue&#x27; import App from &#x27;./App.vue&#x27; const app = createApp(App); app.use(Antd).mount(&#x27;#app&#x27;); 然后直接使用 &lt;template&gt; &lt;a-upload v-model:file-list=&quot;fileList&quot; name=&quot;avatar&quot; action=&quot;http://localhost:3000/upload&quot; :headers=&quot;headers&quot; :progress=&quot;progress&quot; @change=&quot;handleChange&quot; &gt; &lt;a-button&gt; &lt;upload-outlined&gt;&lt;/upload-outlined&gt; Click to Upload &lt;/a-button&gt; &lt;/a-upload&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt; import &#123; message &#125; from &#x27;ant-design-vue&#x27;; import &#123; UploadOutlined &#125; from &#x27;@ant-design/icons-vue&#x27;; import &#123; ref &#125; from &#x27;vue&#x27;; import type &#123; UploadChangeParam, UploadProps &#125; from &#x27;ant-design-vue&#x27;; const handleChange = (info: UploadChangeParam) =&gt; &#123; if (info.file.status !== &#x27;uploading&#x27;) &#123; console.log(info.file, info.fileList); &#125; if (info.file.status === &#x27;done&#x27;) &#123; message.success(`$&#123;info.file.name&#125; file uploaded successfully`); &#125; else if (info.file.status === &#x27;error&#x27;) &#123; message.error(`$&#123;info.file.name&#125; file upload failed.`); &#125; &#125;; const fileList = ref([]); const progress: UploadProps[&#x27;progress&#x27;] = &#123; strokeColor: &#123; &#x27;0%&#x27;: &#x27;#108ee9&#x27;, &#x27;100%&#x27;: &#x27;#87d068&#x27;, &#125;, strokeWidth: 3, format: percent =&gt; `$&#123;parseFloat(percent.toFixed(2))&#125;%`, class: &#x27;test&#x27;, &#125;; const headers = &#123; authorization: &#x27;authorization-text&#x27; &#125;; &lt;/script&gt; 需要注意的点 name中的avatar是后端接收文件的字段名 action是具体的后端接口地址 headers中的authorization是前端传给后端的头部信息 详细的信息请查看官网: https://www.antdv.com/components/overview 构建后端1. 安装项目express myapp 如果没有安装express，可以先安装express npm install -g express-generator 2. 安装crypto、multernpm i crypto multer -S 3. 后端路由var express = require(&#x27;express&#x27;); var router = express.Router(); const path = require(&#x27;path&#x27;); const crypto = require(&#x27;crypto&#x27;); // 加密 // 引入multer const multer = require(&#x27;multer&#x27;) // 定义一个生成唯一哈希文件名的函数 function generateHashedFilename(req, file, callback) &#123; const hash = crypto.randomBytes(16).toString(&#x27;hex&#x27;); const ext = path.extname(file.originalname); // 获取原始文件扩展名 const filename = `$&#123;hash&#125;$&#123;ext&#125;`; // 将哈希与扩展名拼接成新的文件名 callback(null, filename); &#125; const storage = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; cb(null, &#x27;public/images/&#x27;); &#125;, filename: generateHashedFilename, &#125;); const upload = multer(&#123; storage &#125;) /* GET home page. */ router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Express&#x27; &#125;); &#125;); router.post(&#x27;/upload&#x27;,upload.single(&#x27;avatar&#x27;), function(req, res, next) &#123; res.send(&#x27;恭喜上传成功&#x27;); // console.log(req.file); &#125;); module.exports = router; 说明 cb(null, ‘public&#x2F;images&#x2F;‘); 这个是将文件保存到public&#x2F;images&#x2F;目录下 upload.single(‘avatar’)是前端传过来的avatar字段名，这个字段名在前端的name属性中定义的 4. 解决跨域安装cors npm install cors -S 在app.js中添加 var cors = require(&#x27;cors&#x27;); // 解决跨域问题 app.use(cors(&#123; origin: &#x27;http://127.0.0.1:5173&#x27;, // 允许指定源进行跨域访问，也可以设置为&#x27;*&#x27;表示任何源 credentials: false, // 如果需要携带cookie，开启此项 allowedHeaders: [&#x27;x-requested-with&#x27;,&#x27;authorization&#x27;] // 允许自定义请求头 &#125;)); 说明 origin是前端实际地址 记得放在路由之前，不然会报错 总结这里就只对单文件上传进行简单的讲解，关于文件上传还有很多的逻辑，比如： 文件大小限制 文件类型限制 支持文件夹上传 大文件分片上传 多文件上传等等； 大家可以参考ant-design-vue与multer官网，或者网上找找资料","tags":["node"],"categories":["前端进阶"]},{"title":"解决vite+vue中别名问题","path":"/2023/09/15/47/","content":"创建vite+vue项目npm create vite@latest 配置别名在vite.config.js中配置别名 import &#123; defineConfig &#125; from &#x27;vite&#x27; import vue from &#x27;@vitejs/plugin-vue&#x27; import path from &#x27;path&#x27; // https://vitejs.dev/config/ export default defineConfig(&#123; plugins: [vue()], resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;), &#125;, &#125;, &#125;) 此时的@别名指向的是src目录 解决vscode仍然无法识别别名问题这个问题作者也找了很久，根据网上提示说: 这个问题可能是因为VS Code的JavaScript&#x2F;TypeScript语言服务没有识别到你设置的路径别名 解决方法在你的项目根目录下添加jsconfig.json或tsconfig.json文件（取决于你是用JavaScript还是TypeScript），然后设置路径别名。例如，如果你想要设置@为src目录的别名，可以按照以下方式设置： &#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;] &#125;","tags":["vue"],"categories":["前端进阶"]},{"title":"npm创建vue项目","path":"/2023/09/11/46/","content":"创建vue3项目npm init vue@latest npm init vue@latest 安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。创建的 vue3 项目是基于 Vite 打包的。","tags":["vue"],"categories":["前端进阶"]},{"title":"主题推荐-stellar","path":"/2023/09/10/45/","content":"预览图 官方文档https://xaoxuu.com/wiki/stellar/ 安装在hexo根目录下执行 git clone https://github.com/xaoxuu/hexo-theme-stellar.git themes/stellar 运行安装后运行可能会缺少一些模块，可以根据报错，将缺失的模块安装比如我缺少的模块是: hexo-fs hexo-util 执行 npm install hexo-fs hexo-util -D 增加友链页面 先在hexo根目录执行 hexo new page friends 修改主题配置文件增加一个导航 nav_tabs: &#x27;友链&#x27;: /friends/ 新建yml文件，用以存放友链信息在根目录下新建: source&#x2F;_data&#x2F;links&#x2F;ios_developer.yml配置如下 - title: 某某某 url: https:// cover: icon: description: 使用找到刚才新建的friends页面, 在其index.md文件中添加如下内容: &#123;% friends ios_developer %&#125;","tags":["stellar"],"categories":["魔改"]},{"title":"css中变量的使用","path":"/2023/09/05/44/","content":"前言说来惭愧，最近学习sass后，才发现原来css中也可以写变量，原来自己对css的知识只是冰山一角，接下来我们就来写一个简单的动态改变背景颜色的demo css中如何定义变量:root&#123; --color: #000; &#125; 如何使用body&#123; height: 96vh; background-color: var(--color); &#125; js中获取变量值const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); js中动态改变变量值document.documentElement.style.setProperty(&#x27;--color&#x27;, 值); 完整代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;简单的背景选择&lt;/title&gt; &lt;style&gt; :root&#123; --color: #000; &#125; body&#123; height: 96vh; background-color: var(--color); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;color&quot; id=&quot;color&quot;&gt; &lt;script&gt; // const rootColor = getComputedStyle(document.documentElement).getPropertyValue(&#x27;--color&#x27;); let colorSelector = document.querySelector(&#x27;#color&#x27;); colorSelector.addEventListener(&#x27;change&#x27;, (e) =&gt; &#123; // 通过改变css变量，改变页面背景色 document.documentElement.style.setProperty(&#x27;--color&#x27;, e.target.value); &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 或许css才是最神秘的语言","tags":["css"],"categories":["前端3大件"]},{"title":"在vscode中的使用sass插件","path":"/2023/09/02/43/","content":"介绍Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。官网: https://sass-lang.com/ 在vscode中安装安装插件: Live Sass Compiler此插件可以直接将sass文件转为css文件官方文档: https://github.com/ritwickdey/vscode-live-sass-compiler?tab=readme-ov-file 安装后需要进行配置 点击扩展设置 编辑json文件 我的配置如下（仅供参考） &#123; &quot;liveSassCompile.settings.formats&quot;:[ // This is Default. &#123; /* 1.nested: 嵌套模式 2.compact: 紧凑模式 3.expanded: 展开模式 4.compressed: 压缩模式 */ &quot;format&quot;: &quot;expanded&quot;, &quot;extensionName&quot;: &quot;.css&quot;, &quot;savePath&quot;: &quot;~/./css&quot; &#125;, ], // 排除目录 &quot;liveSassCompile.settings.excludeList&quot;: [ &quot;**/node_modules/**&quot;, &quot;.vscode/**&quot; ], // 是否添加兼容前缀 &quot;liveSassCompile.settings.autoprefix&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot; ], // 控制资源管理器是否应在通过回收站删除文件时要求确认。 &quot;explorer.confirmDelete&quot;: false, // 是否生成.map文件 &quot;liveSassCompile.settings.generateMap&quot;: false &#125; 如何使用安装成功后，会在vscode的下方出现watch Sass，点击后就会对你目前的sass文件进行监听，自动生成css文件","tags":["sass"],"categories":["前端进阶"]},{"title":"js扩展API","path":"/2023/08/28/42/","content":"数组方法 拆分多维数组flat let arr = [1,2,[3,4,[5,6]]] console.log(arr.flat(2)) // [1,2,3,4,5,6] 数组元素修改fill let arr = [1, 2, 3, 4, 5] console.log(arr.fill(10, 2)) // [1, 2, 10, 10, 10] 只改变数组其中一个元素with let arr = [1, 2, 3, 4, 5] console.log(arr.with(1, 100)) //[1, 100, 3, 4, 5] 数值方法 Math.trunc() 方法会将数字的小数部分去掉，只保留整数部分 let a = 123.9999 console.log(Math.trunc(a)) // 123 Math.sign() 函数返回一个数字的符号，指示数字是正数，负数还是零 console.log(Math.sign(99)) // 1 console.log(Math.sign(-3)) // -1 console.log(Math.sign(0)) // 0 字符串方法 startsWith和endsWith方法可以判断字符串是否以指定字符串开头或结尾 let str = &quot;hello&quot; console.log(str.startsWith(&quot;h&quot;)) // true console.log(str.startsWith(&quot;h&quot;, 1)) // false console.log(str.endsWith(&quot;o&quot;)) // true 字符串的repeat方法可以重复字符串 let str = &quot;hello&quot; console.log(str.repeat(3)) // hellohellohello 字符串的padStart和padEnd方法可以对字符串进行填充 let str = &quot;hello&quot; console.log(str.padStart(10, &quot;world&quot;)) // worldhello console.log(str.padEnd(10, &quot;world&quot;)) // helloworld at函数用于访问数组 let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] console.log(arr.at(1)) // 2 console.log(arr.at(-1)) // 10 generator函数生成器函数可以暂停执行，下次调用时继续执行 function *generator() &#123; yield &#x27;aaa&#x27;; yield &#x27;bbb&#x27;; &#125; let a = generator(); for(let item of generator())&#123; console.log(item); &#125; // aaa // bbb ReflectReflect对象提供了一组静态方法，用于操作对象的属性和方法 Reflect.has判断对象是否存在某个属性 let obj = &#123; name: &#x27;xiaoming&#x27;, age: 18 &#125; console.log(Reflect.has(obj, &#x27;name&#x27;)) // true Reflect.ownKeys()返回这个对象自身的属性 console.log(Reflect.ownKeys(obj)) // [ &#x27;name&#x27;, &#x27;age&#x27; ] Reflect.defineProperty()为对象添加一个属性，并且可以进行配置 Reflect.defineProperty(obj, &#x27;height&#x27;, &#123; value: 170, writable: true, enumerable: true, configurable: true &#125;) console.log(obj) // &#123; name: &#x27;xiaoming&#x27;, age: 18, height: 170 &#125; Reflect.set()为对象直接添加一个属性 Reflect.set(obj, &#x27;weight&#x27;, 70) console.log(obj) // &#123;name: &#x27;xiaoming&#x27;, age: 18, weight: 70&#125; Reflect与Proxy联合使用 let obj = &#123;&#125; let proxy = new Proxy(obj, &#123; get(target, key) &#123; return Reflect.get(...arguments) &#125;, set(target, key, value) &#123; Reflect.set(...arguments) return true &#125; &#125;) matchAll()方法返回一个迭代器，该迭代器包含了检索字符串与正则表达式进行匹配的所有结果 let str = ` &lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt; &lt;/ul&gt; ` let reg = /&lt;li&gt;(?&lt;content&gt;.*)&lt;\\/li&gt;/g for(var item of str.matchAll(reg))&#123; console.log(item) &#125; Promise集合一个 Promise 必然处于以下几种状态之一：1.待定（pending）：初始状态，既没有被兑现，也没有被拒绝。2.已兑现（fulfilled）：意味着操作成功完成。3.已拒绝（rejected）：意味着操作失败。 function ajax(str, time, isSuccess) &#123; if (isSuccess)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(str); &#125;, time); &#125;); &#125;else&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(str); &#125;, time); &#125;); &#125; &#125; Promise.all()等待所有 Promise, 在任意一个 Promise 被拒绝时拒绝 Promise.all([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) Promise.race() 看哪一个 Promise 先被执行完，就执行哪一个 Promise Promise.race([ajax(&#x27;1&#x27;,1000, true), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;) Promise.any()当输入的任何 promise 实现时，此返回的 promise 将实现，并具有第一个 fulfillation 值。当所有输入的 promise 都拒绝时（包括传递空可迭代对象时），它会拒绝 Promise.any([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, true)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err, &#x27;拒绝&#x27;) &#125;) Promise.allSettled() 无论任何 promise 实现，此返回的 promise 都将实现，并具有一个数组，其中包含每个输入 promise 的状态和值。 Promise.allSettled([ajax(&#x27;1&#x27;,1000, false), ajax(&#x27;2&#x27;,2000, false)]).then((res) =&gt; &#123; console.log(res) &#125;).catch((err) =&gt; &#123; console.log(err) &#125;)","tags":["js"],"categories":["前端3大件"]},{"title":"css属性mix-blend-mode介绍","path":"/2023/08/25/41/","content":"介绍mix-blend-mode 是一种 CSS 属性，它定义了一个元素的颜色如何与其父元素的颜色以及兄弟元素的颜色混合。它允许您创建令人惊艳的视觉效果，可以用于创建半透明效果、添加阴影、制作图片蒙版和很多其他效果。 具体属性值 difference将前景色减去背景色的值，并取绝对值。这会导致一个反相的效果。效果如下: multiply将两个颜色的值相乘，得到一个更暗的颜色。这通常用于创建阴影效果。原效果如下: 使用multiply后 screen将两个颜色的值相加，然后减去相乘的值，得到一个更亮的颜色。这通常用于创建高光效果。效果如下: overlay根据背景颜色的亮度来选择颜色混合模式。如果背景颜色较暗，则使用 multiply 模式；如果背景颜色较亮，则使用 screen 模式。 darken将两个颜色的值比较，使用较暗的那个颜色。 lighten将两个颜色的值比较，使用较亮的那个颜色。 color-dodge将前景色分解为 RGB 分量，并将每个分量分别除以（1 减去背景色的对应分量）。然后将每个分量限制在 0 到 1 之间，并使用限制后的前景色作为混合色。 color-burn将前景色分解为 RGB 分量，并将每个分量分别除以背景色的对应分量。然后将每个分量限制在 0 到 1 之间，并使用限制后的前景色作为混合色。 exclusion将前景色和背景色的值相加，然后减去相乘的值的两倍。这通常用于创建反相效果。 hue将前景色的色相（Hue）与背景色的饱和度（Saturation）和亮度（Lightness）混合。这可以用于在不改变亮度和饱和度的情况下改变颜色。 saturation将前景色的饱和度与背景色的色相和亮度混合。这可以用于在不改变颜色的情况下改变饱和度。 color将前景色的色相、饱和度和亮度与背景色混合。这可以用于在改变所有颜色属性的情况下改变前景色的颜色。 luminosity将前景色的亮度与背景色的色相和饱和度混合。这可以用于在不改变颜色的情况下改变亮度。","tags":["css"],"categories":["前端3大件"]},{"title":"uni-app实现app自动检测更新","path":"/2023/08/23/40/","content":"前言在做app项目时，app版本管理是必不可少的，在发布新版本后，应该提醒用户需要更新了此时需要两个功能： 后台进行版本发布与管理（使用uni-app的模板admin即可，需要关联Dcloud的服务空间） 前台检测更新（使用uni-app的插件, https://ext.dcloud.net.cn/plugin?id=4542） 后台 在HBuilder里面新建一个项目（模板为uni-admin）： 运行项目到浏览器 登录即可（没有先注册） 在系统管理中找到应用管理 新增一个应用成功后即可发布版本，首先得进行云打包，每次发布都会让你上传apk资源包的，并且每次上传的版本号要比上次大 前台检测更新 插件引入, https://ext.dcloud.net.cn/plugin?id=4542 添加路径在pages.json文件，添加一个更新页面 &#123; &quot;path&quot;: &quot;uni_modules/uni-upgrade-center-app/pages/upgrade-popup&quot;, &quot;style&quot;: &#123; &quot;disableScroll&quot;: true, &quot;app-plus&quot;: &#123; &quot;backgroundColorTop&quot;: &quot;transparent&quot;, &quot;background&quot;: &quot;transparent&quot;, &quot;titleNView&quot;: false, &quot;scrollIndicator&quot;: false, &quot;popGesture&quot;: &quot;none&quot;, &quot;animationType&quot;: &quot;fade-in&quot;, &quot;animationDuration&quot;: 200 &#125; &#125; &#125; 添加更新代码(建议在App.vue中引入) import checkUpdate from &#x27;uni_modules/uni-upgrade-center-app/utils/check-update.ts&#x27; 在生命周期函数中调用此函数 checkUpdate()","tags":["uni-app"],"categories":["前端进阶"]},{"title":"vue(原生js)事件委托与参数同时使用","path":"/2023/08/19/39/","content":"事件委托的作用在孩子节点需要绑定多个点击事件的时候，可以直接使用事件委托，将点击事件绑定到父节点，利用事件委托就可以知道自己点击的孩子节点是谁了 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../库/vue2.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot; @click=&quot;test&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#box&#x27;, methods: &#123; test(event) &#123; console.log(event.target) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 默认在不传参数的时候，在方法定义的第一个参数就是事件委托的对象 vue事件委托与参数同时使用如果需要传参的同时，并且能够使用事件委托对象，可以这样： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../库/vue2.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot; @click=&quot;test($event, &#x27;ttt&#x27;)&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#box&#x27;, methods: &#123; test(event, a) &#123; console.log(event.target, a) &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 原生js事件委托与参数同时使用可以使用闭包，还有其他方法可以在这里发表哦，这也是事件传递参数的一种方式 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;box&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script&gt; box.onclick = test(&quot;aaa&quot;) function test(a) &#123; return function (evt) &#123; console.log(evt.target, a) &#125; &#125; &lt;/script&gt; &lt;/html&gt;","tags":["vue"],"categories":["前端进阶"]},{"title":"探究css的滤镜效果","path":"/2023/08/15/38/","content":"今天来讲一讲前端的滤镜效果，也就是filter属性 drop-shadow如果我让你对一个图片里面的图形设置阴影，你有什么办法吗？正常来说你可能想到的是box-shadow,给盒子设置一个阴影 box-shadow: 10px 10px 10px gray; 但是好像没有达到我们预期的效果，那么这里就要用上drop-shadow了不要box-shadow，而是filter filter: drop-shadow(10px 10px 10px gray); blur这个值会让像素变得模糊正常来说: 设置blur后（后面还发现了一个神奇的现象，我的margin: 0 auto;好像失效了，但是好像又没有，因为这个盒子还是在屏幕中间的，不知道为什么，好像这个blur会使这个元素的像素点回到最初的状态） filter: blur(10px); contrast提高色彩对比度 grayscale变灰，一些纪念日用得上 backdrop-filter正常: 如果我想给他的背景加点模糊效果，怎么做呢?注意这里可不能用filter了而是得用到我们的backdrop-filter这个可以模糊自身后面的像素 backdrop-filter: blur(10px);","tags":["css"],"categories":["前端3大件"]},{"title":"主题推荐-anzhiyu","path":"/2023/08/10/37/","content":"预览图 官方文档https://docs.anheyu.com/ 下载git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu 安装 pug 和 stylus 渲染插件npm install hexo-renderer-pug hexo-renderer-stylus --save","tags":["anzhiyu"],"categories":["魔改"]},{"title":"maupassant的基本配置","path":"/2023/08/05/36/","content":"新增标签页面 在hexo根目录下执行 hexo new page tags 会发现在source文件夹下多了一个tags文件夹, 点进去找到index.md文件，添加如下配置即可 --- title: tags date: 2023-10-13 23:11:26 layout: tagcloud --- 添加一个导航找到主题配置文件的_config.yml文件, 找到menu属性: menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive - page: tags directory: tags/ icon: fa-tag - page: about directory: about/ icon: fa-user 添加网站图标将favicon.ico放到hexo的根目录source文件夹下即可，推荐像素为32*32, 不会立即生效 增加搜索功能 安装插件 npm install hexo-generator-search 添加代码至hexo下面的_config.yml文件 search: path: search.xml field: post content: true 修改主题下的_config.yml文件 self_search: true 清除多余的搜索框做到这里你会发现你的页面多了一个搜索输入框，我来教你解决找到主题文件下的source&#x2F;js&#x2F;search.js添加脚本 const searchInput = document.querySelector(&#x27;.widget input&#x27;) searchInput.style.display = &#x27;none&#x27;","tags":["maupassant"],"categories":["魔改"]},{"title":"主题推荐-maupassant","path":"/2023/08/03/35/","content":"今天给大家推荐一款非常好看的主题，预览如下 下载主题首先在自己的hexo博客项目的根目录下执行 git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant 安装渲染器npm install hexo-renderer-sass --save npm install hexo-renderer-jade --save 修改_config.ymltheme: maupassant 运行查看效果hexo s","tags":["maupassant"],"categories":["魔改"]},{"title":"uni-app中的省市区选择组件","path":"/2023/08/02/34/","content":"找到省市区选择组件的资源包因为uni-app中不支持npm安装后直接导入，所以我们必须先找到这个组件 uni-app中提供了这个组件资源，我们打开Hbuilder，新建一个uni-app的模板项目，如下： 创建完成后找到这个组件，如下： 将其复制到自己的uni-app项目中 配置可参考：https://github.com/MPComponent/mpvue-citypicker 我的配置（仅供参考） &lt;template&gt; &lt;view class=&quot;&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;city&quot; style=&quot;border: 1px solid black;&quot;&gt; &lt;button @tap=&quot;showCityPicker&quot;&gt;选择城市&lt;/button&gt; &lt;mpvue-city-picker ref=&quot;mpvueCityPicker&quot; :pickerValueDefault=&quot;pickerValueDefault&quot; @onChange=&quot;onChange&quot; @onCancel=&quot;onCancel&quot; @onConfirm=&quot;onConfirm&quot;&gt;&lt;/mpvue-city-picker&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import mpvueCityPicker from &#x27;@/components/mpvue-citypicker/mpvueCityPicker.vue&#x27;; export default &#123; data() &#123; return &#123; pickerValueDefault: [0, 0, 1], city: &#x27;请选择...&#x27; &#125;; &#125;, components: &#123; mpvueCityPicker &#125;, methods: &#123; showCityPicker() &#123; this.$refs.mpvueCityPicker.show(); &#125;, onChange(e) &#123; console.log(e); &#125;, onCancel(e) &#123; console.log(e); &#125;, onConfirm(e) &#123; this.city = e.label &#125; &#125; &#125;; &lt;/script&gt;","tags":["uni-app"],"categories":["前端进阶"]},{"title":"chart.js的使用","path":"/2023/07/27/33/","content":"先导之前使用canvaJS已经写过了一个统计页面，但是我觉得样式不够好看，于是又去找图表框架，发现chart.js还挺好看，这里就不说怎么创建一个统计页面了，我不可能所有文章都从最最最基础的讲起的，作者也开始摆烂咯，哈哈哈哈！！！（主要是写教程没经济来源） 找到教程教程：Chart.js · GitBook (bootcss.com) 本教程会使用到webpack, 不知道什么是webpack的，可以先去看一下，官网在：webpack，用于解决模块化导入问题。我觉得很多小伙伴是不是卡在这里了呢？看到这里你是不是觉得很懵，为什么能直接在自己博客的目录下安装chart.js, 然后直接引用，哈哈哈哈，hexo可不支持模块化哦！，看以后会不会支持吧，反正不管怎样都要使用webpack去打包，生成一个可用的js文件 安装webpack在一个空文件夹中 npm i webpack npm i webpack-cli 安装chart.jsnpm i chart.js 新建一个src目录在此目录新建main.js, 主要用于写chart.js的配置内容如下： import Chart from &quot;chart.js/auto&quot;; var ctx = document.getElementById(&quot;myChart&quot;).getContext(&#x27;2d&#x27;); var myChart = new Chart(ctx, &#123; type: &#x27;bar&#x27;, data: &#123; labels: [&quot;Red&quot;, &quot;Blue&quot;, &quot;Yellow&quot;, &quot;Green&quot;, &quot;Purple&quot;, &quot;Orange&quot;], datasets: [&#123; label: &#x27;# of Votes&#x27;, data: [12, 19, 3, 5, 2, 3], backgroundColor: [ &#x27;rgba(255, 99, 132, 0.2)&#x27;, &#x27;rgba(54, 162, 235, 0.2)&#x27;, &#x27;rgba(255, 206, 86, 0.2)&#x27;, &#x27;rgba(75, 192, 192, 0.2)&#x27;, &#x27;rgba(153, 102, 255, 0.2)&#x27;, &#x27;rgba(255, 159, 64, 0.2)&#x27; ], borderColor: [ &#x27;rgba(255,99,132,1)&#x27;, &#x27;rgba(54, 162, 235, 1)&#x27;, &#x27;rgba(255, 206, 86, 1)&#x27;, &#x27;rgba(75, 192, 192, 1)&#x27;, &#x27;rgba(153, 102, 255, 1)&#x27;, &#x27;rgba(255, 159, 64, 1)&#x27; ], borderWidth: 1 &#125;] &#125;, options: &#123; scales: &#123; yAxes: [&#123; ticks: &#123; beginAtZero:true &#125; &#125;] &#125; &#125; &#125;); 注意chart.js的引用：import Chart from “chart.js&#x2F;auto”; 配置webpack的打包信息新建文件webpack.config.js const path = require(&#x27;path&#x27;); module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./src/main.js&#x27;, // 项目的入口文件路径 output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27; // 构建后的文件路径和文件名 &#125; &#125;; 执行命令： npx webpack 执行后生成一个dist文件夹 创建html页面&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;myChart&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 用浏览器打开应该就成功了 最后在根据我之前的那篇文章：增加一个统计模块 | Lazychild&#39;s Blog，可以获取本地的一些数据，将图表的数据与博客数据关联起来，最后将自己生成的js文件与html页面移植到自己的博客项目中即可","tags":["butterfly"],"categories":["魔改"]},{"title":"LeanCloud云数据库基本操作","path":"/2023/07/23/32/","content":"官网LeanCloud: 在这里你可以注册leanCloud的账号，并且创建你的应用，即数据库 下面将以vue2案例向大家介绍如何使用leanCloud进行数据的储存, 带大家写一个最常用的登录验证的例子吧 创建一个最简单的vue2项目吧vue create 项目名称 之前有介绍， 这里就不详细说明了 创建好后，建立两个页面，一个登录页面，还有一个登录跳转后的页面 先自己将路由写好， 能够访问这两个页面即可 下载必要的模块npm install leancloud-storage 在登录页面引入模块并初始化const AV = require(&quot;leancloud-storage&quot;); // 初始化 LeanCloud AV.init(&#123; appId: &quot;你的应用的appId&quot;, appKey: &quot;你的应用的appKey&quot;, serverURL: &quot;https://ysyeflyc.lc-cn-n1-shared.com&quot;, &#125;); 用户的登录验证 // 用户登录 AV.User.logIn(username, password).then(function(user) &#123; // 登录成功，跳转页面 &#125;).catch(function(error) &#123; // 登录失败 &#125;); vue2的路由守卫的书写，防止用户未登录就能访问登录后的页面 beforeEnter: (to, from, next) =&gt; &#123; var token = localStorage.getItem(&#x27;AV/YsYeflyCpiGJrcfPnYM80d43-gzGzoHsz/currentUser&#x27;) var tokenObj = JSON.parse(token) AV.User.become(tokenObj?._sessionToken) .then(function (user) &#123; // token 验证成功，user 是验证后返回的用户对象 next() &#125;) .catch(function (error) &#123; // token 验证失败 location.href = &quot;http://xiao-zhe-is-not-lazy.gitee.io/chou/#/login&quot; &#125;); &#125; 用户属性的更改，将awordNumber改为0 var currentUser = AV.User.current(); currentUser.set(&quot;awordNumber&quot;, 0); currentUser .save() .then(function (updatedUser) &#123; // 更新成功 console.log(&quot;更新成功&quot;); &#125;) .catch(function (error) &#123; // 更新失败 &#125;); 我的项目页面展示我主要是写了一个抽奖的项目，一个用户登录后只能抽一次奖 登录界面：&lt;template&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;cover&quot; v-if=&quot;isShow&quot;&gt;登录失败&lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- span标签作为背景的圆形图案 --&gt; &lt;div class=&quot;bg&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;text&quot;&gt; 云亦音乐 &lt;span style=&quot; font-size: 12px; line-height: 50px; margin-left: 5px; color: gray; &quot; &gt;周年庆抽奖活动火热进行中!&lt;/span &gt; &lt;/div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;账号&quot; id=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; placeholder=&quot;密码&quot; id=&quot;password&quot; /&gt; &lt;input type=&quot;text&quot; placeholder=&quot;验证码&quot; id=&quot;code&quot; /&gt; &lt;div class=&quot;code&quot;&gt; &lt;div&gt;验证码:&lt;/div&gt; &lt;div&gt;&#123;&#123; code &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;button @click=&quot;btn&quot;&gt;→&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import codeFun from &#x27;@/assets/code&#x27; const AV = require(&quot;leancloud-storage&quot;); // 初始化 LeanCloud AV.init(&#123; appId: &quot;隐藏&quot;, appKey: &quot;隐藏&quot;, serverURL: &quot;https://ysyeflyc.lc-cn-n1-shared.com&quot;, &#125;); export default &#123; data() &#123; return &#123; isShow: false, code: &quot;1234&quot;, timer: null, &#125;; &#125;, created()&#123; this.code = codeFun() &#125;, methods: &#123; btn() &#123; clearTimeout(this.timer); if (code.value == this.code) &#123; AV.User.logIn(username.value, password.value) .then((user) =&gt; &#123; // 登录成功 this.$router.push(&quot;/chou&quot;); &#125;) .catch(() =&gt; &#123; // 登录失败（可能是密码错误） this.isShow = true; this.timer = setTimeout(() =&gt; &#123; this.isShow = false; &#125;, 2000); &#125;); &#125; else &#123; this.code = codeFun() this.isShow = true; this.timer = setTimeout(() =&gt; &#123; this.isShow = false; &#125;, 2000); &#125; &#125;, &#125;, &#125;; &lt;/script&gt; &lt;style scoped&gt; .box &#123; background-color: rgba(0, 0, 0); margin: 0; padding: 0; width: 100%; height: 100%; position: absolute; z-index: -2; &#125; .container &#123; width: 80vw; height: 65vh; margin: 20vh auto; background-color: rgba(255, 255, 255, 0.1); border-radius: 20px; position: relative; box-shadow: inset 1px 1px 6px rgba(255, 255, 255, 0.3), 2px 2px 15px rgba(0, 0, 0, 0.5); &#125; input &#123; background: transparent; outline: none; border: none; border-bottom: 1px solid #666; width: 80%; height: 45px; font-size: 18px; margin-left: 30px; margin-top: 40px; color: white; &#125; .text &#123; display: inline-block; font-size: 26px; margin-left: 34px; margin-top: 50px; color: #eee; &#125; button &#123; border: none; width: 70px; height: 70px; border-radius: 50%; font-weight: bold; font-size: 26px; margin-top: 60px; margin-left: calc(50% - 35px); cursor: pointer; background-color: rgba(255, 255, 255, 0.1); color: white; text-align: center; box-shadow: 0 2px 10px #111; &#125; button:hover &#123; color: greenyellow; background-color: rgba(255, 255, 255, 0.2); &#125; span &#123; position: absolute; border-radius: 50%; box-shadow: 1px 1px 50px #000; z-index: -1; &#125; .bg &#123; width: 100%; height: 100%; position: absolute; z-index: -1; animation: am2 ease-out 1s; &#125; .bg span:nth-child(1) &#123; width: 80px; height: 80px; top: -30px; left: -30px; background-color: purple; animation: am1 ease-in-out 3s infinite alternate; &#125; .bg span:nth-child(2) &#123; width: 40px; height: 40px; top: 40px; right: 40px; background-color: orange; animation: am1 ease-in-out 4s infinite alternate-reverse; &#125; .bg span:nth-child(3) &#123; width: 120px; height: 120px; bottom: -60px; right: -25px; background-color: cyan; animation: am1 ease-in-out 2.5s 0.5s infinite alternate; &#125; /* 动画 */ @keyframes am1 &#123; 0% &#123; transform: translateY(0); &#125; 100% &#123; transform: translateY(-30px); &#125; &#125; @keyframes am2 &#123; 0% &#123; transform: scale(0, 0) rotateZ(60deg); &#125; 100% &#123; transform: scale(1, 1) rotateZ(0); &#125; &#125; .cover &#123; width: 90vw; position: absolute; top: 10vh; left: 5vw; text-align: center; opacity: 0.9; color: #e10b0b; border-radius: 20px; &#125; /* 验证码 */ .code &#123; color: #c2a3a3; display: flex; margin-left: 10%; margin-top: 10px; &#125; .code div:nth-child(2) &#123; width: 70px; height: 30px; text-align: center; line-height: 30px; margin-left: 10px; background-color: #353743; border: 1px solid white; font-size: 20px; border-radius: 3px; &#125; &lt;/style&gt; 登录页面需要引用的js（验证码的生成）let codeFun = () =&gt; &#123; var code1 = String(Math.floor(Math.random() * 10)) var code2 = String(Math.floor(Math.random() * 10)) var code3 = String(Math.floor(Math.random() * 10)) var code4 = String(Math.floor(Math.random() * 10)) return code1 + code2 + code3 + code4 &#125; export default codeFun 抽奖页面&lt;template&gt; &lt;div @click=&quot;btn2()&quot; class=&quot;box&quot;&gt; &lt;audio src=&quot;@/assets/music.mp3&quot; autoplay&gt;&lt;/audio&gt; &lt;!-- 抽中奖品后的遮罩层 --&gt; &lt;div class=&quot;cover&quot; v-if=&quot;isShow&quot;&gt; &#123;&#123; selectedPrize?.name &#125;&#125; &lt;span&gt;恭喜你获得：&#123;&#123; selectedPrize?.describe &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;button @click.once=&quot;btn&quot;&gt;抽奖&lt;/button&gt; &lt;div&gt;剩余的抽奖次数: &#123;&#123; currentUser?.attributes.awordNumber &#125;&#125;&lt;/div&gt; &lt;footer&gt; &lt;h3&gt;奖品详情：&lt;/h3&gt; &lt;div v-for=&quot;(data, index) in prizes&quot; :key=&quot;index&quot;&gt; &lt;span&gt; &#123;&#123; data.name &#125;&#125; : &lt;/span&gt; &lt;span&gt;&#123;&#123; data.describe &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; const AV = require(&quot;leancloud-storage&quot;); // 声明 class const Todo = AV.Object.extend(&quot;Todo&quot;); // 构建对象 const todo = new Todo(); export default &#123; data() &#123; return &#123; prizes: [ &#123; name: &quot;一等奖&quot;, describe: &quot;免费体验课&quot;, probability: 0 &#125;, &#123; name: &quot;二等奖&quot;, describe: &quot;尤克里里一个&quot;, probability: 0 &#125;, &#123; name: &quot;三等奖&quot;, describe: &quot;小玩具一个&quot;, probability: 0.05 &#125;, &#123; name: &quot;四等奖&quot;, describe: &quot;免费来撸猫&quot;, probability: 0.15 &#125;, &#123; name: &quot;鼓励奖&quot;, describe: &quot;抱抱&quot;, probability: 1 &#125;, ], selectedPrize: null, isShow: false, currentUser: null, &#125;; &#125;, created() &#123; this.currentUser = AV.User.current(); &#125;, methods: &#123; btn(event) &#123; if (this.currentUser.attributes.awordNumber === 0) &#123; alert(&quot;抽奖次数已用完&quot;); return; &#125; this.isRote = true; this.currentUser.attributes.awordNumber -= 1; // 生成一个随机的概率值 var randomProbability = Math.random(); for (var i = 0; i &lt; this.prizes.length; i++) &#123; var prize = this.prizes[i]; if (randomProbability &lt; prize.probability) &#123; this.selectedPrize = prize; // 为属性赋值 todo.set(this.currentUser.attributes.username, prize.describe); break; &#125; else &#123; this.selectedPrize = &#123; name: &quot;空&quot;, describe: &quot;什么都没有&quot; &#125;; &#125; &#125; // 更新后台 this.currentUser.set( &quot;awordNumber&quot;, this.currentUser.attributes.awordNumber ); this.currentUser .save() .then(function (updatedUser) &#123; // 更新成功 console.log(&quot;更新成功&quot;); &#125;) .catch(function (error) &#123; // 更新失败 console.log(&quot;更新失败&quot;); &#125;); // 用户奖品的数据储存 // 将对象保存到云端 todo.save().then( (todo) =&gt; &#123; // 成功保存之后，执行其他逻辑 console.log(`奖品数据保存成功`); &#125;, (error) =&gt; &#123; // 异常处理 console.log(`奖品数据保存失败`); &#125; ); this.isShow = true; // 阻止冒泡 event.stopPropagation(); &#125;, btn2() &#123; this.isShow = false; &#125;, &#125;, &#125;; &lt;/script&gt; &lt;style scoped&gt; .box &#123; height: 100vh; background: no-repeat url(&quot;@/assets/bg.png&quot;); background-size: cover; &#125; button &#123; border: none; width: 70px; height: 70px; border-radius: 50%; font-weight: bold; font-size: 26px; margin-top: 60px; margin-left: calc(50% - 35px); cursor: pointer; background-color: rgba(255, 255, 255, 0.1); text-align: center; box-shadow: 0 2px 10px #111; &#125; .item &#123; width: 80px; height: 80px; background-color: rgba(0, 0, 0, 0.8); margin: 20px; color: #fff; line-height: 80px; text-align: center; border-radius: 10px; font-size: 14px; &#125; .cover &#123; width: 90vw; height: 30vh; position: absolute; top: 35vh; left: 5vw; text-align: center; line-height: 30vh; background-color: black; opacity: 0.9; color: #eee; border-radius: 20px; &#125; footer &#123; width: 100%; position: absolute; left: 0; bottom: 0; font-size: 15px; background-color: rgba(0, 0, 0, 0.4); color: white; font-size: 30px; &#125; footer span &#123; margin-bottom: 5px; &#125; @keyframes am1 &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; &lt;/style&gt;","tags":["LeanCloud"]},{"title":"Aseprite汉化教程","path":"/2023/07/19/31/","content":"推荐一个好用的像素画制作软件官网：https://www.aseprite.org/ 汉化包与主题包下载在网上找了好久，才找到，于是直接上传到云仓库了，防止丢失，嘻嘻https://gitee.com/xiao-zhe-is-not-lazy/aseprite Aseprite汉化与主题修改 打开下载好的软件，找到左上角，点击Edit 将最下面的File type改为All files： 找到下载好的汉化包与主题包，增加即可 然后会发现多了种语言和主题： 将语言改为中文（将这里的en修改为sChinese）： 到了这一步会发现字体模糊，需要配置主题才可以 修改主题： 点击调整缩放：","tags":["Aseprite"],"categories":["游戏制作"]},{"title":"解决安装Godot时未授权","path":"/2023/07/16/30/","content":"最近对像素类游戏产生了极大的兴趣，感觉玩的不是很过瘾（主要是好多游戏都收费），于是我打算去自己动手制作一款像素类游戏找了很多游戏引擎，搜到最多的就是Unity和Godot，经过一番思考，我打算学习Godot 首先我喜欢Godot的编辑页面， 给人一种简约美 个人认为Godot容易上手 至于游戏的各种素材的制作， 也就是美术和音频，我打算慢慢积累，毕竟游戏制作我认为素材的制作最重要，也最难，目前是打算制作一款像素风格类的生存游戏 于是开始安装Godot找到官网https://godotengine.org/后，开始下载，速度很慢，但这不是大问题，大概下了一半左右，上面提示说未授权， 我真的很懵逼， 刚开始我以为是Godot需要收费，后面去搜索， 发现Godot是一款完全免费的软件，于是去找发现是本地安全策略的问题， 于是去看大佬们的解决办法， 这里@https://blog.csdn.net/weixin_60526471&#x2F;article&#x2F;details&#x2F;126105622 作者就是看这篇文章解决的， 为了防止文章丢失， 作者这里就记录一下 1. 新建一个txt文件，内容如下 @echo off pushd &quot;%~dp0&quot; dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in (&#x27;findstr /i . List.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;C:\\Windows\\servicing\\Packages\\%%i&quot; pause 2. 将txt文件的后缀改为.cmd, 然后右键以管理员身份打开，等待.cmd文件运行完成，就可以成功开启组策略了3. 同时按【WIN键+R键】，打开cmd命令窗口，输入gpedit.msc，这时候点击【确定】按钮，或按回车键(Enter)就可以打开本地策略组的内容了，4. 本地组策略编辑器找到之后就是调整一下设置了 。找到计算机配置 → windows管理 → 安全设置 → 本地策略 → 安全选项 → 用户控制：以管理员批准模式运行所有管理员 → 双击进入，设置为已禁用状态即可。重启电脑即可正常下载软件了。","tags":["Godot"],"categories":["游戏制作"]},{"title":"使用nvm对node进行版本管理","path":"/2023/07/15/29/","content":"下载nvm地址在https://github.com/coreybutler/nvm-windows/releases 下载后在任意终端执行, 看是否安装成功 nvm -v 不成功的，可以先将已经安装的node卸载掉 nvm常用命令 安装指定版本: nvm install 版本号 列出远程服务器上所有的可用版本： nvm ls available 在不同版本间进行切换(已经安装了) nvm use 版本号 查看本地安装了的node版本 nvm ls","tags":["node"],"categories":["前端进阶"]},{"title":"ws模块实现聊天的一些基本功能","path":"/2023/07/10/28/","content":"本篇文章难度较大哦，小伙伴们👀️本文要讲解的代码作者已上传至云仓库：https://gitee.com/xiao-zhe-is-not-lazy/chat学习本篇文章之前记得先去看:1.登录鉴权——JWT(前后端分离) | Lazychild&#39;s Blog2. 初始ws模块 | Lazychild&#39;s Blog 先写好一个基本的登录鉴权功能之前文章写过了，小伙伴们自己去看看吧👀️ 前端一共有两个界面： 登录界面 聊天室界面 到了这一步应该实现前端进行登录，后端进行token校验，成功后跳转至聊天室这个界面（只要跳转就行，后面会讲聊天室界面对于token的校验） 代码展示 登录界面代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 const autorization = response.headers.autorization autorization &amp;&amp; localStorage.setItem(&#x27;token&#x27;, autorization) return response &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;聊天室登录界面&lt;/h2&gt; &lt;div&gt;账号：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;/div&gt; &lt;div&gt;密码：&lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;登录&lt;/button&gt; &lt;script&gt; btn.onclick = function () &#123; axios.post(&#x27;http://localhost:3000/login&#x27;, &#123; username: username.value, password: password.value &#125;).then(res =&gt; &#123; if (res.data.ok) &#123; location.href = &#x27;/index&#x27; &#125; else &#123; alert(&#x27;账号或密码错误&#x27;) &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 基本的路由代码 var express = require(&#x27;express&#x27;); var jwtObj = require(&#x27;../utils/jsonwebtoken&#x27;) const mysql2 = require(&#x27;mysql2&#x27;) var router = express.Router(); /* GET home page. */ router.get(&#x27;/login&#x27;, function (req, res, next) &#123; res.type(&#x27;html&#x27;); res.render(&#x27;login&#x27;) &#125;) router.get(&#x27;/index&#x27;, function (req, res, next) &#123; res.type(&#x27;html&#x27;); res.render(&#x27;index&#x27;) &#125;) let mony, name router.post(&#x27;/login&#x27;, async function (req, res) &#123; a = &#x27;users&#x27; // 创建连接池 const config = handleConfig() const promisePool = mysql2.createPool(config).promise() let users = await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 if (users[0].length) &#123; mony = users[0][0].mony name = users[0][0].name // 将token放在header中 const token = jwtObj.sign(&#123; name, mony &#125;, &#x27;1h&#x27;) res.header(&#x27;Autorization&#x27;, token) res.send(&#123; ok: 1 &#125;) &#125; else &#123; res.send(&#123; ok: 0 &#125;) &#125; &#125;) module.exports = router; // 连接数据库的基本配置 function handleConfig() &#123; return &#123; host: &#x27;localhost&#x27;, port: 3306, user: &quot;root&quot;, password: &quot;&quot;, database: &quot;maizuo&quot;, connectLimit: 1 &#125; &#125; token加密&#x2F;解密代码 const &#123; json &#125; = require(&#x27;express&#x27;) const jwt = require(&#x27;jsonwebtoken&#x27;) const key = &#x27;maizuoc312asdpkj&#x27; //秘钥 const obj=&#123; // 加密 sign: function(data,time)&#123; const token=jwt.sign(data, key, &#123; expiresIn: time &#125;) return token &#125;, verify: function(token)&#123; try &#123; return jwt.verify(token, key) &#125; catch (error) &#123; return false &#125; &#125; &#125; module.exports=obj 各种依赖包记得下载 依赖包展示（package.json文件） &#123; &quot;name&quot;: &quot;nodeapp2-jwt&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;node ./bin/www&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;cookie-parser&quot;: &quot;~1.4.4&quot;, &quot;debug&quot;: &quot;~2.6.9&quot;, &quot;ejs&quot;: &quot;~2.6.1&quot;, &quot;express&quot;: &quot;~4.16.1&quot;, &quot;http-errors&quot;: &quot;~1.6.3&quot;, &quot;jsonwebtoken&quot;: &quot;^9.0.0&quot;, &quot;morgan&quot;: &quot;~1.9.1&quot;, &quot;mysql2&quot;: &quot;^3.3.3&quot;, &quot;ws&quot;: &quot;^8.13.0&quot; &#125; &#125; 进入主题ws模块大家之前应该就使用过了吧，这里主要是与之前的登录鉴权实现一些聊天的基本功能，比如群聊，单聊等，站长这里只讲功能，页面的美化得靠大家，直接代码展示node服务端ws代码展示(建议新建一个文件独立写ws的代码，容易维护)： const WebSocket = require(&quot;ws&quot;) const &#123; WebSocketServer &#125; = require(&quot;ws&quot;) const JWT = require(&#x27;../utils/jsonwebtoken&#x27;) const wss = new WebSocketServer(&#123; port: 8080 &#125;); wss.on(&#x27;connection&#x27;, function connection(ws, req) &#123; ws.on(&#x27;error&#x27;, console.error); // 验证token const payload = JWT.verify(req.url.split(&#x27;=&#x27;)[1]) if (payload) &#123; ws.user = payload // 通知在线用户的人数 sendAll() &#125; else &#123; ws.send(createMessage(WebSocketType.Error, null, &quot;登录已过期&quot;)) &#125; ws.on(&#x27;message&#x27;, function message(data, isBinary) &#123; // 解析前端发送过来的消息进行判断 const msgObj = JSON.parse(data) // 判断，进行逻辑处理 switch (msgObj.type) &#123; case WebSocketType.groupList: break; case WebSocketType.groupChat: wss.clients.forEach(function each(client) &#123; if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); break; case WebSocketType.singleChat: wss.clients.forEach(function each(client) &#123; if (client.user.name == msgObj.to &amp;&amp; client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); break; &#125; &#125;) // 当服务器断开时触发 ws.on(&#x27;close&#x27;, () =&gt; &#123; wss.clients.delete(ws.user) sendAll() &#125;) &#125;); const WebSocketType = &#123; Error: 0, groupList: 1, //在线人数 groupChat: 2, //群聊 singleChat: 3 //单聊 &#125; function createMessage(type, user, data) &#123; return JSON.stringify(&#123; type, user, data &#125;) &#125; // 给所有的在线用户实时发送当前的用户列表 function sendAll() &#123; wss.clients.forEach(function each(client) &#123; if (client.readyState === WebSocket.OPEN) &#123; client.send(createMessage(WebSocketType.groupList, null, JSON.stringify(Array.from(wss.clients).map(item =&gt; item.user)))) &#125; &#125;); &#125; 前端聊天室代码展示： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;聊天室&lt;/title&gt; &lt;script src=&quot;https://unpkg.com/axios@1.1.2/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;聊天室&lt;/h1&gt; &lt;input type=&quot;text&quot; class=&quot;message&quot;&gt; &lt;select name=&quot;&quot; id=&quot;onlineUsers&quot;&gt;&lt;/select&gt; &lt;button id=&quot;btn&quot;&gt;发送&lt;/button&gt; &lt;script&gt; // to字段主要是在单聊时，知道要发给谁 function createMessage(type, data, to) &#123; return JSON.stringify(&#123; type, data, to &#125;) &#125; let btn = document.querySelector(&#x27;#btn&#x27;) let message = document.querySelector(&#x27;.message&#x27;) let onlineUsers = document.querySelector(&#x27;#onlineUsers&#x27;) const WebSocketType = &#123; Error: 0, groupList: 1, //在线人数 groupChat: 2, //群聊 singleChat: 3 //单聊 &#125; const ws = new WebSocket(`ws://localhost:8080?token=$&#123;localStorage.getItem(&#x27;token&#x27;)&#125;`) ws.onopen = () =&gt; &#123; console.log(&quot;服务器已连接&quot;) &#125; ws.onmessage = (msgObj) =&gt; &#123; // 解析后端传过来的值，进行判断 let dataObj = JSON.parse(msgObj.data) switch (dataObj.type) &#123; case WebSocketType.Error: location.href = &#x27;/login&#x27; break; case WebSocketType.groupList: // 获取用户列表 onlineUsers.innerHTML =&#x27;&lt;option value=&quot;all&quot;&gt;群发&lt;/option&gt;&#x27; + JSON.parse(dataObj.data).map(item =&gt;`&lt;option value=&quot;$&#123;item.name&#125;&quot;&gt;$&#123;item.name&#125;&lt;/option&gt;`) break; //群聊 case WebSocketType.groupChat: console.log(&#x27;群聊&#x27;, dataObj) break; //单聊 case WebSocketType.singleChat: console.log(&#x27;单聊&#x27;, dataObj) break; &#125; // 发送消息 btn.onclick = function () &#123; if (onlineUsers.value == &#x27;all&#x27;) &#123; // 群发 ws.send(createMessage(WebSocketType.groupChat, message.value)) &#125;else&#123; // 单聊 ws.send(createMessage(WebSocketType.singleChat, message.value, onlineUsers.value)) &#125; &#125; &#125; ws.onerror = () =&gt; &#123; console.log(&quot;error&quot;) &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 能够看到这里的小伙伴给自己鼓鼓掌吧，未来的前端是你们的🎉️","tags":["node"],"categories":["前端进阶"]},{"title":"闲聊篇","path":"/2023/07/06/27/","content":"7月6日，下班后有感：很想说说我以前喜欢过的女生 谈谈初中她是我的同桌，额，准确来说是我的初三的同桌吧，当时老班把我和她安排到同桌的时候，真的开心了好久，她长的不高，脸上有一些雀斑，和我一个姓，当时她成绩特别好，嗯嗯，至少比我好太多了，一般都是班上前几名，我真的对学习好的女生特别有好感，但是我当时用一组词来形容（可能现在也好不到哪去吧）就是：矮、穷、挫，反正不好的标签往我身上贴就行，但是不知道是谁说我喜欢你，搞的全班皆知，除了老班，我的本意哪敢和你说我喜欢你啊，我用脚趾头都能想到，你不可能喜欢我，哎！不记得这个走漏风声的人是谁了，不然在这里非得骂你几句，当时想着只要不影响你学习，我这一辈子都不会去告诉你我喜欢你的我觉得我同桌当时被我这样的人喜欢一定很痛苦吧，在这里向你道歉了，哈哈哈 谈谈高中高一刚进来的时候，也有过许多漂亮的女同学，但是我好像对爱情的向往再也没有了兴趣😮‍💨😮‍💨，好吧，我骗人的，其实我喜欢过一个女生，她的名字中有一个和我一样，长得不高，鼻子很挺，给人一种明星的感觉，成绩不是很好，但是好像喜欢一个人，真的没有什么标准，就是一瞬间，她的某个动作，或者某个眼神，直击你的心脏，哈哈哈哈，我这样描述，好肉麻，反正我知道她就是我喜欢的女生了，但是表白这种行为，在我这里就好比让我去摘天上的月亮这么难，可能受我原生家庭的影响吧，你别看我平时各种搞笑，其实我的自卑是刻在骨子里的，就是现在，我其实也没有自信，但是可能比以前好了（自我感觉）所以一直没有和她说后来分班了，其实我一直喜欢着她，直到现在毕业，我承认还是会想起她，但是还是没有向她袒露心声可能有些事情错过了就是一辈子，有些人一转身就是永远吧，我只能默默祝福你了呢，哈哈哈哈 谈谈大学好像有点喝醉了。。。头好晕，不写了","tags":["生活闲聊"]},{"title":"初始ws模块","path":"/2023/06/01/26/","content":"websocket协议Webscoket是Web浏览器和服务器之间的一种全双工通信协议 ，其中WebSocket协议由IETF定为标准，WebSocket API由W3C定为标准。 一旦Web客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。 通信过程中，可互相发送JSON、XML、HTML或图片等任意格式的数据。我们将基于这个协议，实现聊天室的功能 下载ws模块npm i ws node服务端代码const WebSocket = require(&quot;ws&quot;) const &#123; WebSocketServer &#125; = require(&quot;ws&quot;) const wss = new WebSocketServer(&#123; port: 8080 &#125;); wss.on(&#x27;connection&#x27;, function connection(ws) &#123; ws.on(&#x27;error&#x27;, console.error); ws.on(&#x27;message&#x27;, function message(data, isBinary) &#123; wss.clients.forEach(function each(client) &#123; if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123; client.send(data, &#123; binary: isBinary &#125;); &#125; &#125;); &#125;); ws.send(&quot;欢迎进入聊天室&quot;) &#125;); 前端代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;聊天室&lt;/h1&gt; &lt;script&gt; var ws = new WebSocket(&quot;ws://localhost:8080&quot;) ws.onopen = ()=&gt;&#123; console.log(&quot;连接成功&quot;) &#125; ws.onmessage = (msgObj)=&gt;&#123; console.log(msgObj.data) &#125; ws.onerror = ()=&gt;&#123; console.log(&quot;error&quot;) &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 测试打开两个前端页面（客户端），在一个客户端控制台输入ws.send(“hello”) 在另一个客户端的控制台就能收到hello这个消息了， 这里其实已经相当一个群聊功能了，只是聊天的用户都是互相不知道的，接下来作者会使用登录验证，让所有用户能够彼此能够认识 让我们实现私聊功能吧！！","tags":["node"],"categories":["前端进阶"]},{"title":"hexo博客项目部署至vercel","path":"/2023/05/28/25/","content":"部署过程太过于繁琐，作者真的好懒，不想写，这里就大概描述一下我的部署过程吧 注册github账号GitHub 因为作者之前用的都是Gitee，因为vercel的部署不能用Gitee了，所有注册github是必要的，并且作者悄悄的告诉你，github才是真正的源码市场，可以学到很多大佬的源码 下载fastgithub很多人访问github都很难进去，这是当然，毕竟是国外的网站，这里可以自己翻墙，但是大多数翻墙软件都需要money👀️ ，这里就不得不介绍另外一种软件了——fastgithub不多说，用它之后腰不疼，腿也不疼了，哈哈哈哈😄 直接搜索即可下载，网上有使用教程，作者真的很懒，不想多说 修改hexo下面的_config.yml文件因为作者之前用的是Gitee，你如果之前用的是github请省略这个步骤这一步也不想多说，主要是改变了云仓库的地址，直接展示： deploy: type: git repo: 自己仓库的地址 branch: main 注册vercel账号https://vercel.com/ 这里最最最最最好使用github账号登录即可，方便后续代码的上传更新，总而言之，很方便注册成功后点击新建一个项目（不要跟我说新建项目也不会，实在不行请留言给我），之后会出现： 点击import导入自己github的项目即可🎉️最后经过一系列的操作就会成功部署，然后你很开心的打开vercel给你分配的域名发现根本无法访问，哎！！，这里注意vercel给的域名在国内是访问不了的，这里就需要接下来的步骤了 购买域名这里自己随便找个网站购买域名（其实挺麻烦，购买成功后，找到控制台，对域名进行解析，解析@，www这两个即可，这里需要绑定ip地址，可以在vercel的设置域名那里找到（具体的我也忘了，反正可以在vercel中找到👀️ ） vercel的配置创建好项目后点击： 进入后再点击： 这里接着的操作请使用浏览器自带的翻译功能，一步步的配置自己的域名，写起来挺麻烦，但是操作起来挺简单，这里配置成功后需要有一个等待时间他会不断的刷新，然后报错，等等他就好了 最后变成这样你就成功了🎉️ ： 最后一步修改hexo下面的_config.yml文件url: 自己网站的域名 root: / 记得重新上传代码","tags":["hexo"],"categories":["魔改"]},{"title":"留言板模块与文章评论开启","path":"/2023/05/24/24/","content":"注册LeanCloud账号注册LeanCloud账号是为了给评论的数据提供云存储 首先来到LeanCloud的首页:https://www.leancloud.cn/，点击右上角的控制台，按照指引进行注册即可 创建应用注册完成后,进行登录会进入这个页面： 点击创建应用，随后填写一些应用的基本信息后你的应用就创建成功啦🎉️ 创建留言板页面hexo new page message 修改其目录下的index.md为index.ejs,增添如下内容： --- title: 留言板 --- &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&#x27;//unpkg.com/valine/dist/Valine.min.js&#x27;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; new Valine(&#123; el: &#x27;#vcomments&#x27;, appId: &#x27;你的AppID&#x27;, appKey: &#x27;你的AppKey&#x27;, placeholder: &#x27;欢迎大家来到lazychild,如果有什么想说的话，请留言给作者哦，作者会尽量快速回复大家的哦😜😜，注意邮箱一定不能写错哦，不然你就收不到作者的回复了&#x27;, avatar: &#x27;wavatar&#x27;, pageSize: 4, requiredFields: [&#x27;mail&#x27;] &#125;) &lt;/script&gt; &lt;/html&gt; AppID与AppKey的设置：创建好LeanCloud应用后，找到左边设置的应用凭证即可找到自己的AppID与AppKey 这里的评论系统使用的是基于基于LeanCloud的快速、简洁且高效的无后端评论系统————Valine，更多的Valine的配置请自主学习，请参考https://valine.js.org/configuration.html👀️ 增加导航栏菜单最后自己在主题配置文件_config.yml中配置即可这是我的： menu: 首页: / || icon-shouye2 文章 || icon-xiewenzhang: 归档: /archives/ || icon-guidang 标签: /tags/ || icon-biaoqian 分类: /categories/ || icon-fenlei 统计: /statistics/ || icon-tongjitu 友链: /link/ || icon-LINKS 我的: /about/ || icon-gerenzhongxin_wodediqu 留言板: /message/ || icon-liuyanban icon图标是我自己引入的，你不能照搬哦👀️ ，具体的引入方法请参考菜单栏多色图标 | Lazychild&#39;s Blog (gitee.io)到这里你就已经完成了留言板模块了🎉️ 文章评论功能的开启在此之前小伙伴们肯定已经创建了一个LeanCloud应用了，这里请小伙伴们再创建一个LeanCloud应用，用来存放文章评论 创建成功后，找到主题配置文件_config.yml,修改： comments: # Up to two comments system, the first will be shown as default # Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo/Giscus/Remark42/Artalk use: Valine text: true # Display the comment name next to the button # lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport. # If you set it to true, the comment count will be invalid lazyload: true count: true # Display comment count in post&#x27;s top_img card_post_count: true # Display comment count in Home Page valine: appId: 你的AppID appKey: 你的AppKey avatar: wavatar # gravatar style https://valine.js.org/#/avatar serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in) bg: # valine background visitor: false option: bug解决发现了一个bug，发现很多不需要用到评论的地方也有了评论功能，解决办法：在自定义的js文件中增加如下内容： // 删除多余的评论板块 // 解决留言板模块2次渲染问题导致评论区出现了2次 if(path[2] == &#x27;message&#x27; || path[2] == &#x27;about&#x27; || path[2] == &#x27;tags&#x27; || path[2] == &#x27;categories&#x27; || path[2] == &#x27;statistics&#x27; || path[2] == &#x27;link&#x27;)&#123; var postComment = document.querySelector(&#x27;#post-comment&#x27;) &amp;&amp; postComment.remove() &#125;","tags":["butterfly"],"categories":["魔改"]},{"title":"增加一个统计模块","path":"/2023/05/23/23/","content":"canvasJS的使用这是前端的一个画各种表格的插件，十分好用哦！！官网地址在https://canvasjs.com/ 新建一个js文件// 将文章日期和数量存本地 var achivesDate = document.querySelectorAll(&#x27;.card-archive-list-date&#x27;); var achivesDateNumber = document.querySelectorAll(&#x27;.card-archive-list-count&#x27;); var achivesDateArr = []; var achivesDateNumberArr = []; if (achivesDate.length) &#123; for (var i = 0; i &lt; achivesDate.length; i++) &#123; achivesDateArr.push(achivesDate[i].innerHTML); achivesDateNumberArr.push(achivesDateNumber[i].innerHTML) &#125;; localStorage.setItem(&#x27;achivesDateArr&#x27;, achivesDateArr); localStorage.setItem(&#x27;achivesDateNumberArr&#x27;, achivesDateNumberArr) &#125; // 将分类信息存入本地 var cardCategoryListCountArr = [] var cardCategoryListNameArr = [] var cardCategoryListCount = document.querySelectorAll(&#x27;.card-category-list-count&#x27;) var cardCategoryListName = document.querySelectorAll(&#x27;.card-category-list-name&#x27;) if (cardCategoryListCount.length) &#123; for (var i = 0; i &lt; cardCategoryListCount.length; i++) &#123; cardCategoryListCountArr.push(cardCategoryListCount[i].innerHTML) cardCategoryListNameArr.push(cardCategoryListName[i].innerHTML) &#125; localStorage.setItem(&#x27;card-category-list-count&#x27;, cardCategoryListCountArr) localStorage.setItem(&#x27;card-category-list-name&#x27;, cardCategoryListNameArr) &#125; 记得引入至主题配置文件_config.yml中 新建页面在根目录source目录下新建一个目录statistics，在其下面新建index.ejs文件增加如下内容即可： --- title: 统计 --- &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://www.lazychild.fun/js/canvasJS.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;chartContainer&quot; style=&quot;height: 300px; width: 95%;&quot;&gt;&lt;/div&gt; &lt;div id=&quot;chartContainer1&quot; style=&quot;height: 300px; width: 95%;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 从本地获取文章数量和日期 var achivesDateArr = localStorage.getItem(&#x27;achivesDateArr&#x27;).split(&#x27;,&#x27;).reverse() var achivesDateNumberArr = localStorage.getItem(&#x27;achivesDateNumberArr&#x27;).split(&#x27;,&#x27;).reverse() var cardCategoryListName = localStorage.getItem(&#x27;card-category-list-name&#x27;).split(&#x27;,&#x27;) var cardCategoryListCount = localStorage.getItem(&#x27;card-category-list-count&#x27;).split(&#x27;,&#x27;) // 文章 var chart = new CanvasJS.Chart(&quot;chartContainer&quot;, &#123; title: &#123; text: &quot;归档&quot; &#125;, data: [ &#123; dataPoints: [] &#125; ] &#125;); let initX = 1 for (var i = 0; i &lt; achivesDateArr.length; i++) &#123; chart.options.data[0].dataPoints.push(&#123; x: initX, y: parseInt(achivesDateNumberArr[i]), label: achivesDateArr[i] &#125;) initX++ &#125; chart.render(); // 分类 var chart1 = new CanvasJS.Chart(&quot;chartContainer1&quot;, &#123; legend: &#123; maxWidth: 350, itemWidth: 120 &#125;, title: &#123; text: &quot;分类&quot; &#125;, data: [ &#123; type: &quot;pie&quot;, showInLegend: true, legendText: &quot;&#123;indexLabel&#125;&quot;, dataPoints: [] &#125; ] &#125;); for (var i = 0; i &lt; cardCategoryListName.length; i++) &#123; chart1.options.data[0].dataPoints.push(&#123; y: parseInt(cardCategoryListCount[i]), indexLabel: cardCategoryListName[i] &#125;) &#125; chart1.render(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 最后在增加一个导航栏menu: 统计: /statistics/ || icon-tongjitu","tags":["butterfly"],"categories":["魔改"]},{"title":"vue项目打包部署至云仓库","path":"/2023/05/21/22/","content":"创建云仓库这里不做过多解释，网上都有教程，作者用的是Gitee创建好后就可以将自己的项目上传了 配置vue.config.js文件module.exports = &#123; publicPath: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/仓库根目录的名字&#x27; : &#x27;/&#x27; , productionSourceMap: false, &#125; 修改.gitignore文件删除文件里dist这个字段修改此文件的目的是执行push命令时能上传dist目录， vue项目打包npm run build 打包成功后会出现一个dist目录 使用git命令上传至云仓库这里还不会的建议先去看看教程 开启Gitee Pages先将远程仓库开源，然后在服务选项那里有一个Gitee Pages点进去开启就行(必须设置为开源哦)记得将部署的目录改成dist","tags":["vue"],"categories":["前端进阶"]},{"title":"Electron与vue的组合","path":"/2023/05/20/21/","content":"本篇文章出自：https://blog.csdn.net/honest1120110/article/details/116643392 创建vue项目vue create myapp 安装electron环境Electron安装 npm install electron Vue项目添加Electron-builder打包工具 vue add electron-builder 提示：如果出现electron安装失败，或者后面使用electron-builder打包时，出现从github down包失败，请设置electron镜像。 npm config edit 使用该命令会弹出npm的配置文档，将以下类容复制到文件末尾。 electron_mirror=https://npm.taobao.org/mirrors/electron/ electron-builder-binaries_mirror=https://npm.taobao.org/mirrors/electron-builder-binaries/ 测试npm run electron:serve 运行成功后会自动弹出一个窗口，这就是你的app了，你成功了吗？ 替换客户端图标进入项目路径，查看是否存在vue.config.js同名文件（好像是vue3没有，vue2会有），没有则创建一个空文件。编辑vue.config.js文件 module.exports = &#123; pluginOptions: &#123; electronBuilder: &#123; builderOptions: &#123; &quot;appId&quot;: &quot;com.example.app&quot;, &quot;productName&quot;: &quot;aDemo&quot;,//项目名，也是生成的安装文件名，即aDemo.exe &quot;copyright&quot;: &quot;Copyright © 2023&quot;,//版权信息 &quot;directories&quot;: &#123; &quot;output&quot;: &quot;./dist&quot;//输出文件路径，之前编译的默认是dist_electron &#125;, &quot;win&quot;: &#123; &quot;icon&quot;: &quot;Demo.ico&quot;//这里注意配好图标路径 &#125; // options placed here will be merged with default configuration and passed to electron-builder &#125; &#125; &#125; &#125; electron-builder的更多配置：&quot;build&quot;: &#123; &quot;productName&quot;:&quot;xxxx&quot;, //项目名 这也是生成的exe文件的前缀名 &quot;appId&quot;: &quot;com.xxx.xxxxx&quot;, //包名 &quot;copyright&quot;:&quot;xxxx&quot;, //版权信息 &quot;directories&quot;: &#123; //输出文件夹 &quot;output&quot;: &quot;build&quot; &#125;, &quot;nsis&quot;: &#123; //nsis相关配置，打包方式为nsis时生效 &quot;oneClick&quot;: false, // 是否一键安装 &quot;allowElevation&quot;: true, // 允许请求提升，如果为false，则用户必须使用提升的权限重新启动安装程序。 &quot;allowToChangeInstallationDirectory&quot;: true, // 允许修改安装目录 &quot;installerIcon&quot;: &quot;./build/icons/aaa.ico&quot;, // 安装图标 &quot;uninstallerIcon&quot;: &quot;./build/icons/bbb.ico&quot;, //卸载图标 &quot;installerHeaderIcon&quot;: &quot;./build/icons/aaa.ico&quot;, // 安装时头部图标 &quot;createDesktopShortcut&quot;: true, // 创建桌面图标 &quot;createStartMenuShortcut&quot;: true, // 创建开始菜单图标 &quot;shortcutName&quot;: &quot;xxxx&quot;, // 图标名称 &quot;include&quot;: &quot;build/script/installer.nsh&quot;, // 包含的自定义nsis脚本 &#125;, &quot;publish&quot;: [ &#123; &quot;provider&quot;: &quot;generic&quot;, // 服务器提供商，也可以是GitHub等等 &quot;url&quot;: &quot;http://xxxxx/&quot; // 服务器地址 &#125; ], &quot;win&quot;: &#123; &quot;icon&quot;: &quot;build/icons/aims.ico&quot;, &quot;target&quot;: [ &#123; &quot;target&quot;: &quot;nsis&quot;, //使用nsis打成安装包，&quot;portable&quot;打包成免安装版 &quot;arch&quot;: [ &quot;ia32&quot;, //32位 &quot;x64&quot; //64位 ] &#125; ] &#125;, &quot;mac&quot;: &#123; &quot;icon&quot;: &quot;build/icons/icon.icns&quot; &#125;, &quot;linux&quot;: &#123; &quot;icon&quot;: &quot;build/icons&quot; &#125; &#125; 打包(生成桌面app)npm run electron:build","tags":["Electron"],"categories":["桌面App"]},{"title":"首页轮播功能的实现","path":"/2023/05/16/20/","content":"本篇文章参考https://akilar.top/posts/8e1264d1/这里只是做个记录 在博客根目录安装插件npm install hexo-butterfly-swiper --save 更改根目录下的_config.yml## 增加首页的轮播功能 # hexo-butterfly-swiper # see https://akilar.top/posts/8e1264d1/ swiper: enable: true # 开关 priority: 5 #过滤器优先权 enable_page: all # 应用页面 timemode: date #date/updated layout: # 挂载容器类型 type: id name: recent-posts index: 0 default_descr: 再怎么看我也不知道怎么描述它的啦！ swiper_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css #swiper css依赖 swiper_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js #swiper js依赖 custom_css: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css # 适配主题样式补丁 custom_js: https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js # swiper初始化方法 增加文章的一个配置项swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前","tags":["hexo"],"categories":["魔改"]},{"title":"登录鉴权——JWT(前后端分离)","path":"/2023/05/13/19/","content":"本篇文章适合有node基础的同学们哦！这篇文章记录了做的仿卖座电影的一个登录功能我用到的技术 express（基于node的后端） 数据库（我用的是Wampserver64） vue2 （前端） axios mysql2 jsonwebtoken 创建后台项目express --view=ejs nodeApp 下载依赖npm i 测试能否成功访问开启本地服务器： node ./bin/www 访问http://localhost:3000 创建数据库打开Wampserver64, 如果是绿色则启动成功 后端根目录下载mysql2npm i mysql2 前端下载axiosnpm i axios 后端路由var express = require(&#x27;express&#x27;); const mysql2 = require(&#x27;mysql2&#x27;) var router = express.Router(); /* GET home page. */ router.post(&#x27;/login&#x27;,async function(req, res)&#123; a=&#x27;users&#x27; // 创建连接池 const config=handleConfig() const promisePool=mysql2.createPool(config).promise() let users=await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 console.log(users[0]) if(users[0].length)&#123; res.send(&#123;ok:1&#125;) &#125;else&#123; res.send(&#123;ok:0&#125;) &#125; &#125;) module.exports = router; // 连接数据库的基本配置 function handleConfig()&#123; return&#123; host:&#x27;localhost&#x27;, port:3306, user:&quot;root&quot;, password:&quot;&quot;, database:&quot;maizuo&quot;, connectLimit:1 &#125; &#125; express设置跨域//设置允许跨域访问该服务. app.all(&#x27;*&#x27;, function (req, res, next) &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;*&#x27;); res.header(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;); next(); &#125;); 前端请求代码axios.post(&#x27;http://localhost:3000/login&#x27;,&#123; username:values.username, password:values.password &#125;).then(res=&gt;&#123; console.log(res.data) &#125;).catch(err=&gt;&#123; console.log(err) &#125;) 到这里就完成最基本的登录鉴权了，接下来进入主题 下载jsonwebtokennpm i jsonwebtoken 导入const jwt = require(&#x27;jsonwebtoken&#x27;) 创建一个公共js文件此文件用来存放jsonwebtoken的加密与解密函数 const &#123; json &#125; = require(&#x27;express&#x27;) const jwt = require(&#x27;jsonwebtoken&#x27;) const key = &#x27;maizuoc312asdpkj&#x27; //秘钥 const obj=&#123; // 加密 sign: function(data,time)&#123; const token=jwt.sign(data, key, &#123; expiresIn: time &#125;) return token &#125;, verify: function(token)&#123; try &#123; return jwt.verify(token, key) &#125; catch (error) &#123; return false &#125; &#125; &#125; module.exports=obj 更改express的路由router.post(&#x27;/login&#x27;,async function(req, res)&#123; a=&#x27;users&#x27; // 创建连接池 const config=handleConfig() const promisePool=mysql2.createPool(config).promise() let users=await promisePool.query(`SELECT * FROM $&#123;a&#125; WHERE name=&#x27;$&#123;req.body.username&#125;&#x27; AND password=&#x27;$&#123;req.body.password&#125;&#x27;`) //sql语句 if(users[0].length)&#123; mony=users[0][0].mony name=users[0][0].name // 将token放在header中 const token=jwtObj.sign(users[0][0],&#x27;1h&#x27;) res.header(&#x27;Autorization&#x27;, token) res.send(&#123; ok:1 &#125;) &#125;else&#123; res.send(&#123;ok:0&#125;) &#125; &#125;) 使用axios拦截器// 添加请求拦截器 axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;); // 添加响应拦截器 axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); 到这里会发现可能拿不到自定义头部在设置跨越那里加上 res.header(&#x27;Access-Control-Expose-Headers&#x27;, &#x27;Autorization&#x27;); 意思就是允许头部信息Autorization的显示 拿到头部并保存本地axios.interceptors.response.use(function (response) &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 const autorization = response.headers.autorization autorization &amp;&amp; localStorage.setItem(&#x27;token&#x27;,autorization) return response &#125;, function (error) &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error); &#125;); 每次向后端请求都带上tokenaxios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 const token=localStorage.getItem(&#x27;token&#x27;) config.headers.Authorization = `Bearer $&#123;token&#125;` return config &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;); 后端进行接收前端发过来的token进行校验const examineToken = jwtObj.verify(req.headers.authorization.split(&#x27; &#x27;)[1]) 然后就可以对校验的结果进行自己相关的逻辑处理 总结就是前端输入登录账号与密码，后端进行判断，如果成功，就向前端通过header发送token的值前端接收到token后就存在本地，然后每次向后端发送请求时就带上这个token，后端进行校验后返回值给前端，前端根据后端返回的值再进行业务逻辑的一个处理","tags":["node"],"categories":["前端进阶"]},{"title":"登录鉴权——Cookie与Session(适合后台嵌套模板)","path":"/2023/05/12/18/","content":"本篇文章适合有node基础的同学们哦！我用到的技术 express（基于node的后端） json-server 创建项目express --view=ejs nodeApp 下载依赖npm i 测试能否成功访问开启本地服务器： node ./bin/www 访问http://localhost:3000 创建一个登录界面在views目录下（ejs）代码如下 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;卖座后台登录界面：&lt;/h1&gt; &lt;div&gt; &lt;span&gt;用户:&lt;/span&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; id=&quot;mypassword&quot;&gt; &lt;/div&gt; &lt;div&gt;&lt;button id=&quot;btn&quot;&gt;login&lt;/button&gt;&lt;/div&gt; &lt;script&gt; btn.onclick = function () &#123; // console.log(username.value,mypassword.value) fetch(&quot;http://localhost:3001/login&quot;, &#123; method: &#x27;POST&#x27;, headers: &#123; &quot;content-type&quot;: &quot;application/json&quot; &#125;, body: JSON.stringify(&#123; username: username.value, password: mypassword.value &#125;) &#125;).then(res =&gt; res.json()).then(res =&gt; &#123; if(res.ok===1)&#123; alert(&quot;登录成功&quot;) location.href = &#x27;http://localhost:3001/index&#x27; &#125;else&#123; alert(&#x27;登录失败&#x27;) &#125; &#125;) &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 创建一个登录成功后的跳转界面（ejs）创建完后记得写好接口，渲染这个ejs页面 后台路由代码这里使用fetch一直报错，我不知道什么原因，后面使用了axios(好用，爱用，哈哈哈哈！！) 下载json-servernpm i -g json-server 开启json-server服务这里要注意:express项目与json-server的默认端口都是3000,建议修改express的端口（容易改），在bin目录下修改www即可在你的express项目下创建user.jsonuser.json的内容如下： &#123; &quot;users&quot;:[ &#123; &quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;123&quot;, &quot;mony&quot;:&quot;567&quot; &#125;, &#123; &quot;username&quot;:&quot;test&quot;, &quot;password&quot;:&quot;1234&quot;, &quot;mony&quot;:&quot;11&quot; &#125; ] &#125; 执行 json-server --watch user.json 这样你的user.json这个文件就在json-server的监听下了 下载axios(一种请求方式)npm i axios var express = require(&#x27;express&#x27;); var axios = require(&#x27;axios&#x27;) var router = express.Router(); /* GET home page. */ router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;login&#x27;); &#125;); router.post(&#x27;/login&#x27;,function(req, res, next) &#123; let dataLength axios.get(&quot;http://localhost:3000/users&quot;).then(re=&gt;&#123; dataLength=re.data.length for(var i=0;i&lt;dataLength;i++)&#123; if(re.data[i].username==req.body.username &amp;&amp; re.data[i].password==req.body.password)&#123; res.send(&#123;ok:1&#125;) return &#125; &#125; if(i===dataLength)&#123; res.send(&#123;ok:0&#125;) &#125; &#125;) &#125;) module.exports = router; 这里作者只是讲一下登录鉴权的一个过程，就没有创建数据库了，正常的应该在路由中去获取数据库的内容，验证前端提交用户名与密码是否正确,作者这里就使用json-server模拟了一下后台数据 到这里最简单的一个登录鉴权就已经写完了但是现在好像不登录直接输入后台url地址也能访问，现在就要进入本篇文章的主题了，使用Express中间件 Express-session 安装express-session中间件npm i express-session 配置app.js文件导入express-sessionconst session = require(&#x27;express-session&#x27;) 配置session（记得放在express的路由之前）// 设置session app.use(session(&#123; secret: &#x27;asdjlzxco&#x27;, //秘钥 resave: true, //重新设置session后，就会重新开始计算过期时间 saveUninitialized: true, //一开始访问就会生成一个无效的cookie, cookie: &#123; secure: false, maxAge: 1000*60*60 &#125;, name: &#x27;maiZuo&#x27; &#125;)) 修改post请求的路由(设置req.session.username的值) router.post(&#x27;/&#x27;,function(req, res, next) &#123; let dataLength axios.get(&quot;http://localhost:3000/users&quot;).then(re=&gt;&#123; dataLength=re.data.length for(var i=0;i&lt;dataLength;i++)&#123; if(re.data[i].username==req.body.username &amp;&amp; re.data[i].password==req.body.password)&#123; req.session.username = re.data[i].username res.send(&#123;ok:1&#125;) return &#125; &#125; if(i===dataLength)&#123; res.send(&#123;ok:0&#125;) &#125; &#125;) &#125;) 创建中间件对接口进行拦截app.use((req,res,next)=&gt;&#123; // 解决重定向次数过多，只要是关于登录有关的接口就放行 if(req.url.includes(&#x27;login&#x27;))&#123; next() return &#125; if(req.session.username)&#123; //重新设置session，刷新过期时间 req.session.mydate = Date.now() next() &#125;else&#123; // 重定向到登录界面 res.redirect(&#x27;http://localhost:3001/login&#x27;) &#125; &#125;) 整个app.js代码var createError = require(&#x27;http-errors&#x27;); var express = require(&#x27;express&#x27;); const session = require(&#x27;express-session&#x27;) var path = require(&#x27;path&#x27;); var cookieParser = require(&#x27;cookie-parser&#x27;); var logger = require(&#x27;morgan&#x27;); var loginRouter = require(&#x27;./routes/login&#x27;); var usersRouter = require(&#x27;./routes/users&#x27;); var app = express(); // view engine setup app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;)); app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;); app.use(logger(&#x27;dev&#x27;)); app.use(express.json()); app.use(express.urlencoded(&#123; extended: false &#125;)); app.use(cookieParser()); app.use(express.static(path.join(__dirname, &#x27;public&#x27;))); // 设置session app.use(session(&#123; secret: &#x27;asdjlzxco&#x27;, //秘钥 resave: true, //重新设置session后，就会重新开始计算过期时间 saveUninitialized: true, //一开始访问就会生成一个无效的cookie, cookie: &#123; secure: false, maxAge: 1000*60*60 &#125;, name: &#x27;maiZuo&#x27; &#125;)) // 中间件对接口进行拦截 app.use((req,res,next)=&gt;&#123; // 解决重定向次数过多，只要是关于登录有关的接口就放行 if(req.url.includes(&#x27;login&#x27;))&#123; next() return &#125; if(req.session.username)&#123; //重新设置session，刷新过期时间 req.session.mydate = Date.now() next() &#125;else&#123; // 重定向到登录界面 res.redirect(&#x27;http://localhost:3001/login&#x27;) &#125; &#125;) app.use(&#x27;/login&#x27;, loginRouter); //登录界面的路由 app.use(&#x27;/&#x27;, usersRouter); //登录成功后界面的路由 // catch 404 and forward to error handler app.use(function(req, res, next) &#123; next(createError(404)); &#125;); // error handler app.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&#x27;env&#x27;) === &#x27;development&#x27; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&#x27;error&#x27;); &#125;); module.exports = app; 到这一步，伙伴们你们已经实现了一个登录鉴权功能了，是不是很简单呢！！登出功能的实现在登录成功后的界面写一个退出按钮&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;卖座后台&lt;/h1&gt; &lt;div&gt;&lt;button id=&quot;btn&quot;&gt;退出登录&lt;/button&gt;&lt;/div&gt; &lt;script&gt; btn.onclick=function()&#123; fetch(&#x27;http://localhost:3001/exit&#x27;).then(res=&gt;res.json()).then(res=&gt;&#123; if(res.ok===1)&#123; location.href = &#x27;./login&#x27; &#125;else&#123; alert(&quot;退出失败&quot;) &#125; &#125;) &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 后台退出的接口router.get(&#x27;/exit&#x27;, function(req, res, next) &#123; req.session.destroy() res.send(&#123;ok:1&#125;) &#125;); 总结呼！终于写完了，这种方法的弊端还是很多的，一旦登录用户一多，后台内存不断变大，容易导致后台直接奔溃，当然session可以存数据库，但是流量一大对数据库的压力也不小，所以也有另外一种登录鉴权方案——————JWT方案","tags":["node"],"categories":["前端进阶"]},{"title":"Electron的初次认识","path":"/2023/05/10/17/","content":"什么是Electron 简单的讲就是，使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架， 这篇博客将介绍Electron的最基本的使用—–打包自己的博客变成桌面App 创建一个文件夹 初始化，也就是记录版本与使用的依赖包 npm init 将项目导入 Forge（注意兼容性）npm install --save-dev @electron-forge/cli npx electron-forge import 这一步可能会出现node版本过高的错误，建议降低node版本（网上有很多教程），使其可以兼容Electron，注意node版本降低后，要重新全局安装npm哦！！ 安装成功后package.json会出现以下内容： &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron-forge start&quot;, &quot;package&quot;: &quot;electron-forge package&quot;, &quot;make&quot;: &quot;electron-forge make&quot; &#125;, 建立一个js文件名字要与package.json这个相同 &quot;main&quot;: &quot;index.js&quot;, 将以下内容写入index.js中 const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;) const path = require(&#x27;path&#x27;) function createWindow () &#123; const win = new BrowserWindow(&#123; &lt;!-- 更改窗口尺寸--&gt; width: 1000, height: 800, webPreferences: &#123; preload: path.join(__dirname, &#x27;preload.js&#x27;) &#125; &#125;) win.loadURL(&#x27;自己博客的地址&#x27;) &#125; app.whenReady().then(() =&gt; &#123; createWindow() app.on(&#x27;activate&#x27;, () =&gt; &#123; if (BrowserWindow.getAllWindows().length === 0) &#123; createWindow() &#125; &#125;) &#125;) app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit() &#125; &#125;) 将win.loadURL的地址写上自己博客的即可 执行 npm start 可以看效果 更改图标修改forge.config.js的内容 const path = require(&#x27;path&#x27;) module.exports = &#123; packagerConfig: &#123; // 自定义图标 icon: path.join(__dirname, &#x27;./favicon.ico&#x27;) &#125;, rebuildConfig: &#123;&#125;, makers: [ &#123; name: &#x27;@electron-forge/maker-squirrel&#x27;, config: &#123;&#125;, &#125;, &#123; name: &#x27;@electron-forge/maker-zip&#x27;, platforms: [&#x27;darwin&#x27;], &#125;, &#123; name: &#x27;@electron-forge/maker-deb&#x27;, config: &#123;&#125;, &#125;, &#123; name: &#x27;@electron-forge/maker-rpm&#x27;, config: &#123;&#125;, &#125;, ], &#125;; 生成桌面应用执行 npm run make 出现out文件夹，打开里面的.exe文件即可注意ico的尺寸必须是256*256的，不然设置不上去，然后ico图标由于缓存可能会有延迟 我的博客的压缩文件地址https://gitee.com/xiao-zhe-is-not-lazy/lazychild-zip","tags":["Electron"],"categories":["桌面App"]},{"title":"面试题-1（来自b站千峰教育）","path":"/2023/05/04/16/","content":"rem em vw vw 百分比区别 相同点： rem，em，vw，vh，vw属于前端开发除了px单位之外的另外几种单位取值；但是具体含义存在区别 不同点： px：是像素单位，属于绝对单位，是一个具体的大小 rem：相对于根元素进行设置 em：如果自身有字体大小的设置，那么就相对于自身字体大小设置，如果自身没有字体大小设置，那么就相当于父元素进行设置。 vw：1vw相当于浏览器窗口宽度的百分之一 vh：1vh相当于浏览器窗口高度的百分之一 百分比：相对于父元素宽度或者高度的百分之几 注意：vw和vh是视口可以观看的区域的大小；如果没有滚动条的话，则宽度设置成100vw和100%的时候实现的效果一直；如果有滚动的话，则100vw中不是包括滚动条的，100%是包括滚动条的距离的 &lt;!--注意里面的代码解释说明--&gt; &lt;style&gt; *&#123;margin:0;padding:0&#125; html,body&#123; height: 100%; &#125; .box1&#123; width: 100%; height:500px; background-color: red; &#125; .box2&#123; width: 100vw; height:500px; background-color: green; &#125; &lt;/style&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt; 750的设计图，20px为多少rem首先设计图是UI设计提供给前端开发工程师的设计稿，750的设计图出自于手机屏幕为375px*667px的iphone678手机屏幕的设计稿，这里也可以称之为2倍图。20px的字体大小涉及到了单位的转换，页面中默认的字体大小为16px，那么此时的1rem &#x3D; 16px;那么20px通过计算得出公式 1rem &#x3D; 16px; ?rem &#x3D; 20px; 得出结果为:1.25rem 扩展1：因为他的设备像素比（dpr&#x3D;物理像素&#x2F;CSS像素）是2；dpr是一个固定的比值；不同的手机型号比值不应：物理像素：可以理解成你ps里面测量的距离的大小CSS像素：你编写开发代码的时候CSS里面给定的像素值；dpr固定值如下如： app怎么做适配的 基于手机系统开发的app(原生Android&#x2F;IOS) 另外一种是webapp 设置以下标签：&lt;meta content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;&quot; name=&quot;viewport&quot; /&gt; 具体的含义为：app完成的页面的宽度等于设备的宽度，页面的缩放比例为1.0，不允许最大缩放； 使用媒体查询和响应式做适配 使用媒体查询检测设备屏幕的大小改变布局样式，但是成本耗费比较大，不易操作 使用单位自己单位中经常使用的封装好的flexble.js文件做适配 封装好的flexble.js文件文件可以做到适配，并且原理是已经封装好的视口和设备像素比基于webapp开发 bfc是什么，清楚浮动的原理 BFC含义： 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域 BFC触发条件： 根元素 float属性不为none（脱离文档流） position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inine-flex overflow不为visible BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠（按照最大margin值设置） 每个元素的margin box的左边， 与包含块border box的左边相接触 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 计算BFC的高度时，浮动元素也参与计算 boder实现0.5像素实现方法：CSS3有缩放的属性，我们可以利用这个属性，缩小50%的1px的边框，来实现这个功能代码如下： &lt;div class=&quot;border3&quot;&gt; &lt;div class=&quot;content&quot;&gt;伪类设置的边框&lt;/div&gt; &lt;/div&gt; &lt;style&gt; *&#123; margin:0;padding:0 &#125; .border3&#123; position: relative; &#125; .border3:before&#123; content: &#x27;&#x27;; position: absolute; width: 200%; height: 200%; border: 1px solid red; transform-origin: 0 0; transform: scale(0.5, 0.5); box-sizing: border-box; &#125; &lt;/style&gt; 场景题（两个盒子，左边固定宽，右边自适应，你能想到几种方法） 公共HTML代码部分 &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; 方法一：float来和BFC实现 &lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; &#125; .left &#123; width: 200px; height: 100%; background: red; float: left; &#125; .right &#123; height: 100%; background: pink; overflow: hidden; &#125; &lt;/style&gt; 方法二：absolute定位和margin值实现 &lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; &#125; .left &#123; width: 200px; height: 100%; background: red; position: absolute; &#125; .right &#123; height: 100%; background: pink; margin-left: 200px; &#125; &lt;/style&gt; 方法三：calc(100% - 固定内容的宽度) 用calc函数动态计算数值 &lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; &#125; .left &#123; width: 200px; height: 100%; background: red; float: left; &#125; .right &#123; height: 100%; background: pink; float: left; width: calc(100% - 200px); &#125; &lt;/style&gt; 方法四：flex布局轻松搞定 &lt;style&gt; .content &#123; border: 1px solid #000; height: 800px; padding: 20px; display: flex; &#125; .left &#123; width: 200px; height: 100%; background: red; &#125; .right &#123; height: 100%; background: pink; flex: 1; &#125; &lt;/style&gt; 方法五：使用table和table-cell实现 &lt;style&gt; .content &#123; border: 1px solid #000; width: 100%; height: 800px; display: table; &#125; .left &#123; width: 200px; height: 100%; background: red; display: table-cell; &#125; .right &#123; height: 100%; background: pink; display: table-cell; &#125; &lt;/style&gt; 方法六：使用inline-block携手calc函数设置宽度 &lt;style&gt; .content &#123; border: 1px solid #000; width: 100%; height: 800px; font-size: 0; &#125; .left &#123; width: 200px; height: 100%; background: red; display: inline-block; vertical-align: top; &#125; .right &#123; height: 100%; background: pink; display: inline-block; vertical-align: top; width: calc(100% - 200px); font-size: 16px; &#125; &lt;/style&gt; css 选择器有哪些，权重是什么样的选择器含义：选择器是查找页面元素的一种方式方法，选择器的种类有很多种。常用的选择器有以下内容： ID #id class .class 标签 p 通用 * 属性 type&#x3D;”text” 伪类 :link :visited :hover :active 伪元素 ::first-line :first-letter 子选择器 div&gt;p 后代选择器 div p 相邻兄弟 div+p 通用兄弟 div~p 结构伪类 :nth-child :first-child :last-child 权重计算规则： 第一等：代表内联样式，如: style&#x3D;””，权值为1000。 第二等：代表ID选择器，如：#content，权值为0100。 第三等：代表类，伪类和属性选择器，如.content，权值为0010。 第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。 通配符、*权值为0000。 继承的样式没有权重值。 important &gt; 内联 &gt; ID &gt; 类| 伪类 | 属性选择|伪对象 &gt; 标签 &gt; 继承 &gt; 通配符","tags":["一阶段面试题集锦"],"categories":["前端面试题"]},{"title":"菜单栏多色图标","path":"/2023/05/03/15/","content":"这篇文章引自这里https://www.fomal.cc/posts/5389e93f.html,作者怕文章丢失就写在这里啦！找到自己想要的矢量图标推荐网站阿里巴巴矢量图标库 引入下载js代码(butterfly下面的_config.yml)inject: bottom: - &lt;script src=&quot;/hexo/download/shiLiang/iconfont.js&quot;&gt;&lt;/script&gt; 替换[BlogRoot]\\themes\\butterfly\\layout\\includes\\header\\menu_item.pug为以下代码if theme.menu .menus_items each value, label in theme.menu if typeof value !== &#x27;object&#x27; .menus_item - const valueArray = value.split(&#x27;||&#x27;) a.site-page.faa-parent.animated-hover(href=url_for(trim(value.split(&#x27;||&#x27;)[0]))) if valueArray[1] i.fa-fw(class=trim(valueArray[1])) - var icon_value = trim(value.split(&#x27;||&#x27;)[1]) - var anima_value = value.split(&#x27;||&#x27;)[2] ? trim(value.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_value.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_value + &#x27; &#x27; + anima_value) else if icon_value.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_value) use(xlink:href=`#`+ icon_value) span=&#x27; &#x27;+label else .menus_item - const labelArray = label.split(&#x27;||&#x27;) - const hideClass = labelArray[3] &amp;&amp; trim(labelArray[3]) === &#x27;hide&#x27; ? &#x27;hide&#x27; : &#x27;&#x27; a.site-page.group.faa-parent.animated-hover(class=`$&#123;hideClass&#125;` href=&#x27;javascript:void(0);&#x27;) if labelArray[1] - var icon_label = trim(label.split(&#x27;||&#x27;)[1]) - var anima_label = label.split(&#x27;||&#x27;)[2] ? trim(label.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_label.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_label + &#x27; &#x27; + anima_label) else if icon_label.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_label) use(xlink:href=`#`+ icon_label) span=&#x27; &#x27;+ trim(labelArray[0]) i.fas.fa-chevron-down ul.menus_item_child each val,lab in value - const valArray = val.split(&#x27;||&#x27;) li a.site-page.child.faa-parent.animated-hover(href=url_for(trim(val.split(&#x27;||&#x27;)[0]))) if valArray[1] - var icon_val = trim(val.split(&#x27;||&#x27;)[1]) - var anima_val = val.split(&#x27;||&#x27;)[2] ? trim(val.split(&#x27;||&#x27;)[2]) : &#x27;faa-tada&#x27; if icon_val.substring(0,2)==&quot;fa&quot; i.fa-fw(class=icon_val + &#x27; &#x27; + anima_val) else if icon_val.substring(0,4)==&quot;icon&quot; svg.icon(aria-hidden=&quot;true&quot; class=anima_val) use(xlink:href=`#`+ icon_val) span=&#x27; &#x27;+ lab 配置butterfly下面的_config.ymlmenu: 首页: / || icon-shouye2 文章 || icon-xiewenzhang: 归档: /archives/ || icon-guidang 标签: /tags/ || icon-biaoqian 分类: /categories/ || icon-fenlei 友链: /link/ || icon-LINKS 我的: /about/ || icon-gerenzhongxin_wodediqu 留言板: /message/ || icon-liuyanban","tags":["butterfly"],"categories":["魔改"]},{"title":"依赖包与vue版本冲突问题","path":"/2023/05/02/14/","content":"😀😀这篇文章是根据作者自身犯的错误写的，在遇到同类错误时，请根据具体情况去找到自己的错误哦！！ 出现的问题当你下载某个模块时： 错误的解释：这是一个 npm 依赖冲突的错误。具体来说，在解决包的依赖关系时，npm 发现主项目使用了vue: 2.6.14，然后 vue-router 依赖于vue: 3.2.0，两个版本不兼容，导致冲突。 解决方法: 可以尝试在 npm install 命令后加上 –force 或 –legacy-peer-deps 参数来忽略错误，但这可能会导致包的版本兼容性问题。 更好的方法是解决依赖冲突，使得主项目和 vue-router 使用相同的 vue 版本，或者使用兼容的版本。 解决依赖冲突 在 package.json 中修改 vue 的版本号，将版本号更新为 “^3.2.0”（或者，将 vue 的版本设置为 “~2.6.14”，这意味着允许在小版本更新范围内更新版本号） 执行命令：npm update vue 再次执行命令：npm install 命令解释：执行 npm update vue 命令后，npm 会检查所有引用 vue 的包，并在这些包中寻找符合 vue 版本要求的中间版本。如果找到了可更新的版本，npm 就会下载并安装它们。但是，它并不会在 package.json 文件中更新版本号。因此，第三步执行的是 npm install 命令，这样可以确保更新后的依赖关系被记录在 package.json 文件中，以便将来进行版本控制。注意，如果 npm update vue 命令没有更新任何依赖项，则可以跳过第三步。","tags":["vue"],"categories":["前端进阶"]},{"title":"WgpSec CTF(web:尝试找到你的小姐姐吧)","path":"/2023/05/01/13/","content":"作者的啰嗦这是作者第一次更新有关ctf题目的文章，那么什么是CTF比赛呢？CTF是一种流行的信息安全竞赛形式，其英文名可直译为”夺得Flag”，也可意译为”夺旗赛”。其大致流程是，参赛团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。为了方便称呼，我们把这样的内容称之为”Flag”。具体的的一些细节，我就不在这里说明了，如果您对CTF感兴趣的话，可以具体找找相关说明。 题目的网站这里是WgpSec CTF官方网站https://ctf.wgpsec.org，然后找到web题目:尝试找到你的小姐姐吧 开始做题在正式开始之前，你需要了解如下： 什么是robots协议 电脑已经有了Python环境，并且下载了pip（我的解题思路会用到Python脚本） 正式开始点进去后发现是这样的 什么都没有先查看一下源代码： 他说百度收录不了，那肯定就是robots协议，什么是robots协议呢？Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。试着访问&#x2F;robots.txt: 发现一个路径：&#x2F;readme_hahah.txt，试着访问它： 这里的信息特别多： 首先用户名是admin 密码是5位的数字 网站的登录网址（被遮盖了一部分） base32位解码将Hint的内容进行base32位解码（网上在线解码即可）： 提示我们用记事本打开最初的那张照片，那我们先右键图片进行下载后打开。可以找到： 这就是登录网址被遮盖的一部分：&#x2F;7b6ca699输入网址：http://web.t.ctf.wgpsec.org/notjustweb/7b6ca699/login.html 脚本爆破这里作者的方法是用Python进行爆破：import requests def num(x): mmm = 6 - x item1 = &#x27;&#x27; ooo = range(1, mmm) for it in ooo: item1 += &#x27;0&#x27; return item1 # url = &#x27;http://web.t.ctf.wgpsec.org/notjustweb/7b6ca699/login.php&#x27; data = &#123;&#x27;username&#x27;: &#x27;admin&#x27;, &#x27;password&#x27;: &#x27;00000&#x27;, &#x27;verifycode&#x27;: &#x27;&#x27;, &#x27;submit&#x27;: &#x27;&#x27;&#125; a = range(0, 10000) for item in a: stritem = str(item) newitem = num(len(stritem)) + stritem data[&#x27;password&#x27;] = newitem r = requests.post(url, data) print(r.text + newitem) 得到flag：","tags":["web"],"categories":["ctf"]},{"title":"基于hexo的搜索功能","path":"/2023/04/23/12/","content":"安装依赖包npm install hexo-generator-search 添加代码至hexo下面的_config.yml文件search: path: search.xml field: post content: true 修改butterfly下面的_config.yml文件local_search: enable: true preload: true 最后在重新部署即可","tags":["hexo"],"categories":["魔改"]},{"title":"更换博客背景2.0版本（自由选择）","path":"/2023/04/18/11/","content":"感觉用js去写html确实有点难度啊，而且js去写html的代码真的很乱（站长能力有限，只能写出这样的代码了，我会继续学习，优化自己的代码的，哈哈哈哈），维护起来不容易啊！！！ 更改后的js代码// 适合于电脑的背景 var arrImg = [&#x27;https://www.toopic.cn/public/uploads/small/1634204095151163420409592.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/163420343597163420343525.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1637562996238163756299635.png&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1642751534826164275153484.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1642751487281164275148774.png&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1642751473324164275147339.png&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/164275143227816427514329.png&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1642751024946164275102446.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1642750988739164275098839.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/164275047944164275047961.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/164275045439516427504541.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1642750432122164275043293.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1637562995904163756299548.png&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1634204739682163420473994.jpg&#x27; ] // 适合于手机的背景 var arrImg_1=[&#x27;https://www.toopic.cn/public/uploads/small/1643009966127164300996671.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1643009930474164300993032.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1643009928240164300992847.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1642756678726164275667880.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1643009950579164300995042.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1643009929331164300992978.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/16430099287616430099288.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1643009925630164300992534.jpg&#x27;, &#x27;https://www.toopic.cn/public/uploads/small/1643009891321164300989160.jpg&#x27; ] var a = document.querySelector(&#x27;.full_page&#x27;) var b = document.querySelector(&#x27;.menus_item&#x27;) var c = document.querySelector(&#x27;#menus&#x27;) var odiv = document.createElement(&#x27;div&#x27;) //创建一个div标签 var suoying = parseInt(Math.random() * arrImg.length) //用来记录是第几张图片 var suoying_1 = parseInt(Math.random() * arrImg_1.length) //用来记录是第几张图片 odiv.innerHTML = &#x27;&lt;svg t=&quot;1681093944846&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;4217&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M947.2 173.248c6.912 0 12.8 5.888 12.8 12.8v615.232c0 6.912-5.888 12.8-12.8 12.8H76.8c-6.912 0-12.8-5.888-12.8-12.8V186.048c0-6.912 5.888-12.8 12.8-12.8h870.4m0-64H76.8c-42.24 0-76.8 34.56-76.8 76.8v615.232c0 42.24 34.56 76.8 76.8 76.8h870.4c42.24 0 76.8-34.56 76.8-76.8V186.048c0-42.24-34.56-76.8-76.8-76.8z&quot; fill=&quot;blue&quot; p-id=&quot;4218&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M694.4 760.192H117.824l242.176-257.28c25.344-26.944 66.88-26.944 92.224 0l242.176 257.28z&quot; fill=&quot;aqua&quot; p-id=&quot;4219&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M906.176 760.192H519.296l87.552-92.992 59.84-63.552c25.28-26.944 66.816-26.944 92.16 0l147.328 156.544z&quot; fill=&quot;aqua&quot; p-id=&quot;4220&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M649.792 341.952m-62.976 0a62.976 62.976 0 1 0 125.952 0 62.976 62.976 0 1 0-125.952 0Z&quot; fill=&quot;aqua&quot; p-id=&quot;4221&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;span&gt;更换背景&lt;/span&gt;&#x27; odiv.id = &#x27;custom&#x27; //给自己创建的div标签挂一个id属性，方便对其样式进行修改 // 生成弹窗 var al = document.querySelector(&#x27;#sidebar&#x27;) $alert1 = document.createElement(&#x27;div&#x27;) $alert2 = document.createElement(&#x27;div&#x27;) $alert5 = document.createElement(&#x27;div&#x27;) $alert6 = document.createElement(&#x27;div&#x27;) $alert7 = document.createElement(&#x27;div&#x27;) $alert8 = document.createElement(&#x27;div&#x27;) $alert9 = document.createElement(&#x27;div&#x27;) $alert10 = document.createElement(&#x27;div&#x27;) $alert11 = document.createElement(&#x27;div&#x27;) $alert12 = document.createElement(&#x27;div&#x27;) $alert13 = document.createElement(&#x27;div&#x27;) $alert14 = document.createElement(&#x27;div&#x27;) $input = document.createElement(&#x27;input&#x27;) $alert1.id = &#x27;alert&#x27; $alert2.id = &#x27;alertcenter&#x27; $alert10.innerHTML = &#x27;🥥🥥更换背景&#x27; $alert7.innerHTML = &#x27;自定义背景：&#x27; $alert8.innerHTML = &#x27;更改&#x27; $alert9.innerHTML = &#x27;&lt;label&gt;×&lt;/label&gt;&#x27; $alert12.innerHTML = &#x27;适合于电脑的背景:&#x27; $alert13.innerHTML = &#x27;适合于手机的背景:&#x27; $alert5.id = &#x27;alertcenterHeader&#x27; $alert6.id = &#x27;alertcenterContent&#x27; $alert8.id = &#x27;aaa&#x27; $alert11.id = &#x27;bbb&#x27; $alert14.id = &#x27;alertcenterContent_1&#x27; $input.type = &#x27;text&#x27; $input.placeholder = &#x27;请输入自定义背景的链接&#x27; $input.id = &#x27;alertcenterContentInput&#x27; odiv.onclick = function() &#123; $alert1.style.display = &#x27;block&#x27; &#125; c.appendChild(odiv) console.log(window.document.documentElement.clientWidth) if(window.document.documentElement.clientWidth&lt;500)&#123; a.style.backgroundImage = `url($&#123;arrImg_1[suoying_1]&#125;)` &#125;else&#123; a.style.backgroundImage = `url($&#123;arrImg[suoying]&#125;)` &#125; al.onclick = function(evt) &#123; // 这个if语句是为了只有点击空白处时才会关闭弹窗 if (evt.target.id == &#x27;alert&#x27;) &#123; $alert1.style.display = &#x27;none&#x27; &#125; &#125; // ×的点击事件 $alert9.onclick = function() &#123; $alert1.style.display = &#x27;none&#x27; &#125; // 判读照片链接的函数 function checkImg(imgUrl) &#123; return new Promise((resolve, reject) =&gt; &#123; var ImgObj = new Image() ImgObj.src = imgUrl ImgObj.onload = function(res) &#123; resolve(res) &#125; ImgObj.onerror = function(err) &#123; reject(err) &#125; &#125;) &#125; // 更改的事件 $alert8.onclick = function() &#123; checkImg($input.value).then(() =&gt; &#123; a.style.backgroundImage = `url($&#123;$input.value&#125;)` &#125;).catch(() =&gt; &#123; alert(&#x27;照片链接错误&#x27;) &#125;) &#125; al.appendChild($alert1) $alert1.appendChild($alert2) $alert2.appendChild($alert5) $alert2.appendChild($alert12) $alert2.appendChild($alert6) $alert2.appendChild($alert13) $alert2.appendChild($alert14) $alert2.appendChild($alert7) $alert2.appendChild($input) $alert2.appendChild($alert8) $alert5.appendChild($alert11) $alert11.appendChild($alert10) $alert11.appendChild($alert9) // 根据存放的照片数量创建img标签 // 电脑背景 for (let i = 0; i &lt; arrImg.length; i++) &#123; var img = document.createElement(&#x27;img&#x27;) img.src = arrImg[i] img.onclick = function() &#123; a.style.backgroundImage = `url($&#123;arrImg[i]&#125;)` &#125; $alert6.appendChild(img) &#125; // 手机背景 for (let i = 0; i &lt; arrImg_1.length; i++) &#123; var img = document.createElement(&#x27;img&#x27;) img.src = arrImg_1[i] img.onclick = function() &#123; a.style.backgroundImage = `url($&#123;arrImg_1[i]&#125;)` &#125; $alert14.appendChild(img) &#125; // 适配黑夜模式 var changeDark = document.querySelector(&#x27;#darkmode&#x27;) var win = document.querySelector(&#x27;html&#x27;) onscroll = function() &#123; //滚动条滚动就会触发 if(win.dataset.theme==&#x27;dark&#x27;)&#123; odiv.style.color = &#x27;white&#x27; &#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125; &#125; &#125; changeDark.onclick=function()&#123; // console.log(win.dataset.theme) if(win.dataset.theme==&#x27;light&#x27;)&#123; odiv.style.color = &#x27;white&#x27; $alert2.style.backgroundColor=&#x27;#1c1a1a&#x27; $alert5.style.backgroundColor=&#x27;#283536&#x27; $input.style.backgroundColor=&#x27;black&#x27; &#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125; $alert2.style.backgroundColor=&#x27;white&#x27; $alert5.style.backgroundColor=&#x27;#a3e9eb&#x27; $input.style.backgroundColor=&#x27;white&#x27; &#125; &#125; if(win.dataset.theme==&#x27;dark&#x27;)&#123; odiv.style.color = &#x27;white&#x27; $alert2.style.backgroundColor=&#x27;#1c1a1a&#x27; $alert5.style.backgroundColor=&#x27;#283536&#x27; $input.style.backgroundColor=&#x27;black&#x27; &#125;else&#123; if (window.document.documentElement.scrollTop &gt; 0) &#123; odiv.style.color = &#x27;black&#x27; &#125; else &#123; odiv.style.color = &#x27;white&#x27; &#125; &#125; 更改后的css代码 /* 背景更换 */ #custom&#123; display: flex; justify-content: space-between; align-items: center; position: absolute; width: 90px; height: 40px; right: 485px; top: 12px; font-size: 0.78em; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif; transition: all 1s; margin-right: 5px; color: white; &#125; #custom:hover&#123; transform: translateX(-0.5rem); &#125; @media screen and (max-width:768px) &#123; #custom&#123; right: 70px; &#125; &#125; @media screen and (min-width:768px) and (max-width:824px) &#123; #custom&#123; right: 90px; &#125; &#125; @media screen and (max-width:350px) &#123; #custom&#123; right: 10px; top: 40px; &#125; &#125; .icon &#123; width: 1.5em; height: 1.5em; vertical-align: -0.45em; fill: currentColor; overflow: hidden; &#125; /* 更换背景的弹窗 */ #alert&#123; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; background-color: rgba(0, 0, 0, 0.8); z-index: 999; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif;; display: none; &#125; #alertcenter&#123; width: 70%; height: 70%; background-color: white; border-radius: 10px; overflow: auto; position: relative; margin: 10vh auto; &#125; #alertcenterHeader&#123; width:70%; height: 33px; background-color: #a3e9eb; line-height: 33px; font-size: 1.1rem; border-radius: 5px 5px 0 0; position: fixed; z-index: 100; &#125; @media screen and (max-width:521px) &#123; #alertcenter&#123; width: 100%; height: 90%; margin: 5vh 0; &#125; #alertcenterHeader&#123; width: 100%; &#125; &#125; #alertcenterContent&#123; width: 100%; display: flex; justify-content: center; flex-wrap: wrap; margin-top: 30px; &#125; #alertcenterContent img&#123; margin: 15px; width: 15%; border-radius: 5px; &#125; #alertcenterContent_1&#123; width: 100%; display: flex; justify-content: center; flex-wrap: wrap; &#125; #alertcenterContent_1 img&#123; margin: 15px; width: 20%; border-radius: 5px; &#125; @media screen and (max-width:780px) &#123; #alertcenterContent img&#123; width: 25%; &#125; &#125; @media screen and (max-width:400px) &#123; #alertcenterContent img&#123; width: 35%; &#125; &#125; #alertcenterContentInput&#123; width: 80%; height: 30px; font-size: 14px; border-radius: 10px; border: 1px solid deepskyblue; display: inline-block; margin-left: 20px; &#125; #aaa&#123; width: 3.875rem; height: 25px; line-height: 25px; text-align: center; font-size: 0.9rem; border: 1px solid black; display: inline-block; margin-left: 0.5rem; border-radius: 4px; &#125; #bbb&#123; height: 33px; display: flex; justify-content: space-between; align-items: center; &#125; #bbb div:nth-child(2)&#123; font-size: 25px; position: fixed; right: 10px; &#125; #alertcenter div:nth-child(2)&#123; position: relative; top: 34px; &#125; 这篇文章后续会持续修改的，请关注一下哦！！！","tags":["butterfly"],"categories":["魔改"]},{"title":"更换博客背景1.0版本（随机背景）","path":"/2023/04/16/10/","content":"提前声明要想完成这个功能你必须会前端三大件（html,css,js）的基础知识，不然你就只能照搬作者的代码，但是里面的内容你是看不懂的哦！！！ 自建与引入css与js文件相信大家应该已经学会了这个步骤了，如果不会的请先移步这篇文章自定义css与js js的代码var arrImg=[&#x27;https://www.toopic.cn/public/uploads/small/1634204095151163420409592.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/163420343597163420343525.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642752073265164275207379.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751728155164275172815.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751487281164275148774.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751473324164275147339.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/164275143227816427514329.png&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642751024946164275102446.jpg&#x27;,&#x27;https://www.toopic.cn/public/uploads/small/1642750988739164275098839.jpg&#x27;] var a=document.querySelector(&#x27;.full_page&#x27;) var b=document.querySelector(&#x27;.menus_item&#x27;) var c=document.querySelector(&#x27;#menus&#x27;) var odiv=document.createElement(&#x27;div&#x27;) //创建一个div标签 var suoying=parseInt(Math.random()*arrImg.length) //用来记录是第几张图片 odiv.innerHTML=&#x27;&lt;svg t=&quot;1681093944846&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; p-id=&quot;4217&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;path d=&quot;M947.2 173.248c6.912 0 12.8 5.888 12.8 12.8v615.232c0 6.912-5.888 12.8-12.8 12.8H76.8c-6.912 0-12.8-5.888-12.8-12.8V186.048c0-6.912 5.888-12.8 12.8-12.8h870.4m0-64H76.8c-42.24 0-76.8 34.56-76.8 76.8v615.232c0 42.24 34.56 76.8 76.8 76.8h870.4c42.24 0 76.8-34.56 76.8-76.8V186.048c0-42.24-34.56-76.8-76.8-76.8z&quot; fill=&quot;blue&quot; p-id=&quot;4218&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M694.4 760.192H117.824l242.176-257.28c25.344-26.944 66.88-26.944 92.224 0l242.176 257.28z&quot; fill=&quot;aqua&quot; p-id=&quot;4219&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M906.176 760.192H519.296l87.552-92.992 59.84-63.552c25.28-26.944 66.816-26.944 92.16 0l147.328 156.544z&quot; fill=&quot;aqua&quot; p-id=&quot;4220&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M649.792 341.952m-62.976 0a62.976 62.976 0 1 0 125.952 0 62.976 62.976 0 1 0-125.952 0Z&quot; fill=&quot;aqua&quot; p-id=&quot;4221&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;span&gt;更换背景&lt;/span&gt;&#x27; odiv.id=&#x27;custom&#x27; //给自己创建的div标签挂一个id属性，方便对其样式进行修改 odiv.onclick=function()&#123; suoying++ if(suoying===arrImg.length)&#123; suoying=0 a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)` &#125;else&#123; a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)` &#125; &#125; c.appendChild(odiv) onscroll=function()&#123; //滚动条滚动就会触发 if(window.document.documentElement.scrollTop&gt;0)&#123; odiv.style.color=&#x27;black&#x27; &#125;else&#123; odiv.style.color=&#x27;white&#x27; &#125; &#125; a.style.backgroundImage=`url($&#123;arrImg[suoying]&#125;)` 这里的arrImg数组用来存放照片的链接，可以自行添加照片的链接 css的代码#custom&#123; display: flex; justify-content: space-between; align-items: center; position: absolute; width: 90px; height: 40px; right: 420px; /* 请根据自己的导航栏长度进行修改位置 */ top: 12px; font-size: 0.78em; font-family: YSHST, -apple-system, &#x27;Quicksand&#x27;, &#x27;Nimbus Roman No9 L&#x27;, &#x27;PingFang SC&#x27;, &#x27;Hiragino Sans GB&#x27;, &#x27;Noto Serif SC&#x27;, &#x27;Microsoft Yahei&#x27;, &#x27;WenQuanYi Micro Hei&#x27;, &#x27;ST Heiti&#x27;, sans-serif; transition: all 1s; margin-right: 5px; color: white; &#125; #custom:hover&#123; transform: translateX(-0.5rem); &#125; @media screen and (max-width:768px) &#123; #custom&#123; right: 40px; /* 请根据自己的导航栏长度进行修改位置 */ &#125; &#125; @media screen and (max-width:350px) &#123; #custom&#123; right: 10px; top: 40px; &#125; &#125; .icon &#123; width: 1.5em; height: 1.5em; vertical-align: -0.45em; fill: currentColor; overflow: hidden; &#125; 最后不要忘记引入了了哦，小伙伴们！！！ 部署后没有生效的原因如果刷新后没有生效，可以试着清除浏览器数据，再打开自己的博客网站","tags":["butterfly"],"categories":["魔改"]},{"title":"创建express项目","path":"/2023/04/15/9/","content":"安装express我这里是全局安装，去掉-g就不是全局了 npm install -g express-generator 生成express项目express myapp 默认生成的是jade的渲染模板更改渲染模板(ejs) express --view=ejs myapp 启动express项目在这之前请先执行（下载相关的依赖包）： npm i 启动： node ./bin/www 查看是否成功express项目默认占用的是3000端口所以去浏览器输入地址http://localhost:3000看看自己有没有成功吧！！","tags":["node"],"categories":["前端进阶"]},{"title":"vue-cli创建vue项目","path":"/2023/04/11/8/","content":"安装vue-clinpm install -g @vue/cli 创建vue项目vue create &lt;文件夹名字&gt; 出现： 可以选择默认的vue2项目或者vue3项目，也可以选择最后一条进行手动配置哦启动项目下载完成后尝试启动vue项目在终端执行： npm run serve 暂时关闭代码格式检测找到vue.config.js的文件（没有就自己创建） const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;) module.exports = defineConfig(&#123; transpileDependencies: true, lintOnSave: false, // 暂时关闭代码格式检测 &#125;)","tags":["vue"],"categories":["前端进阶"]},{"title":"利用css画图形","path":"/2023/04/10/7/","content":"利用border属性画一个三角形&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box&#123; width: 100px; height: 50px; background: blue; color: white; &#125; .box1&#123; width: 0; height: 0; border: 10px solid rgb(0,0,0,0); /* 将所有边框都透明显示 */ border-top: 10px solid red; /* 只显示上面的边框 */ display: inline-block; position: relative; top: 7px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;导航&lt;span class=&quot;box1&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 利用clip-path属性画一个三角形&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box1&#123; width: 200px; height: 200px; background-color: red; clip-path: polygon(50% 0%, 0% 100%, 100% 100%); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 怎么样这种方法是不是很方便呢，clip-path属性可不仅仅是画一个简单的三角形，可以画的图形可比你想的还要多呢 clip-path绘制简单图形这里作者就提供一下网站http://tools.jb51.net/code/css3path","tags":["css"],"categories":["前端3大件"]},{"title":"自定义css与js","path":"/2023/04/08/6/","content":"找到butterfly下面的source文件夹（hexo目录下的source文件夹也一样）这是一个静态目录里面可以自定义自己的css与js文件，其实不光是css与js，你的图片与下载好的字体都可以放在这里面 尝试修改自己主题的样式吧如果你还不会css与js，建议前往学习哦！！这里站长就给你提供简单的一个例子在你自定义的css文件下添加一下代码 /* 侧边栏个人信息卡片动态渐变色 */ #aside-content &gt; .card-widget.card-info &#123; background: linear-gradient( -45deg, #e8d8b9, #eccec5, #a3e9eb, #bdbdf0, #eec1ea ); box-shadow: 0 0 5px rgb(66, 68, 68); position: relative; background-size: 400% 400%; -webkit-animation: Gradient 10s ease infinite; -moz-animation: Gradient 10s ease infinite; animation: Gradient 10s ease infinite !important; &#125; @-webkit-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; @-moz-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; @keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125; &#125; /* 黑夜模式适配 */ [data-theme=&quot;dark&quot;] #aside-content &gt; .card-widget.card-info &#123; background: #191919ee; &#125; /* 个人信息Follow me按钮 */ #aside-content &gt; .card-widget.card-info &gt; #card-info-btn &#123; background-color: #3eb8be; border-radius: 8px; &#125; 引入css文件 这里虽然是引入字体的地方，也是可以引入css文件的(最好字体的引入与主要的css文件分开)blog_title_font: font_link: css/custom.css 主要在这里引入inject: head: # - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/custom.css&quot;&gt; 赶快去试试看自己有没有成功吧！！！ 引入js文件提供一下js的简单代码，用于测试有没有成功引入 console.log(&#x27;欢迎访问lazychild&#x27;) 开始引入: inject: bottom: - &lt;script src=&quot;js/custom.js&quot;&gt;&lt;/script&gt; 成功后重启服务器，打开页面后，按下F12打开console，看看有没有’欢迎访问lazychild’这句话吧，如果有，你就成功了 需要注意小伙伴有没有注意到我这里的引入都是本地引入呢，会出现许多的问题，比如我在引入本地css文件时，只有在首页才有效果，其他页面的没有生效，这就是相对路径引入的问题了，更换引入路径（外网）： #这是我自己的字体的css文件 @font-face &#123; /* 为载入的字体取名字(随意) */ font-family: &#x27;YSHST&#x27;; /* 字体文件地址(相对或者绝对路径都可以) */ src: url(https://xiao-zhe-is-not-lazy.gitee.io/hexo/font/%E9%9C%9E%E9%B6%A9%E6%96%87%E6%A5%B7TC%20Bold_mianfeiziti.com.woff2); /* 定义加粗样式(加粗多少) */ font-weight: normal; /* 定义字体样式(斜体/非斜体) */ font-style: normal; /* 定义显示样式 */ font-display: block; &#125; 然后在修改butterfly下的_config.yml blog_title_font: font_link: https://xiao-zhe-is-not-lazy.gitee.io/hexo/css/custom/font.css inject: head: - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://xiao-zhe-is-not-lazy.gitee.io/hexo/css/custom/main.css&quot;&gt; bottom: - &lt;script src=&quot;https://xiao-zhe-is-not-lazy.gitee.io/hexo/js/custom.js&quot;&gt;&lt;/script&gt; 或者(省略掉前面的域名)： inject: head: - &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/hexo/css/custom/main.css&quot;&gt; bottom: - &lt;script src=&quot;/hexo/js/custom.js&quot;&gt;&lt;/script&gt; 在本地运行的问题主要就是同源策略的问题，关于什么是同源策略(不同域名，不同端口下就会发生)，就是一个约定，它是浏览器最核心也最基本的安全功能，注意同源策略只会发生在浏览器之间，如果没有同源策略，那么就可以请求任意网站的数据了,直接推送到远程就行，同源策略这个问题就会消失了哦！","tags":["butterfly"],"categories":["魔改"]},{"title":"开启文章封面","path":"/2023/04/07/5/","content":"默认封面的开启找到butterfly下面的_config.yml的文件 cover: # display the cover or not (是否顯示文章封面) index_enable: true aside_enable: true archives_enable: true # the position of cover in home page (封面顯示的位置) # left/right/both position: both # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示) default_cover: - https://lskypro.acozycotage.net/Fomalhaut/img/default_cover_14.webp 在default_cover:添加默认封面的图片链接 文章自定义封面开启只要在文章开始添加一个属性 cover: https://lskypro.acozycotage.net/Fomalhaut/img/default_cover_5.webp 图片来源 直接去别的网站寻找 建立一个远程仓库，将自己的图片放入 图片直接转链接，推荐网站：https://www.imgbed.link/ 重启服务器$ hexo cl $ hexo s","tags":["butterfly"],"categories":["魔改"]},{"title":"butterfly关于logo图标与头像的增加","path":"/2023/04/06/4/","content":"准备好您的logo很多小伙伴可能对于设计logo这方面没有任何经验，但是又急缺logo，作者在这里推荐一个在线设计logo的网站https://www.logosc.cn/start 关于下载logo需要付费的问题作者这里提供给大家一个小妙招，直接截屏 去掉图片背景颜色大家直接在线去除就行https://www.easeconvert.com/image-remove-background/ 修改配置首先找到butterfly的_config.yml的文件 #修改主页的logo nav: logo: img/logo.png display_title: true fixed: true # fixed navigation bar #修改网站标题的logo favicon: /img/favicon.ico #修改头像 avatar: img: /img/tou.png effect: false","tags":["butterfly"],"categories":["魔改"]},{"title":"butterfly的安装使用与导航栏基础","path":"/2023/04/04/3/","content":"首先安装butterfly主题在你的根目录下执行 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 应用butterfly主题找到你hexo的_config.yml文件，更改配置 theme: butterfly 可能出现的问题(安装插件)如果你沒有 pug 以及 stylus 的渲染器，请下载安裝： npm install hexo-renderer-pug hexo-renderer-stylus --save butterfly导航栏的配置默认 Home: / || fas fa-home Archives: /archives/ || fas fa-archive Tags: /tags/ || fas fa-tags Categories: /categories/ || fas fa-folder-open List||fas fa-list: Music: /music/ || fas fa-music Movie: /movies/ || fas fa-video Link: /link/ || fas fa-link About: /about/ || fas fa-heart 生成新的页面默认安装完成后的butterfly缺少的许多页面，可以根据自己的需要生成举个例子，假如我要生成Tags页面 hexo new page tags 注意新页面的配置增加一个类型 type: tags","tags":["butterfly"],"categories":["魔改"]},{"title":"如何部署至Gitee","path":"/2023/04/03/2/","content":"网上也有许多教程，这里作者就是做了一个整理 创建一个Gitee仓库如果不会创建远程仓库的同学，可以先去学习一下哦 开启Gitee Pages先将远程仓库开源，然后在服务选项那里有一个Gitee Pages点进去开启就行(必须设置为开源哦) 一键部署的前提下载hexo-deployer-git $ npm install hexo-deployer-git 配置hexo下面的_config.ymldeploy: type: git repo: (你自己仓库的地址) branch: master 可以在这里找到自己仓库的地址哦 url: 开启Gitee Pages服务的地址 root: 网站的根目录（/&lt;根目录的文件夹名字&gt;） 终端执行的命令hexo cl ##清除缓存 hexo g ##生成网站静态文件到默认设置的 public 文件夹 hexo d ##远程推送至仓库 更新记得更新您的Gitee Pages可能有延迟","tags":["hexo"],"categories":["魔改"]},{"title":"hexo的安装与使用","path":"/2023/04/02/1/","content":"为什么要使用hexo？hexo简单好用 下载node作者这里就只提供一下网站了，安装很简单，node 下载git不会git，建议先学习，这里推荐下载git的比较快的网站，git 查看版本$ node -v 下载Hexo$ npm install -g hexo-cli 安装Hexo在你的某个文件夹下，执行： $ hexo init 下一篇文章讲如何部署，很多细节哦","tags":["hexo"],"categories":["魔改"]},{"title":"关于站长","path":"/about/index.html","content":"刘哲路漫漫其修远兮,吾将上下而求索. 技术栈 html css js vue react node 微信小程序 uni-app hexo vant element echarts webpack vite nuxt vitepress 网页游戏开发 兴趣 代码 海贼 吉他 LoL 无畏契约 洛克王国 赚钱 个人作品 个人导航网站收录学习过程中的优质网站，项目，插件等湖南人文科技学院3D在线地图使用高德api搭建的3D在线地图"},{"title":"友链","path":"/friends/index.html","content":"一蓑烟雨的博客Joker2YueMiKeyAkilar糖果屋Fomalhaut🥝"},{"title":"动态","path":"/dynamic/index.html","content":"2024 年 4 月 8 日浏览器平滑滚动：html,body{ scroll-behavior:smooth; }2024 年 3 月 8 日nginx配置反向代理示例：# 配置反向代理 location /maoyan &#123; proxy_pass https://i.maoyan.com/api/mmdb/movie/v3/list/hot.json?ct=%E5%A8%84%E5%BA%95&amp;ci=274&amp;channelId=4; &#125;说明：当匹配到/maoyan路径请求时会进行反向代理2024 年 1 月 19 日css属性实现宽度自适应内容, width: fit-content;2024 年 1 月 7 日上天赐个我一位美丽的姑娘吧，我想谈恋爱了💓，哈哈哈哈"},{"title":"留言","path":"/comments/index.html","content":"Document new Valine({ el: '#vcomments', appId: '1Wgun0BNYRkq1uy13wzMTTlt-gzGzoHsz', appKey: 'LgkvFc6EjDZy8neCIKorXwET', placeholder: '欢迎大家来到程序猿小哲的博客,如果有什么想说的话，请留言给作者哦，作者会尽量快速回复大家的哦😜😜，注意邮箱一定不能写错哦，不然你就收不到作者的回复了', avatar: 'wavatar', pageSize: 4, requiredFields: ['mail'] })"}]